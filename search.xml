<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文了解大模型</title>
      <link href="/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一.相关概念"></a>一.相关概念</h2><h3 id="1-人工智能"><a href="#1-人工智能" class="headerlink" title="1. 人工智能"></a>1. 人工智能</h3><p><strong>人工智能</strong>是最大的一个概念，它是所有这些技术的终极目标和总称。它的目标是让机器像人类一样思考、学习、推理、感知和行动。</p><h3 id="2-机器学习"><a href="#2-机器学习" class="headerlink" title="2. 机器学习"></a>2. 机器学习</h3><p><strong>机器学习</strong>是实现人工智能的一种核心“方法”。它不再需要程序员为每一个具体任务编写硬编码的规则。相反，机器学习让机器通过分析大量数据来自己学习规律和模式，从而完成任务。它是人工智能的子集，解决了让机器“学习”的问题。</p><h3 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3. 深度学习"></a>3. 深度学习</h3><p><strong>深度学习</strong>是机器学习的一个“分支”。它使用一种特殊的算法——<strong>深度神经网络</strong>。这些网络由许多层的神经元组成，能够自动从原始数据中提取出复杂的特征，这比传统的机器学习算法更强大。</p><h3 id="4-预训练模型"><a href="#4-预训练模型" class="headerlink" title="4. 预训练模型"></a>4. 预训练模型</h3><p><strong>预训练模型</strong>是深度学习的一种“训练范式”或“策略”。传统的深度学习模型需要为每个任务从头开始训练，这耗时耗力且需要大量标注数据。预训练模型改变了这种模式：它先用一个通用的、海量的无标注数据集（如整个互联网的文本和图像）进行训练，让模型学习到通用的知识和表示。这个“预训练”阶段结束后，模型就可以作为一个基础，用于各种不同的下游任务，只需用少量的标注数据进行微调即可。</p><h3 id="5-大规模预训练模型"><a href="#5-大规模预训练模型" class="headerlink" title="5. 大规模预训练模型"></a>5. 大规模预训练模型</h3><p><strong>大规模预训练模型</strong>是预训练模型在“规模”上的一个“特殊阶段”或“进化形态”。当预训练模型的参数量、训练数据量以及计算资源都达到前所未有的规模（例如数百亿、上千亿参数）时，这些模型便不再只是简单的“知识迁移工具”。它们会涌现出新的、意想不到的能力，例如强大的零样本或少样本学习能力、复杂的推理能力和多模态理解能力。<br>我们今天所说的==<strong>大模型</strong>==，通常就是特指这一类模型。<br>==<strong>大模型</strong>==是基于强算法、大算力并通过大规模、多样化数据进行训练以适应广泛下游任务的模型，也可译为==<strong>基础模型</strong>== 。</p><h3 id="6-生成式AI"><a href="#6-生成式AI" class="headerlink" title="6.生成式AI"></a>6.生成式AI</h3><p><strong>生成式AI</strong>是一种可以生成文本、图像、代码、视频、音频等各种新内容的<strong>AI模型</strong>的统称。它与传统AI的区别在于，传统AI主要是分析和识别现有数据（例如，识别图片中的人脸），而生成式AI则是<strong>创造</strong>全新的、以前不存在的内容。</p><h3 id="7-AIGC"><a href="#7-AIGC" class="headerlink" title="7.AIGC"></a>7.AIGC</h3><p><strong>AIGC</strong>是<strong>AI生成的内容</strong>的简称，它更侧重于<strong>结果</strong>和<strong>应用层面</strong>。AIGC泛指由人工智能技术生成的所有内容，包括但不限于文本、图片、音频、视频、代码、游戏等。</p><h3 id="8-Agent"><a href="#8-Agent" class="headerlink" title="8.Agent"></a>8.Agent</h3><p>智能体是一个能够<strong>自主感知环境、做出决策并执行动作</strong>以实现特定目标的系统。它的核心是“行动”。</p><ul><li><strong>例子</strong>：你告诉一个智能体：“帮我总结今天所有未读邮件的主要内容，并用中文写一份报告存到我的Google Drive里。”<ul><li><strong>感知</strong>：智能体会调用Gmail API来读取你的邮件。</li><li><strong>决策与执行</strong>：<ol><li>判断哪些是“未读邮件”。</li><li>调用<strong>生成式AI</strong>（如GPT）来总结每封邮件的核心内容。</li><li>将所有的总结汇总，再次调用<strong>生成式AI</strong>将其整理成一份连贯的中文报告。</li><li>调用Google Drive API，将最终生成的文件保存到指定位置。</li></ol></li></ul></li><li><strong>特点</strong>：智能体<strong>主动管理了整个工作流</strong>，它可能调用了多次生成式AI和各种工具API，最终<strong>完成了你设定的目标，而不仅仅是生成了内容</strong>。</li></ul><h2 id="二-大模型概述"><a href="#二-大模型概述" class="headerlink" title="二.大模型概述"></a>二.大模型概述</h2><h3 id="1-大模型的分类"><a href="#1-大模型的分类" class="headerlink" title="1.大模型的分类"></a>1.大模型的分类</h3><p>按模型数据的媒体类型，大模型可以分为语言类大模型、音频处理大模型、计算机视觉  (包含图像和视频)，以及多模态大模型。<br><strong>（1）语言类大模型 (LLM)</strong></p><ul><li><strong>定义：</strong> 参数量级在十亿及以上的大型预训练语言模型。</li><li><strong>功能：</strong> 在大量文本数据上进行训练，能执行广泛的语言任务，如文本总结、翻译、情感分析等。</li><li><strong>示例：</strong> ChatGPT（3.5及以前版本）、文心一言、通义千问等。</li></ul><p><strong>（2）音频处理大模型</strong></p><ul><li><strong>定义：</strong> 利用深度学习技术处理海量音频数据，实现音频的识别、分类、生成等任务。</li><li><strong>功能：</strong> 处理的音频类型不限于语音，还包括音乐、自然声音等。</li><li><strong>示例：</strong> MusicGen、Whisper、音乐云等。</li></ul><p><strong>（3）计算机视觉 (CV) 大模型</strong></p><ul><li><strong>定义：</strong> 专用于计算机视觉任务的大型深度学习模型，通常采用卷积神经网络（CNN）等算法。</li><li><strong>功能：</strong> 在图像和视频领域取得了重要成果，可用于图像分类、目标检测、图像分割等。</li><li><strong>示例：</strong> 百度文心VIMER-UFO 2.0、华为盘古CV大模型、商汤INTERN大模型等。</li></ul><p><strong>（4）多模态大模型</strong></p><ul><li><strong>定义：</strong> 将文本、图像、视频、音频等多种模态信息联合起来进行训练的模型。</li><li><strong>优势：</strong> 相较于单模态模型，多模态大模型更符合人类认知习惯，接口更友好，任务支持更广泛，被认为是通往通用人工智能（AGI）的重要方向。</li><li><strong>示例：</strong> GPT-4、紫东太初等。</li></ul><h3 id="2-大模型的核心训练阶段"><a href="#2-大模型的核心训练阶段" class="headerlink" title="2.大模型的核心训练阶段"></a>2.大模型的核心训练阶段</h3><p><strong>（1）预训练阶段</strong><br>在海量、未标注的原始数据上进行初步训练，目的是让模型学习到通用的世界知识、特征和规律。这一阶段是模型构建知识库的基础。</p><ul><li>预训练阶段是大模型“打基础”的关键环节。在这个阶段，模型被投放到一个巨大的“知识海洋”中——也就是海量的无标注原始数据。这些数据可能来自网页、书籍、百科全书、论坛等，涵盖了各种主题和格式。</li><li>这个过程就像一个孩子通过阅读成千上万本书来学习世界的常识。模型通过分析这些数据，学习语言的语法、句法、语义，以及不同概念之间的关联，从而构建一个庞大的“世界知识图谱”。例如，它能学会“太阳”通常与“光明”、“热”和“白天”等词汇关联，而“月亮”则与“夜晚”、“阴影”和“星空”相关。</li></ul><p><strong>（2）指令微调阶段</strong><br>预训练后，模型在更具体、更小且有标注的数据集上进行进一步训练。这使得模型能更好地理解用户指令，适应特定任务的需求，从而提高其在特定领域的表现。</p><ul><li>预训练让模型拥有了“通识”，但它还不知道如何有效利用这些知识来回答具体问题。指令微调阶段就是教会模型“听懂人话”和“完成任务”。</li><li>在这个阶段，模型会接触到经过精心标注的<strong>指令-响应</strong>数据集。这些数据告诉模型，当用户提出某个特定问题（指令）时，模型应该如何给出恰当的回答（响应）。例如，数据集会包含“请帮我写一封感谢信”和“请为我总结这篇文章”等指令，并配上正确的示范回答。</li><li>通过学习这些<strong>有监督数据</strong>，模型能够将预训练阶段学到的通用知识，与具体的任务需求联系起来。这就像一个通识教育毕业的学生，开始接受专业的职业技能培训。指令微调使得模型不再只是一个庞大的知识库，而是一个能够理解并执行用户命令的智能助手。</li></ul><p><strong>（3）从人类反馈中强化学习 (RLHF)</strong><br>这一阶段是为了让模型更好地与人类的价值观对齐。通过与人类的互动和接收反馈，模型不断优化自身的行为和输出策略，持续改善生成内容的质量和准确性。</p><ul><li>RLHF 是大模型训练流程中的“精修”和“校准”阶段，旨在确保模型的行为与<strong>人类的价值观和偏好</strong>对齐。这个过程就像是请一位老师来纠正学生的行为，让他们不仅知识渊博，而且言行得体。</li><li>具体来说，RLHF 包含三个主要步骤：<ul><li><strong>收集人类偏好数据：</strong> 给模型一个提示（prompt），让它生成几个不同的回答。然后，请人类评估者对这些回答进行排序，评判哪个回答更好、更安全、更符合预期。</li><li><strong>训练奖励模型：</strong> 基于人类的评分数据，训练一个<strong>奖励模型</strong>（Reward Model）。这个模型能够预测人类对任何一个回答的偏好程度，从而模仿人类的“价值观”。<ul><li><strong>强化学习微调：</strong> 最后，利用这个奖励模型作为“虚拟老师”，通过<strong>强化学习算法</strong>来微调大模型。模型的目标是生成能获得最高“奖励分数”的回答。这使得模型在没有人类直接干预的情况下，也能自主地朝着更安全、更有帮助、更符合人类价值观的方向优化其输出。</li></ul></li></ul></li></ul><h3 id="3-大模型发展的四大核心要素"><a href="#3-大模型发展的四大核心要素" class="headerlink" title="3.大模型发展的四大核心要素"></a>3.大模型发展的四大核心要素</h3><p>大模型的成功发展离不开数据、算力、算法和应用这四大要素的协同作用。</p><ul><li><strong>数据：</strong> 这是大模型训练的基础资源。模型建立和内容落地都依赖于大规模、高质量的数据。原始数据必须经过专业的采集和加工，才能成为可供训练的高质量数据集。</li><li><strong>算力：</strong> 算力是支撑大模型训练和运行的基础设施。强大的算力，主要由GPU、FPGA和ASIC等高性能计算芯片提供，是模型迭代训练和推理的必要条件，也是实现“智慧涌现”能力的关键。</li><li><strong>算法：</strong> 算法是大模型学习和表达的必要路径。它决定了模型的学习能力，能够帮助模型从海量数据中挖掘潜在规律和模式，提升模型的鲁棒性。</li><li><strong>应用：</strong> 应用是推动大模型持续发展的核心和关键。成功的应用市场能够提供正向反馈，帮助大模型实现商业上的良性循环，弥补巨大的研发投入，同时用户反馈也为模型的迭代升级提供了宝贵的方向。<br><img src="/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/file-20250903180847548.png" alt></li></ul><h2 id="三-Tranformer"><a href="#三-Tranformer" class="headerlink" title="三.Tranformer"></a>三.Tranformer</h2><h3 id="1-Transformer架构"><a href="#1-Transformer架构" class="headerlink" title="1.Transformer架构"></a>1.Transformer架构</h3><p><img src="/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/file-20250904181155472.png" alt><br><img src="/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/file-20250904181224292.png" alt></p><p>假设有一个任务：</p><ul><li><strong>任务：</strong> 将中文“猫吃鱼”翻译成英文“The cat eats fish”。</li></ul><h4 id="第零步：预处理-创建-Token-令牌"><a href="#第零步：预处理-创建-Token-令牌" class="headerlink" title="第零步：预处理 - 创建 Token (令牌)"></a>第零步：预处理 - 创建 Token (令牌)</h4><p>计算机只认识数字，所以首先要创建词汇表并把词变成数字。</p><ol><li><strong>Tokenization (分词/令牌化)：</strong> 将句子拆成模型能处理的最小单位。比如：<ul><li>“猫吃鱼” -&gt; 被拆成三个 token： <code>['猫', '吃', '鱼']</code></li><li>“The cat eats fish” -&gt; 被拆成四个 token： <code>['The', 'cat', 'eats', 'fish']</code></li></ul></li><li><strong>映射到 ID：</strong> 每个 token 在模型的“字典”（词汇表）里都有一个唯一的数字 ID。<ul><li><code>‘猫’ -&gt; ID: 101</code></li><li><code>‘吃’ -&gt; ID: 102</code></li><li><code>‘鱼’ -&gt; ID: 103</code></li><li><code>‘The’ -&gt; ID: 201</code></li><li><code>‘cat’ -&gt; ID: 202</code></li><li>…等<br>现在，文字变成了数字：<code>[101, 102, 103]</code>。</li></ul></li></ol><h4 id="第一步：输入编码-位置编码"><a href="#第一步：输入编码-位置编码" class="headerlink" title="第一步：输入编码 + 位置编码"></a>第一步：输入编码 + 位置编码</h4><p>光有 ID 不够，模型还需要知道词的<strong>含义</strong>和它的<strong>位置</strong>。</p><ol><li><strong>词嵌入 (Embedding)：</strong> 一个数学查找表，将每个 ID (如 <code>101</code>) 转换成一个<strong>稠密向量</strong>（一串有意义的数字，比如 <code>[0.2, -0.5, 1.2, ...]</code>）。这个向量表示了“猫”的语义信息。<code>吃</code>和<code>鱼</code>也会被转换成它们自己的向量。<br>Token ID 只是一个无意义的无序编号，无法进行数学计算和表达词语关系；而词嵌入将其转换为一个富含语义的高维数值向量，使得模型能够通过数学计算来理解和学习词语之间的相似性与关联性。<ul><li><code>‘猫’ -&gt; [0.2, -0.5, 1.2, ...]</code></li><li><code>‘吃’ -&gt; [0.8, 0.1, -0.9, ...]</code></li><li><code>‘鱼’ -&gt; [-0.3, 1.5, 0.4, ...]</code></li></ul></li><li><strong>位置编码 (Positional Encoding)：</strong> Transformer 并行处理所有 token，它<strong>天生不知道顺序</strong>。我们必须人工告诉它每个词的位置。<ul><li>我们生成一组代表位置的向量（<code>pos_1</code>, <code>pos_2</code>, <code>pos_3</code>），每个向量都是独一无二的。</li><li><strong>将词向量和位置向量相加</strong>：<ul><li><code>‘猫’的最终向量 = [0.2, -0.5, 1.2, ...] + pos_1</code></li><li><code>‘吃’的最终向量 = [0.8, 0.1, -0.9, ...] + pos_2</code></li><li><code>‘鱼’的最终向量 = [-0.3, 1.5, 0.4, ...] + pos_3</code><br>现在，每个 token 的向量都<strong>既包含了语义信息，也包含了位置信息</strong>。它们被准备好送入编码器。</li></ul></li></ul></li></ol><h4 id="第二步：编码器-Encoder-理解句子"><a href="#第二步：编码器-Encoder-理解句子" class="headerlink" title="第二步：编码器 (Encoder) - 理解句子"></a>第二步：编码器 (Encoder) - 理解句子</h4><p>编码器是一个“理解者”，它将输入序列转化为一个富含全局上下文信息的表示，供解码器使用。<br>编码器由多层组成，每层核心是<strong>多头自注意力机制 (Multi-Head Self-Attention)</strong>。<br><strong>1. 自注意力机制 (Self-Attention) - 一个“头”的工作方式：</strong></p><ul><li><strong>目的：</strong> 让每个 token 都能与其他所有 token“交流”，根据上下文动态更新自己的表示。</li><li><strong>过程（对于“吃”这个 token）：</strong><ul><li><strong>制造三把钥匙：</strong> 为每个 token 生成三个新向量：<ul><li><strong>Query (查询向量 Q)：</strong> “吃”提出的问题：“我是动词，我需要找到谁在做我？谁是我的对象？”</li><li><strong>Key (键向量 K)：</strong> 每个 token 的身份牌。“猫”的钥匙是“名词，主语”，“鱼”的钥匙是“名词，宾语”。</li><li><strong>Value (值向量 V)：</strong> 每个 token 真正要提供的信息内容。</li></ul></li><li><strong>打分：</strong> “吃”用自己的 <strong>Q</strong> 去和所有 token（包括自己）的 <strong>K</strong> 做点乘，计算一个相关性分数。<ul><li><code>Score(吃, 猫) =</code> <strong>很高</strong> (动词找主语)</li><li><code>Score(吃, 鱼) =</code> <strong>很高</strong> (动词找宾语)</li><li><code>Score(吃, 吃) =</code> <strong>较低</strong> (自己和自己关系不大)</li></ul></li><li><strong>加权求和：</strong> 将这些分数转换成权重（softmax），然后用权重对所有的 <strong>V</strong> 向量求和。<ul><li><code>新的“吃”的向量 ≈ 0.4 * V猫 + 0.4 * V鱼 + 0.2 * V吃</code></li></ul></li><li><strong>结果：</strong> 新的“吃”的向量不再是孤立的“吃”，而是变成了 <strong>“被猫执行且对象是鱼的吃”</strong>。它融合了全局信息。<br><strong>2. 多头自注意力 (Multi-Head)：</strong></li></ul></li><li><strong>为什么需要多个头？</strong> 一个“头”可能只关注一种关系。多个头可以让模型同时关注<strong>多种不同</strong>的关系。</li><li><strong>比喻：</strong> 就像你读一句话，可以同时分析它的<strong>语法结构</strong>（主谓宾）、<strong>语义关系</strong>（谁对谁做了什么）、<strong>时态</strong>（过去/现在）等。</li><li><strong>实际操作：</strong> 模型会并行地运行多个（例如8个）独立的上述自注意力过程。每个“头”有不同的<strong>Q, K, V</strong>权重矩阵，因此会学习关注不同类型的模式。<ul><li><strong>头1</strong> 可能专门关注<strong>主谓关系</strong>（“吃”关注“猫”）。</li><li><strong>头2</strong> 可能专门关注<strong>动宾关系</strong>（“吃”关注“鱼”）。</li><li><strong>头3</strong> 可能发现“猫”和“鱼”都是<strong>动物</strong>。</li></ul></li><li>所有头的输出最终会被<strong>拼接</strong>起来，再通过一个线性层整合，形成编码器这一层的最终输出。<br>经过编码器多层这样的处理，输入序列<code>[“猫”, “吃”, “鱼”]</code> 被转化为了一个<strong>富含上下文信息的深度表示矩阵</strong>，我们称之为“上下文包”。这个包准备好了被解码器使用。</li></ul><p><strong>3.层归一化 (Layer Normalization)的作用：</strong></p><ul><li><strong>问题：</strong> 神经网络在训练过程中，每层的输入分布会发生变化（内部协变量偏移），这会导致训练不稳定、变慢。</li><li><strong>解决方案：</strong> 层归一化对<strong>单个样本的所有特征</strong>进行标准化（将其均值变为0，方差变为1），然后进行缩放和偏移。</li><li><strong>例子中的体现：</strong><ul><li>在经过自注意力计算后，“吃”的新向量 <code>[0.4 * V猫 + 0.4 * V鱼 + 0.2 * V吃]</code> 可能会变得非常大或非常小。</li><li><strong>层归一化</strong>会立刻对这个新向量进行“平滑”处理，将其稳定在一个合理的数值范围内。这就像是一个“稳压器”，确保数据流在进入下一层时处于稳定状态，极大加速了训练过程并提升了模型性能。</li></ul></li></ul><p><strong>4. 前馈神经网络 (Feed-Forward Network, FFN)的作用：</strong></p><ul><li><strong>结构：</strong> 它是一个简单的两层神经网络：<strong>线性层 -&gt; 激活函数 (如ReLU) -&gt; 线性层</strong>。它的输入和输出维度相同。</li><li><strong>目的：</strong> 为自注意力机制添加<strong>非线性变换</strong>和<strong>空间变换</strong>。自注意力机制主要负责“融合信息”，而FFN负责“处理信息”。它将注意力输出的向量映射到另一个空间，从中提取更复杂的特征。</li><li><strong>例子中的体现：</strong><ul><li>对于“吃”这个token，自注意力机制已经把它变成了“被猫执行且对象是鱼的吃”。</li><li>这个向量随后会送入FFN。FFN可能会进一步强化“这是一个动词”、“这是一个现在时动作”等特征，或者抑制一些无关的噪音信息。它为每个位置（token）独立地进行计算。</li></ul></li></ul><h4 id="第三步：解码器-Decoder-生成句子"><a href="#第三步：解码器-Decoder-生成句子" class="headerlink" title="第三步：解码器 (Decoder) - 生成句子"></a>第三步：解码器 (Decoder) - 生成句子</h4><p>解码器也是多层的，它比编码器多一个关键环节。它<strong>自回归地</strong>（用已生成的输出作为输入来预测下一个）工作。<br><strong>初始：</strong> 给解码器输入一个起始 token <code>&lt;start&gt;</code>（ID: 300），让它开始生成。</p><p><strong>第一轮：生成 “The”</strong></p><ol><li><strong>目标序列嵌入：</strong> 当前解码器的输入只有 <code>[&lt;start&gt;]</code>。我们先对它进行词嵌入和位置编码。</li><li><strong>掩码自注意力：</strong> 解码器先做自注意力，但有一个关键限制：<strong>掩码 (Mask)</strong>。为了防止“作弊”，它只能看到当前位置及之前的位置。所以<code>&lt;start&gt;</code>只能看到自己。</li><li><strong>编码器-解码器注意力：</strong> 这是最关键的一步！<ul><li>解码器将上一步的输出作为 <strong>Query (Q)</strong>。</li><li>它去<strong>编码器最终输出的那个“上下文包”</strong>（代表“猫吃鱼”）里，去拿它的 <strong>Key (K)</strong> 和 <strong>Value (V)</strong>。</li><li>这个过程相当于解码器在问：“基于你们理解的整个源句子的意思，在我已经有<code>&lt;start&gt;</code>的情况下，下一个最应该生成什么词？”</li><li>“上下文包”根据其内部信息（主语是“猫”，需要冠词）计算出答案。</li></ul></li><li><strong>输出层：</strong> 经过一个线性层和 softmax，模型计算整个英文词汇表中每个词的概率。<ul><li><code>P(“The”) = 0.85</code></li><li><code>P(“A”) = 0.10</code></li><li><code>P(“cat”) = 0.05</code> …等等</li><li>选择概率最高的“The”作为输出。<strong>现在序列是 <code>[&lt;start&gt;, The]</code></strong></li></ul></li></ol><p><strong>第二轮：生成 “cat”</strong></p><ol><li><strong>输入：</strong> 将 <code>[&lt;start&gt;, The]</code> 输入解码器（并加上位置编码）。</li><li><strong>掩码自注意力：</strong> <code>The</code> 可以关注 <code>&lt;start&gt;</code> 和它自己，但不能关注未来的词。</li><li><strong>编码器-解码器注意力：</strong> 解码器再次用当前状态（<code>[&lt;start&gt;, The]</code>）作为 Q，去问“上下文包”：“现在序列是‘The’，后面跟什么最合适？”<ul><li>“上下文包”回应：“我的主语是‘猫’，所以生成‘cat’。”</li></ul></li><li><strong>输出层：</strong> 计算概率，“cat”的概率最高。输出“cat”。<strong>序列变为 <code>[&lt;start&gt;, The, cat]</code></strong></li></ol><p><strong>后续轮次：</strong> 重复此过程，生成“eats”和“fish”。最后生成一个结束 token <code>&lt;end&gt;</code>，标志着生成完成。</p><h4 id="第四步：输出处理"><a href="#第四步：输出处理" class="headerlink" title="第四步：输出处理"></a>第四步：输出处理</h4><p><strong>线性层 (Linear Layer) 和 Softmax 的作用（在输出层）：</strong></p><ul><li><strong>位置：</strong> 在解码堆栈的最终输出之后。</li><li><strong>流程：</strong><ol><li><strong>线性层 (投影层)：</strong> 解码器最终输出的每个token的向量维度很大（如1024维），包含了丰富的语义信息。线性层的作用是将这个高维向量<strong>投影</strong>到一个新的向量，这个新向量的<strong>长度等于目标词汇表的大小</strong>（如30000维）。<ul><li><strong>例子：</strong> 在生成“The”之后，解码器输出一个代表当前状态的向量（1024维）。线性层将其转换为一个30000维的<strong>logits向量</strong>，这个向量的每个位置上的分数对应着词汇表中每个词的“原始得分”。</li></ul></li><li><strong>Softmax：</strong> 这个30000维的“得分”向量可能数值差异巨大、难以解释。Softmax函数将所有得分转换为<strong>概率分布</strong>：每个值变为0到1之间的正数，且所有值之和为1。<ul><li><strong>例子：</strong> Softmax之后，<code>“The”</code>对应的得分可能变成概率<code>0.85</code>，<code>“A”</code>变成<code>0.10</code>，<code>“cat”</code>变成<code>0.05</code>，其他所有词的概率趋近于0。这得到了一个清晰的、可解释的下一步输出概率。</li></ul></li></ol></li></ul><h3 id="2-Transformer变种"><a href="#2-Transformer变种" class="headerlink" title="2.Transformer变种"></a>2.Transformer变种</h3><p><img src="/2025/09/04/others/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%A4%A7%E6%A8%A1%E5%9E%8B/file-20250904190737329.png" alt></p><h4 id="（1）仅编码器-Encoder-Only-模型"><a href="#（1）仅编码器-Encoder-Only-模型" class="headerlink" title="（1）仅编码器 (Encoder-Only) 模型"></a>（1）仅编码器 (Encoder-Only) 模型</h4><p>这类模型只使用 Transformer 的编码器部分。它们擅长<strong>深度理解语言</strong>，常用于需要“全面分析”的任务。</p><ul><li><strong>代表模型：</strong> <strong>BERT</strong> 及其系列（如 RoBERTa, ALBERT）</li><li><strong>核心思想：</strong> <strong>自编码 (Autoencoding)</strong>。在预训练时，随机掩盖输入中的一些词（例如，把“猫吃鱼”变成“猫<code>[MASK]</code>鱼”），然后让模型根据上下文来预测被掩盖的词。这个过程迫使模型双向地、深度地理解每个词的上下文含义。</li><li><strong>主要用途：</strong><ul><li>文本分类（如情感分析）</li><li>命名实体识别（找出人名、地名）</li><li>问答（从文中提取答案）</li></ul></li><li><strong>特点：</strong> 模型输出是对每个输入词的精炼理解，非常适合做文本的分析和标注，但不擅长直接生成新文本。</li></ul><h4 id="（2）仅解码器-Decoder-Only-模型"><a href="#（2）仅解码器-Decoder-Only-模型" class="headerlink" title="（2）仅解码器 (Decoder-Only) 模型"></a>（2）仅解码器 (Decoder-Only) 模型</h4><p>这类模型只使用 Transformer 的解码器部分（并去掉了编码器-解码器注意力层）。它们是目前<strong>最常见、规模最大的生成式模型</strong>。</p><ul><li><strong>代表模型：</strong> <strong>GPT</strong> 系列（GPT-2, GPT-3, GPT-4）</li><li><strong>核心思想：</strong> <strong>自回归 (Autoregressive)</strong>。模型从左到右逐个生成 token。在生成下一个词时，只能关注到它之前已经生成的词（通过掩码实现）。这模拟了人类自然说话或写作的方式。</li><li><strong>主要用途：</strong><ul><li>文本生成（写文章、写故事）</li><li>对话系统（ChatGPT）</li><li>代码生成</li><li>任何可以通过“提示(Prompt)”来引导的任务</li></ul></li><li><strong>特点：</strong> 拥有强大的<strong>涌现能力</strong>，即在没有专门训练的情况下，也能完成许多新任务。它们是真正的“通用生成器”。</li></ul><h4 id="（3）编码器-解码器-Encoder-Decoder-模型"><a href="#（3）编码器-解码器-Encoder-Decoder-模型" class="headerlink" title="（3）编码器-解码器 (Encoder-Decoder) 模型"></a>（3）编码器-解码器 (Encoder-Decoder) 模型</h4><p>这类模型完整保留了原始 Transformer 的结构，是专门的“条件生成”模型。</p><ul><li><strong>代表模型：</strong> <strong>T5</strong>, <strong>BART</strong></li><li><strong>核心思想：</strong> 专门处理<strong>序列到序列 (Seq2Seq)</strong> 的任务。编码器全面理解输入序列，解码器根据编码器的信息生成输出序列。</li><li><strong>主要用途：</strong><ul><li>机器翻译</li><li>文本摘要（长文-&gt;短文）</li><li>文本复述（改写句子）</li><li>问答（需要生成答案，而非提取）</li></ul></li><li><strong>特点：</strong> 在需要“理解A并生成B”的特定任务上表现非常出色。</li></ul><h2 id="四-大语言模型"><a href="#四-大语言模型" class="headerlink" title="四.大语言模型"></a>四.大语言模型</h2><h3 id="1-自然语言处理（NLP）"><a href="#1-自然语言处理（NLP）" class="headerlink" title="1. 自然语言处理（NLP）"></a>1. 自然语言处理（NLP）</h3><p>自然语言处理（NLP）是一个广阔的学科领域，它的目标是让计算机理解、解释和生成人类的自然语言。<br><strong>传统任务举例：</strong></p><ul><li><strong>理解类:</strong> 情感分析、命名实体识别（找出人名、地名）、语法分析。    </li><li><strong>生成类:</strong> 机器翻译、文本摘要、问答系统。</li></ul><h3 id="2-语言模型"><a href="#2-语言模型" class="headerlink" title="2. 语言模型"></a>2. 语言模型</h3><p>语言模型（Language Model）是 NLP 领域的一个核心概念。简单来说，它的任务是<strong>预测一个词序列出现的概率</strong>。<br><strong>一个简单的例子：</strong></p><ul><li>面对句子开头：“猫吃__”</li><li>一个训练好的语言模型会计算：<ul><li><code>P(鱼 | 猫吃) = 0.92</code> (概率很高)</li><li><code>P(书 | 猫吃) = 0.005</code> (概率极低)</li><li><code>P(飞机 | 猫吃) = 0.0001</code> (概率几乎为零)</li></ul></li><li>模型会根据概率选择“鱼”作为最可能的下一个词。<h3 id="3-大语言模型（LLM）"><a href="#3-大语言模型（LLM）" class="headerlink" title="3. 大语言模型（LLM）"></a>3. 大语言模型（LLM）</h3>大语言模型是语言模型在<strong>规模上实现飞跃</strong>后的产物。它通过以下方式突破了传统语言模型的局限：</li><li><strong>海量数据：</strong> LLM 在互联网上几乎所有的公开文本数据上进行训练，包括书籍、维基百科、新闻和论坛等。这使得它拥有了空前庞大的知识库。</li><li><strong>巨量参数：</strong> 它们的参数量达到了数百亿甚至万亿级别。庞大的参数量让模型能够存储和编码海量的语言模式和世界知识，从而理解更深层次的语义和语境。</li><li><strong>先进架构：</strong> LLM 主要采用 <strong>Transformer</strong> 架构。这种架构的核心是<strong>自注意力机制</strong>，它能让模型在处理一个词时，同时考虑句子中的所有其他词，从而理解长距离的依赖关系。</li></ul><p>大语言模型是基于Transformer架构，在海量文本数据上训练而成的、拥有巨量参数的、具有<strong>涌现能力</strong>的深度学习模型。<br><strong>关键特性：</strong></p><ol><li><strong>涌现能力:</strong><ul><li>这是LLM最神奇的特性。当模型规模（数据、参数、算力）超过某个临界点时，模型会<strong>突然获得</strong>在较小模型上不存在的新能力。</li><li><strong>例如：</strong> 代码生成、复杂推理、跨语言迁移、遵循复杂指令等能力，并非被 explicitly 编程，而是自然“涌现”出来的。</li></ul></li><li><strong>通用任务解决器:</strong><ul><li>传统的NLP模型是“一个模型一个任务”（如情感分析模型只能做情感分析）。</li><li>LLM是“一个模型应对万任务”。通过<strong>提示（Prompting）</strong>，即用自然语言描述任务，LLM就能直接完成。<ul><li><strong>提示举例：</strong> “请将以下英文翻译成中文：<code>Hello, world!</code>”</li><li><strong>提示举例：</strong> “请总结这篇文章的核心观点：<code>[文章内容]</code>”</li></ul></li></ul></li><li><strong>核心能力：</strong><ul><li><strong>生成：</strong> 流畅、创造性地生成文本。</li><li><strong>理解：</strong> 深度理解上下文和语义。</li><li><strong>推理：</strong> 进行一定程度的逻辑和常识推理。</li></ul></li></ol><h3 id="4-大语言模型幻觉"><a href="#4-大语言模型幻觉" class="headerlink" title="4.大语言模型幻觉"></a>4.大语言模型幻觉</h3><p>目前所有类别的大模型（语言、音频、视觉、多模态）都存在幻觉问题，这里以大语言模型幻觉为例。</p><p>大语言模型的“幻觉”指的是模型生成的内容与提供的信息源或现实世界事实不符。</p><p><strong>例：</strong></p><ul><li>在摘要生成任务中，大模型生成的摘要可能无法对应源文本中的事实正确信息; </li><li>在对话生成任务中， 对话产生的输出与对话历史或外部事实相矛盾; </li><li>在机器翻译任务中, 则是指大模型产生完全脱离原始材料的错误翻译</li></ul><p><strong>大模型幻觉的成因：</strong><br><strong>1.数据层成因</strong><br>训练数据的质量是模型产生幻觉的根源。</p><ol><li>数据收集问题：为追求效率，常使用启发式方法自动收集网络数据，未全部经人工校验。这导致虚假、有害信息被模型吸收。</li><li>数据重复或缺失：<ul><li>重复：导致模型偏向生成记忆中的重复短语，缺乏创造性且可能复制错误。</li><li>缺失：模型对缺失的知识只能进行偏离事实的预测，从而产生幻觉。</li></ul></li><li>数据标注问题：标注过程从纯人工转向机器辅助，引入了刻板印象、编写错误、文化差异和不一致性，这些偏差被模型学习。</li></ol><p><strong>2.模型层成因</strong><br>模型自身的结构设计和训练机制存在固有缺陷。</p><ol><li>编码与解码缺陷：<ul><li>编码器可能无法精确解析输入内容，导致错误的内部表征。</li><li>解码器可能关注了输入中的错误部分，从而混淆事实、生成错误输出。</li></ul></li><li>预训练知识偏好：模型在生成时更倾向于依赖预训练阶段记忆在参数中的静态知识，而非当前提供的输入信息，导致答案过时或与上下文不符。</li><li>知识更新局限：模型存在“灾难性遗忘”问题。用新数据更新模型时，它会遗忘旧知识，导致知识混乱和不完整，从而产生幻觉。</li></ol><p><strong>3.应用层成因</strong><br>在实际部署和应用中产生的新问题。</p><ol><li><strong>下游任务领域专业化</strong>：为特定领域（如医学、法律）优化模型时，可能使其失去通用性，在与训练数据分布不同的实际应用中产生偏差和幻觉。</li><li><strong>模型同质化</strong>：几乎所有主流模型都基于<strong>Transformer架构</strong>。这使得该架构的任何固有缺陷（包括幻觉倾向）都会被所有模型继承和放大。</li><li><strong>多模态化</strong>：处理文本、图像、音频等多种数据类型极大增加了复杂性。不同模态间的差异和对齐困难更容易导致严重的幻觉。</li><li><strong>提示工程问题</strong>：<ul><li><strong>指令微调</strong>：用于训练的数据指令可能本身包含不存在的对象或关系（合成数据），或指令模板过于单一，引导模型生成幻觉内容。</li><li><strong>思维链技术</strong>：模型生成的推理链可能本身逻辑错误，但最终得出了正确答案，难以评估其推理过程的有效性，隐藏了幻觉风险。</li></ul></li></ol><h3 id="5-提示词工程"><a href="#5-提示词工程" class="headerlink" title="5.提示词工程"></a>5.提示词工程</h3><h4 id="（1）提示词工程的重要性"><a href="#（1）提示词工程的重要性" class="headerlink" title="（1）提示词工程的重要性"></a>（1）提示词工程的重要性</h4><p>提示词工程是设计和优化输入查询（即“提示词”）的过程，其重要性在于能够引导大型语言模型（LLMs）生成准确、有用且相关的输出 。<br>它为用户提供了一种“编程”形式，可以自定义LLM的输出和交互 。通过利用高质量的提示，信息寻求者和开发人员可以提高LLM的性能，探索新应用，并节省时间和资源 。此外，提示工程还支持开发更复杂的LLM应用程序，并有助于开发者更好地理解模型的能力和行为 。</p><h4 id="（2）提示词基本概念"><a href="#（2）提示词基本概念" class="headerlink" title="（2）提示词基本概念"></a>（2）提示词基本概念</h4><p>提示词由三项基本元素组成：<strong>输入指令</strong>、<strong>上下文</strong>和<strong>输出指示</strong>。这些元素需要根据所选模型和具体任务不断调整和修正，以确保模型能生成高质量的回答。</p><ul><li><strong>输入指令</strong>是用户向大型语言模型（LLM）提出的具体请求或问题。它可以是直接的，例如“明天的天气如何？”；也可以是间接的，例如“我准备去北京旅游，有什么建议吗？”。输入指令的设计对于 LLM 理解用户意图和生成相关回答至关重要。</li><li><strong>上下文</strong>指与输入指令相关的信息，有助于 LLM 更准确地理解指令含义和用户需求。上下文可包括用户与 LLM 的历史对话记录、相关话题的背景信息、时间地点等环境因素，甚至用户的情感状态。在处理输入指令时，充分考虑上下文能够帮助 AI 生成更加准确和个性化的回答。</li><li><strong>输出指示</strong>是 LLM 根据输入指令和上下文信息所生成的响应内容。该响应需满足用户的查询需求，并遵循系统的输出规范与限制。输出指示的表现形式可以是一段文本、一个明确答案、一组可选方案或任何其它形式的反馈，其根本目的在于以最适宜的方式回应用户的指令。</li></ul><h4 id="（4）初级提示词工程技术"><a href="#（4）初级提示词工程技术" class="headerlink" title="（4）初级提示词工程技术"></a>（4）初级提示词工程技术</h4><ul><li><strong>明确性</strong>：是提升 LLM 效果的关键。一个清晰的提示可以减少模型的歧义理解，确保模型准确把握用户的意图。为此，指令应该直接、简洁，并且避免使用含糊或多义的词汇。</li><li><strong>使用关键词</strong>：突出关键词可以帮助模型集中注意力。在提示中使用加粗、斜体或列表等形式强调关键词，可以提高模型识别和响应这些关键信息的能力。</li><li><strong>示例学习</strong>：提供正确或错误的例子可以指导模型理解期望的输出格式。例如，如果用户想要模型生成一段代码，提供一段正确和错误代码的示例可以帮助模型理解用户意图。根据提供示例的多少，该技术又分为 zero-shot learning (ZSL) 和 few-shot learning (FSL)。</li><li><strong>使用正确的语言风格</strong>：根据目标输出调整语言的正式程度和风格。例如，如果需要模型生成学术论文，使用正式和学术的语言风格会更合适。</li><li><strong>反馈循环</strong>：利用用户提供的反馈来不断优化提示词。如果用户对模型的输出不满意，可以根据用户的反馈调整提示，以进一步提高性能。</li><li><strong>角色扮演</strong>：指定一个角色或身份给模型，使其以特定视角回答问题。例如，如果用户想知道医生对某个医疗问题的看法，可以让模型扮演医生的角色。</li></ul><h4 id="（5）高级提示词工程技术"><a href="#（5）高级提示词工程技术" class="headerlink" title="（5）高级提示词工程技术"></a>（5）高级提示词工程技术</h4><p><strong>思维链（ CoT）</strong>：<br>让 AI 像人一样一步步思考，把大问题拆成小问题，逐步解决。这样做不仅更准，还能让我们看懂它是怎么想的。有两种常用方式：</p><ul><li><strong>零样本 CoT</strong>：不用举例，直接加一句“请一步步思考”，AI 就会开始推理。</li><li><strong>少样本 CoT</strong>：给出几个例子，AI 就能学着你的样子进行推理。</li></ul><p><strong>自洽性（Self-Consistency, SC）</strong>：<br>让 AI 对同一个问题生成多条推理路径，就像几个人一起讨论，最后“投票”选出最佳答案。这种方式特别适合复杂或答案不唯一的问题。</p><p><strong>思维树（Tree of Thought, ToT）</strong>：<br>让 AI 在推理时像走迷宫一样尝试多种路径，每走一步都自我评估，选择最有希望的方向。适合需要深度规划或搜索的任务。</p><p><strong>思维图（Graph of Thought, GoT）</strong>：<br>把 AI 的推理过程变成一张“思维网”，不同想法可以连接、合并、甚至循环优化。这让 AI 的思考更灵活、更全面。</p><p><strong>自动思维链（Auto-CoT）</strong>：<br>自动为问题生成推理示例，省去人工编写的麻烦，高效又方便。</p><p><strong>生成知识提示（GKP）</strong>：<br>先让 AI 自己生成一些相关知识，再利用这些知识回答问题。特别适合回答常识类问题，不用查外部资料。</p><p><strong>自动提示工程（APE）</strong>：<br>自动尝试多种提问方式，帮我们找出效果最好的那句“指令”，省时又省力。</p><p><strong>自动多步推理与工具使用（ART）</strong>：<br>让 AI 把复杂任务拆成多个步骤，必要时还能调用其他工具（比如计算器或搜索引擎），弥补自身不足。</p><p><strong>检索增强生成（RAG）</strong>：<br>先从外部知识库中查找相关资料，再结合这些资料生成回答，保证答案既准确又及时。</p><p><strong>推理与行动（ReAct）</strong>：<br>让 AI 一边推理、一边行动（比如上网查资料），根据结果动态调整计划，更灵活地完成复杂任务。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><code>[1]董雅雯,李恒,刘佳,等.大模型技术的发展与应用：现状、机遇与挑战[J].人工智能,2025,(01):110-118.DOI:10.16453/j.2096-5036.202503.</code><br><code>[2]刘泽垣,王鹏江,宋晓斌,等.大语言模型的幻觉问题研究综述[J].软件学报,2025,36(03):1152-1185.DOI:10.13328/j.cnki.jos.007242.</code><br><code>[3]王耀祖,李擎,戴张杰,等.大语言模型研究现状与趋势[J].工程科学学报,2024,46(08):1411-1425.DOI:10.13374/j.issn2095-9389.2023.10.09.003.</code><br><code>[4]王东清,芦飞,张炳会,等.大语言模型中提示词工程综述[J].计算机系统应用,2025,34(01):1-10.DOI:10.15888/j.cnki.csa.009782.</code><br><code>[5]罗锦钊,孙玉龙,钱增志,等.人工智能大模型综述及展望[J].无线电工程,2023,53(11):2461-2472.</code><br><code>[6]蔡睿,葛军,孙哲,等.AI预训练大模型发展综述[J].小型微型计算机系统,2024,45(10):2327-2337.DOI:10.20009/j.cnki.21-1106/TP.2023-0571.</code><br><code>[7]Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[J]. Advances in neural information processing systems, 2017, 30.</code><br><code>[8]林粒粒呀. ChatGPT原理揭密！背后的黑科技Transformer模型[视频]. (2023-10-26). 取自 https://www.bilibili.com/video/BV1ZG411y7aZ</code></p>]]></content>
      
      
      <categories>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode42接雨水</title>
      <link href="/2025/07/15/code/leetcode/LeetCode42%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2025/07/15/code/leetcode/LeetCode42%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZwAAAChCAYAAADz0gn+AAAD8GlDQ1BJQ0MgUHJvZmlsZQAAKJGNVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXjEKMJAAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAaXklEQVR4nO3daYyd133f8e//nOfemSFHC0mZEmUlilYvYgI5RaKq9aIqlt06RQy3RWIDdd3ECfomrRGgMVIErl8YLuxCjZD2RYsWMRIvshxXNuraiW3Esl1Rlm1ErhdYkhepolaaFMmhyBnO8pzz74vnee7c4SyipLnnDjm/DzGcu8zMOfc85zn/sz33mrs7IiIiIxbGnQEREdkeFHBERKQIBRwRESlCAUdERIpQwBERkSI2NeBkz5v550RE5Dxim70tuvtzZraZf1ZERM5xmzbCqeuaw4cP4+4KNiIisspLDjjeTqMdPHiQD33oQxw7dmzF4yIiIvASA04zmmn+xFe+8hXuuOMOvvnNb7bPLU+viYiIvKSAk3MzinniiSf4+Mc/DsBdd93FzMwMIQRSSi89hyIicl540QHH3YkxAvCFv/oC9957LwCf+MQn+PrXvw40Gwc0yhEREXgJAacb3Tz++ON89C8+CsC1114LwKc+9SmOHz9OjFGjHBERAV5kwBke3Xz5y1/m/vvvZ3p6mueeew6AT37yk3zjG98ANMoREZHGi7oOJ+dMCIEf/ehHvPKVrwTgggsuIKVEXdcsLi5yyy23cOedd7Jv3z5SSoMAJSIi21P1Yn6pu87m2LFjfOADHyDGyN13380DDzzAbbfdxhvf+EZSShw/fpx9+/YRgt5BR0Rku3vRAcfduemmX+Xmm2+mrmsefPBBHnjgAW666Sbe+973As1ISBeCiogIvMiAA03QMWumyeq6HqzTdJsJAI1sRERkYFOuwxleBlrvtoiIbG8vKeCsNVWm6TMREVmL5rxERKQIBRwRESlCAUdERIpQwBERkSIUcEREpAgFHBERKUIBR0REilDAERGRIhRwRESkCAUcEREpQgFHRESKUMAREZEiFHBERKQIBRwRESlCAUdERIpQwBERkSIUcEREpAgFHBERKUIBR0REilDAERGRIhRwRESkCAUcEREponLAABwwx5sbzWM4uOGAG4T2PnS/JCIicnaqJtJAE0GGo0gXWLrgk8ETEHCLLP+eiIjI86ugBgwssiLoOGRP5AyYEYPjFoCIkQHHNSMnIiJnqYJutDKYXMNwnEwIFWEopiRPBAMfTLmJiIicncoIK2fVAM9LWMicOHqYB3/8/+hPX8yrXvVKdlQZciaFHmDNmo6IiMhZqJqYsRxxPDsh9Dg58xQf/cSnOHnqFE8+/gjXvuaN/P6/eif94JAzIaw9nebuK26baSwkMi7uPjgPvXAH0QB3MDO1AwJA1Yxq0tBdAzK93iT/5Lfeycsv3cs3/+bP+U9/fh//8rf/Obv7AaPGvJlaO9NwIFovKIlIGcON/TgmwhVnZFhFuwEAwD0DgZSNyZ0Xw6GH+J9f+yL3Hrif3/qd32FXP1B7Im7wB3POK26rdyMyHu7O7OwsCwsLYzsH3Z2JiQmmp6fHkr5sLVWzASC2McfwZugCRNxrQuyx55I9/OTB73Hk797I3h0TpJyxELCh6bMu0Dz11FPcd999g2Bzww03sGvXLk2viRSSUiLGyKlTp/jgBz/IXXfdxfXXX8/8/HyRc7A712OMPPnkk7zjHe/gff/+fVSxUjuwzVXNhZwG1u5S80wMNfXSAldc+xquuPY1/Pptf4+//9o38Ms338yb/84vkj0Tz9gS3U2fXXLJJezfvx8zI6U06NmokomU0a2jLiws8J3vfIeDBw9y8ODBseXnwQcfJKVEFaux5UG2hgpYsZiYUyJUgWeefIy/+sq3uOaqq/jJD77NL73+bVz38y8HIFrznjhrLUFOTU1x0UUXrXhMvRqR8kIIXHzxxQBcd911HD58mKoq0+ibGVNTUzzxxBNceOEFupBCgPbCz+WrbwIhVIBzyd7L+YXL9/DDH3yfyel9/Ls//l2uftluPC9ioVp3v8uZazghBAUbkYIGmwTMBufj4uIiJ06cIMZISmmjX98UMS6v9KaUN/hJ2U6a7o4102oGWDA8Z6Z27uLNb3kbb37L8g+7OxZ6y/fX+IPDwUWBRkREOhVWNZvloVnCAQiRnBNOIrTbpLNbu06z/I4EIiJr0e5UWUu78t9uHPDlmdYQAiE4zTU6gRBi+0bRencBERF54SqDVQMWG3yPEIamyDDY8CocERGRtW2wZUXDYRER2Tx67xkRESlCAUdERIpQwBERkSIUcEREpAgFHBERKUIBR0REilDAERGRIhRwRESkCAUcEREpQgFHRESKUMAREZEiFHBERKQIBRwRESlCAUdERIpQwBERkSIUcEREpAgFHBERKWKDT/wEd8fdAbAQ9BmgIiLyoq0bcNzBzDCzwQNuYAo7InJOclD7NVYBEuB494g7njNdnKmXlsgJmgdyO+LJ48iriLwg3n4N2y4NbsZJQyWQgdT0pM8skk3TpLai1J0mzdElek6pIIA3ldCtKawQoF44zr0HDvCtb32PJe9z21vfyk37X4F5xlkCYvslW1U3HTpWtl0auC3Am+IeHHaHVQGm4OEYrn/d7XJ1snuhjmPtfRs0+zaKwY5DE9hsKLzY4CnzwQ+NhW2BczF4O1ppiii19wJzJ2c4OjPLrbfdwtWXZT784T/hiZk5CIGU47oNibuTczMSSjltjUZvG3L3wZToaL/AzNvvazwP+ir11Z6SZoNmleVWdbkBHofhxq5MvTSMZt05kMEgWwDz5frKZn8ZRsRwgtWY5eZ1d+eBlTonV39hW6MDWjkZI9JEZidgeIILd13GP/unbwfg2sv7fPqLf8qpxUVgB8FjOypa/QJ6vR4hNJvfqtgsEXWNn4zecKApY7hRk60gxGbmIU9UELoo1D5ZsM3p6mCMkX6/3+QtFNwYa91/1gae7tYo04MzZ39s5ZNjYSwHnXG2xZXTazcDBMwd80U8RJZ8gh4Ac9z5yc/w+jf/Oq/Ye3G7myCDhxVl2EXPI0eO8NOf/nTw2OWXX87OnTvbga0aplHKORNCYG5ujnvuuYdDhw4xOTlJzqNec+vmqLvGxMATcepC4kVX4AQ0h12IGbmumZic5Pixn/HkMz8DYHZuvnm6UDbcnfn5Js0f//jHfOQjH2FiYoK6ros1eM1UmhM8U120D9uxu5l2ZHSr0Nma8yB2S0Vm+Pwx6pmnYBD2yp0LZkbOmeyZW95wC1ddddVYg04VBjs3lgvDHWIIQOLL//tuDs2/jD98528SgTo5Ftthu6/OdF3XzM/PD7ZUDxo7bRAZuS7gHD16lPe85z08+uijY87RDdz4L/6AZJO41+pwlGBgNVSxj88/zZOPHwXg5OxC09Dm9odG3OillDh58iQ7d+7kwIEDHDhwYKTpPZ+Lbn431776dZyuAQIBxza1CAyoySHjVITc9M2n+sZjD97Ds/f/xWYm9qJ89rOf5aqrrhprHiojgUfAcDOyV0Qc0jE+d/edfP7/PMof/tF7merB7MISExM9LGcMW1Flu4i5d+9e9u/fvyKRcQ/jtqPLLruMRx99lGuuuYbDhw/T6/VGNoc73HyZGRb7nDpyiKt+5Uou3z1NCpPgNepxFJKd0Juinj3Fs/1mniLGtmtpbeeywHy+mTE7O0u/32fnzp2YWdF1hBACjjF/9Fledfkl7Nqzm7rOGI5t+s4xw9pxU7YK8wQOvV5gct8uvgNM7NpFCBU5d+fC6MqiaZ+dqqqIMXLo0CFiHP8mr6qb2exkz8QYePqxx/lv/+MvuWjf9Xz6Y3/Gs8ef452//bu85lXXkdzB1h4arlWhFGzKCiEMKldd15w8eZIdO3aUOdnNCNFZAJJnEpnsCTyhgFOGk5qSzvNkr9sH22Nv3jRFBapCV99SSoPptZIsVGQ35gHPDilDWgScPKo2ySNujpFwjOiBnI05IJ8+Taz65HpxeYfHCLk7ExMTg/tboR1uVvUH+TCqAFCz59Kr+dhdd5MzzC8s4GZcvGv3ci/pLAJ0N8UjZQxXqG4qs/s+NzdXLB9xsmrTdsiGB4NsRU6y7c4A94h7xHKzNjts+N1DSkkpcfr06aJpAhB67exNe/mNN+s6TmjbrhGVgzvNv9Dcbst7fn6eqm/Ui+WCbwhh0AZviV1qw3eaDAU8OxOTU0xMXbjqF1LOhLPcYrcVIqo0Yowj3zzg7sQYidZcTjy8P0dLeKO36ozcQgVeui1wd6oYqN2gXidPo0i3/b+p874qndCWg60zQ7RZus0CW60NPuOtbaxdb4k4GXIN1syD0q7DhBAgp6Eth3KuKNHD2ehC7vH3r2RctkLv+kybnSNbcWvttnFwTe42ffeBFQGnu3ivETFrrppt9nAPFeBgiFYolyIics6rhj+hYHVMXm/9ZbxXLYuIyLnnjCm17fpGfyIiMmpDAefMOUUFGxER2TxDAUfviSUiIqOji2RERKQIBRwRESlCAUdERIpQwBERkSIUcEREpAgFHBERKUIBR0REilDAERGRIhRwRESkCAUcEREpQgFHRESKUMAREZEizjLg6HNvRETkpdkw4GQAT0ACb+4nwEnt4yIiImen2uhJcydjOIHgjuFkM9ybD54WERE5W6Edx6zJHJJDSj74tJyAYxbQ8o+IiLwQVbM+k1kdQJyM0wuhu0s2A5qRDmZa2hERWZdmgc7UTqmtLBj3jBmEEPjZM09weGaOV11/PVU0cjOfplizBfmWOyrO8EeXj+P0G2eJqLnZmprjMsqa4ZxZ97cax8eyLFI1I5vlhN0ds6aQvnXgq/z3//pf8D3X8J//439gOvaAGujRjHVWc/cz/lb5F+We8TEf5/Kv25qBalx5DMbNYXAsxpItY926OuJkmzTH8Jrd27IeVwa2sNHWwbbLZ9297lhsjWPQ5SN7xtzAvPg5Wa3uhzU5qOtFehMVv/GW13HPD2aok7fPxg0rcghhzdslmQXGEOfGruo1A9Z+vzcIeOMI+F2KZoEqVqRQNcGwWF66dJycc/ETvgs2ZkaI5c+B4E5VVXiM7XrrdrO6ixFCIMaqaWxtuX5sNm878M2ad6CqAiHGFTkrrXu9/X4fgBiG8lM4Q0O71DJgmAXcEyFM8Mu/8joumjjNV79/ALeum2rNcGydnKaUSClhZqSUqKqqSKPXDRFzzhw/fpyFxQXCyE+2MyusNQ0NkEMkxV57v3t0tOq6ZscF0xw8fJSFpaXmsVR6+7rj3mxEyYsnqU88hlsP9zTy2m0ObtCM2p1g4FOX4tUOLNcjTRu6I5xxIm6RsHQCnz+Cu+ElzuxuaTVnvIqk2SOkpfn2ubrN4/hH/6PXtVV5cDPPHiLPPELuzgcb+rlN0raMdAHP3UmVkeaOLOfMu01aZQ6Ce9PpAjh8+DAzMzOcPn26eEfU3en3+13AWZ5rdG/2onWNw/zcSZbq1BaU49nJFoi2shfRvainn36a+++/v+lJYNyw/wZ279o98um1nDIxRg4deoZ/85738KUvfolXv/rVBQp3uOIYWKCen2Hvda/jsv1vInlsrlkqcIBzzvR7kfljB3niyUMAnHhutn2uTAXP2WFxDoCnf/p/Of70Tyg9qWUhkupFosGr3/Jvmb70ldSZEeaja+nbhgaoQmDmqYf44Rc/TG/npWChaQALMRz3xOxccywW5k4RqGhO0+ZquvNbJCUwW8AJPPyNz9L7278mE9hoZ+5L07Wj3S7eTCCxtLTUlD2JuusAjFg3qp+fX07v/e9/P3fcccegrS7FzFhcXOTKK68c3jQQ2ifbKOwZrMfO6YuYmpxg586p7tcJYXV17abP9u7dy4033jgY4ezYsWOQ6Ch1BTw7O8fXvvo1Tp06xbe//e2RprmRJ+16bvy5Hsl6kMsEHM/QqyL5ZKSu2/72oG6VamCcnJ0YK+ZPzzJ/erZQuuvkZvEUgRpGPsq0ZoztATOnYoF0+llOzQPzPxthus+vqiKpdty6E7fpPJ7f2usFgxEr47mTJ4ATY8tNr6rwVH4dswsuk5OTPPbYY2UTP8NDDz00PKXW7t1wb9pGX+C7D3yLv/nSPdz39W/ymbt/kVtueT379uwh54yFtbeqTUxMMD09veKxkpsHqqriyiuv5OjRo1x99dU8e/RZqrjh9a2bxsyw0OPUkUP83J5ppqcCidDWssHM/ohSd7IbVT9SLwQs5DZP3fORpqEp0bsxUqqJVY9Y9Qukt1KMPRYWF8lLcxAieVDmzah7s895Y3lmwK0td0/Edhp6YudF4E5OaeT9jq6GNZOKTr20SK7rNhjWmDWLxue/RBN0nOSJXn8KC107MLrdY2fu/jIzck4s1UtY2YH+CvPz81xwwQX0+/2xbWIIIaz/TgNmztGjz7Jn3yv4g3/9S8zOneL0/MLy86xddsPDtZwzIYQywWYoiaV2/WJhYYHnTjw3+rSHVJMXUgNLdU3KiWShyAjHaC7SjdnwtDQ0fdNOlVoo2L1q0kn1Erkuu4bkZKqJSfJg6qJpgs1DU2dtNGVgnpsyxsgWyOaDQJfqGnJNvbSAFbhg2tqUPUSyG1gEEmFoe/r5Pr4ZhN1sEBJL9SKw1Cz0kSDZSLYFO0Zo359l0M2xZonCC01rr+fkyZNjTR9WbBpoT8xBw9jn1970VoZb8gyk3I5WPLNWb304uJRcmFrZq1iZfoyRNILF8+XlwXbmNsYVccUImDd9zXY1e4QcyxHyBHifZkTT5ZLhfbLldAVUKOVuHfjMmOJtAAgjy4W310H78CMMLqYeLocRxpvhutikl8BjW/eqQf6cbfA+iObtyBNCbtZTrD1OmJHC8lhkM2pFs2EgAoGcA2YZa9+DEm92Dm6HceXzGdo00AQQ94BZxC00J4075ksY3WOO5YzHuB26SRuyoa+04tHmuw/6OcOhaRS5aE8dAyzhttz0dd8jmVS6yjvLrf+o60oXbTy2W1O7ZNt6PFTHR5F4l2Y3urDh0aT78usf5SizfZlm1lxn0ebH21xla6692B4tnwM1WMAH5ZGa0Z4bm76OZc00anBva1rGCSvGs9tjZLmxoU0DzddgdNAuujXXEzQ7bIyImbfTAlu5+MqMrNZ+9ctNvQ3WTPJIhu9dOsv5qMEyZml1N38srYzhudB1IIM2ffVILriTvQnKoxhorhjN0BS9WbcdHkoNcXxFL6M7kTNmebCRbvD0+a6rD9Z2pEN3nqQmCKXmmGxWWbh353vb9fQw+PvLaWzlNrOMoSm11SdCMGgKqbk+NHQ/t50q7gY2nqSylT9YanbRI3hcFeBys/2wUCYGmYGi0zcrJpXaLLTblY12xLn5ZbC8GZrmloHb8Cz+cJ5GXx7DrzAPRdhtsVfgTN7uYF1xOoymIBwjrZhbyNu+jTxTme1b29bQyV46XR+6PXzzvD4DhkcUQ0p1kMYR09fha9za1ooUg69zWzrb8X0vtgFV9rFQsYtsSAHnvFRud6CIyNlSwBERkSIUcEREpAgFHBERKUIBR0REilDAERGRIhRwRESkCAUcEREpQgFHRESKUMAREZEiFHBERKQIBRwRESlCAUdERIpQwBERkSIUcEREpAgFHJHNok+FENnQ83zip5Oz4+6EEDDTGXVu0CeBjYWKXWRD6wac5qNyjRCGPibZXUFHzlHOqIYgKz7NW0FHZF2VA+aOk0kWiTkB4CESgHppkbp2JqcmMDNydswctmjg2VoB0YAAlrEC8y2GYxjZIm6+nIX2m2+TxtCGWn0zx8jN67eM+WbPIhtuqSlvj0QPOA6WB8dAcUik0Y5wfPAPHHcjsMRD37+X//W5rzNzMvGrt/4D3vLmX6MfHPf1+4o5Z3LOmBkppWIBoK5rYozUdY23LasPtbAhjHa5yj2vLBPPeE64Bci5DdCjbHYMzzXZK7JDF2/wLuJYWwaj6+lvBZ4zw68vu5OzkbNhlto6vpnHwiBnzJq/6LnGLZAd3O3Mn8RGXA9Ftip3pzJoGiOPbS/YCDFy7JmH+eAH/5R/9Pbf43V7Eu/74z9i78s/zmv3v4I6JUIVVvQkO/1+f9C4V9XzLBFtohgjADt37hwEue57SqlIHlJKpNT2akNF7E0CPfBEiUY+uxP7faqqGhyZ5Ll5bkUZnN/97aXF5dcaY4/Yn8KtIlDjZstBeJMYjnd/1iugTxUzMTT1f6l2SDXQBUSR7amCjBOa3pcnam+2rj3y8PfoX7qft73tH7ODmn/4hr/m+z88yGv3v4JABuLgj5gZvV4PgLm5OY4cOdJ0/FIuNsJJKTE9Pc3TTz9Nv98HYHp6miuuuGLko5sVLLJ48iRTcQk7/QyBCnxlr3tkSbtjdZ+wcJSLL9xJz3fTn7qYvPuCLTbVOEIOmOGe8aVT9JaOEWYfJ6Q0mHLc/GPh7QjH2pFlIMSavp/isj0T9Kf3tjG+TD0Q2Uq6tf+cM9XK3q5D2zgvzJzgZZdewmINO6pT7Lr0Mp6bWwIghAi+/JvuziOPPALA7bffzu23317w5SzbsWMHc3Nzg/sPP/zwWPIBcOi+z/Pd+z4/tvSXHRt3BsbqyU//ybizAEcPjjsHIlvC8pxXt8DZjvh70xcyOztDrwKYZP7EDL1dTe/MWQL6g1+NMfKud72LW2+9lX6/z+zsbKHsr+TuVFXF5OTk+Hv07uScmv5syay0SxQWQrN+RHtoz++lmzW0E755CbwGC+34xja9LJotN44R2gvbHNyxYGDV5iYmcg4ZXkefnJxcHuE4mWZSoHH5L1zDw3/7Mb773d/g5y+s+crXvsPvf/j3mp/NDpUNrhrt9/u8+93vLvcq5CxsuwgzVmuXto6ByDBzTw6h7aM55qHd8Xyaz336L/nMF+6hqnrcfOubePs7fpMdBuRm6k2nkoiInC1zX311hg8usznNzLHnWKDP7t276EGzAG6rF16zdt+IiMgG1gw40O4sYAmsWatJQPDueoN2baBYNkVE5Fy37oUyZobnQPa8vJm0u15OkUZERF6gja/MDBWBNr501xGMe/eXiIick17gWwE0F3sq5IiIyAv1vB9P0IxujO7yBRh+c0SFHhEROTsbvudLd5nn8jtBioiIvDjr7lITERHZTHqvdBERKeL/A2RDYyp9vOqhAAAAAElFTkSuQmCC" alt></p><p>输入：<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code><br>输出：6<br>解释：上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例 2：</strong><br>输入：<code>height = [4,2,0,3,2,5]</code><br>输出：9</p><p>提示：</p><ul><li>n == height.length</li><li>1 &lt;= n &lt;= 2 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h2 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h2><p>逐个计算每一列能存下的水量。</p><p>遍历整个数组。针对数组中的每个元素<code>arr[i]</code>，都分别向左、向右遍历一遍数组，找到<code>arr[i]</code>左侧和右侧的最大值，计为<code>leftMax</code>和<code>rightMax</code>，如果<code>leftMax &lt;= arr[i]</code>或者<code>rightMax &lt;= arr[i]</code>，说明当前这一列存不出水。否则当前列能存储的水量为<code>min(leftMax, rightMax) - arr[i]</code>。</p><p>所以数组的i位置能存储的水量<code>res[i] = max{0, min{max(arr[0...i-1]), max(arr[i+1...n])} - arr[i] }</code>。</p><p>再思考一下，如果<code>max(arr[0...i-1]) &gt; arr[i]</code>，那么数组<code>0</code>到<code>i-1</code>位置的最大值和<code>0</code>到<code>i</code>位置的最大值一定是相等的；如果<code>max(arr[0...i-1]) &lt;= arr[i]</code>，那么数组<code>0</code>到<code>i</code>位置的最大值一定等于<code>arr[i]</code>，所以为了避免和<code>0</code>之间取<code>max</code>的计算，上述公式可以化简为下面的形式。<br><code>res[i] = min{max{arr[0... i]} , max{arr[i . . . n − 1]}} − arr[i]</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) {</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (height[j] &gt; leftMax) {</span><br><span class="line">                leftMax = height[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (height[j] &gt; rightMax) {</span><br><span class="line">                rightMax = height[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        sum += <span class="built_in">min</span>(leftMax, rightMax) - height[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>从暴力解法中我们可以看到，要求数组<code>i</code>位置可以存储的水量，需要先求出<code>0</code>到<code>i</code>位置的最大值<code>max(arr[0...i])</code>，再求出<code>i</code>到<code>n-1</code>位置的最大值<code>max(arr[i...n-1])</code>，两个值中取最小与<code>arr[i]</code>做差。</p><p>暴力解法之所以时间复杂度比较差，是因为对于数组中的每一个元素，都需要再遍历一遍数组才能得到它左右两侧的最大值。</p><p>所以我们可以通过预处理数组得到<code>leftMax[]</code>和<code>rightMax[]</code>两个数组，<code>leftMax[i]</code>代表数组<code>0</code>到<code>i</code>位置的最大值，<code>leftMax[i] = max(leftMax[i-1], arr[i])</code>；<code>rightMax[i]</code>代表数组<code>i</code>位置到<code>n-1</code>位置的最大值，<code>rightMax[i] = max(rightMax[i+1], arr[i])</code>。</p><p>这样我们就得到了如下的算法流程。</p><p>首先遍历数组，从左向右得到数组<code>leftMax[]</code>，再从右向左得到<code>rightMax[]</code>。然后再遍历一遍数组，对于数组的每一个位置<code>i</code>，通过<code>leftMax[i]</code>，<code>rightMax[i]</code>和<code>arr[i]</code>得到结果，将结果汇总得到的值就是最终答案。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) {</span><br><span class="line">        leftMax[i] = <span class="built_in">max</span>(leftMax[i<span class="number">-1</span>], height[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        rightMax[i] = <span class="built_in">max</span>(rightMax[i<span class="number">+1</span>], height[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) {</span><br><span class="line">        res += <span class="built_in">min</span>(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h2 id="解法三：双指针进阶"><a href="#解法三：双指针进阶" class="headerlink" title="解法三：双指针进阶"></a>解法三：双指针进阶</h2><p>解法二中的双指针需要遍历三次数组，第一次得出数组<code>leftMax[]</code>，第二次得出数组<code>rightMax[]</code>，第三次才是根据<code>leftMax[i]</code>，<code>rightMax[i]</code>和<code>height[i]</code>得出结果。那我们能不能想办法把这三次遍历合并成一次呢？</p><p>我们设置两个指针，<code>left</code>指向数组的<code>0</code>位置，<code>right</code>指针指向数组的<code>n-1</code>位置。再使用两个变量<code>leftMax</code>和<code>rightMax</code>，<code>leftMax</code>的含义是数组<code>0...left</code>位置的最大值，<code>rightMax</code>的含义是数组<code>right...n-1</code>位置的最大值，这几个变量设置好后就有以下几种情况。</p><ul><li><code>leftMax &lt; rightMax</code>，此时可以使用<code>leftMax</code>来结算<code>height[left]</code>位置的储水量。它的右侧可能还会有比<code>rightMax</code>更高的元素，但不会影响<code>left</code>位置的储水量。因为这种情况下<code>left</code>位置左侧的最大值是影响该位置储水量的瓶颈，此时<code>res[left] = leftMax - height[left]</code>。</li><li><code>leftMax &gt; rightMax</code>，此时可以使用<code>rightMax</code>来结算<code>right</code>位置的储水量。同样的，它的左侧可能还会有比<code>leftMax</code>更高的元素，但都不影响<code>right</code>位置的储水量。因为这种情况下<code>right</code>位置右侧的最大值是影响该位置储水量的瓶颈。此时<code>res[right] = rightMax - height[right]</code>。</li><li><code>leftMax == rightMax</code>，此时既可以结算左侧，也可以结算右侧，或者左右两侧可以同时结算储水量。<code>res[left] = leftMax - height[left]</code>，<code>res[right] = rightMax - height[right]</code>。但是要注意如果结算前<code>left == right</code>，此时只能结算一侧。</li></ul><p>不断重复上述流程，哪侧结算就将哪侧的指针相应移动，并在移动的过程中更新<code>leftMax</code>和<code>rightMax</code>，直到两个指针会合，结算完最后一个位置的水量为止。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right]);</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) {</span><br><span class="line">                res += leftMax - height[left++];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (leftMax &gt;= rightMax) {</span><br><span class="line">                res += rightMax - height[right--];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地项目上传到 GitHub 仓库的步骤</title>
      <link href="/2025/07/12/others/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%20GitHub%20%E4%BB%93%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
      <url>/2025/07/12/others/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%20GitHub%20%E4%BB%93%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="首次上传新项目到-GitHub"><a href="#首次上传新项目到-GitHub" class="headerlink" title="首次上传新项目到 GitHub"></a>首次上传新项目到 GitHub</h3><p>如果你有一个全新的本地项目，还没有任何 Git 初始化或关联，可以按照以下步骤操作：</p><ol><li><p><strong>在本地项目文件夹中初始化 Git 仓库：</strong><br> 打开项目文件夹，右键点击空白处，选择“Git Bash Here”或者打开终端/命令提示符，导航到项目目录。然后运行：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p> 这会在项目文件夹中创建一个名为 <code>.git</code> 的隐藏文件夹，表示本地仓库已初始化。</p></li><li><p><strong>将项目文件添加到暂存区：</strong><br> 接下来，需要告诉 Git 哪些文件需要被追踪并提交。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p> <code>git add .</code> 会将当前目录下所有文件（包括子文件夹中的文件）添加到暂存区。如果只想添加特定文件，可以将 <code>.</code> 替换为文件名或文件夹名。</p></li><li><p><strong>提交到本地仓库：</strong><br> 现在，将暂存区的文件提交到本地 Git 仓库，并附上一条有意义的提交信息。    </p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m "Initial commit of my project"</span><br></pre></td></tr></table></figure><p> 将 <code>"Initial commit of my project"</code> 替换为你自己的提交信息。</p></li><li><p><strong>在 GitHub 上创建新的远程仓库：</strong></p><ul><li>登录 GitHub 账号。</li><li>点击页面右上角的 <code>+</code> 号，选择 “New repository”（新建仓库）。</li><li>填写仓库名称，可以添加描述，选择公共或私有。</li><li>点击 “Create repository”（创建仓库）。</li></ul></li><li><strong>关联本地仓库与远程仓库：</strong><br> 创建成功后，GitHub 会显示一些指令，需要复制并运行其中的两行命令。它们通常是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;你的GitHub仓库地址&gt;</span><br><span class="line">git branch -M main # 或者 git branch -M master，取决于你希望默认分支叫什么</span><br></pre></td></tr></table></figure> <code>&lt;你的GitHub仓库地址&gt;</code> 通常是 <code>https://github.com/你的用户名/你的仓库名.git</code>。<br> <code>git remote add origin &lt;你的GitHub仓库地址&gt;</code>：给 GitHub 仓库地址起一个名叫 <code>origin</code> 的别名，并将其添加到你本地 Git 仓库的远程配置中。<br> <code>git branch -M main</code>：将当前你所在的本地分支（通常是刚初始化的 <code>master</code> 分支）强制重命名为 <code>main</code></li></ol><ol><li><strong>将本地代码推送到 GitHub：</strong><br> 最后，将本地 main（或 master）分支的代码推送到 GitHub 远程仓库。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure> 将本地仓库的 <code>main</code> (或 <code>master</code>) 分支上的提交推送到名为 <code>origin</code> 的远程仓库。<br> <code>-u</code> 选项会在第一次推送时设置上游分支，这样以后只需要运行 <code>git push</code> 即可。</li></ol><h3 id="后续代码更新后的推送步骤"><a href="#后续代码更新后的推送步骤" class="headerlink" title="后续代码更新后的推送步骤"></a>后续代码更新后的推送步骤</h3><ol><li><p><strong>提交本地更改：</strong><br> 在对项目进行了修改、新增文件或删除了文件之后，需要将这些更改提交到本地 Git 仓库中。</p><ul><li><strong>添加更改到暂存区：</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>  这条命令会将所有修改过的、新增的或删除的文件添加到暂存区。如果只想添加特定文件，可以将 <code>.</code> 替换为相应的文件名或文件夹名。</li><li><strong>提交更改到本地仓库：</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m "Your meaningful commit message here"</span><br></pre></td></tr></table></figure>  将 <code>"Initial commit of my project"</code> 替换为你自己的提交信息。</li></ul></li><li><p><strong>将本地提交推送到 GitHub：</strong><br> 完成本地提交后，就可以将这些新的提交推送到 GitHub 远程仓库了。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p> 由于在第一次推送时使用了 <code>-u</code> 选项（<code>git push -u origin main</code>），Git 已经记住了本地 <code>main</code> 分支应该推送到 <code>origin</code>（您的 GitHub 仓库）的 <code>main</code> 分支。所以，后续只需要运行 <code>git push</code> 即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA数据库连接报错“文件名或扩展名太长”</title>
      <link href="/2025/07/07/others/IDEA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E2%80%9C%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%96%E6%89%A9%E5%B1%95%E5%90%8D%E5%A4%AA%E9%95%BF%E2%80%9D/"/>
      <url>/2025/07/07/others/IDEA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E2%80%9C%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%96%E6%89%A9%E5%B1%95%E5%90%8D%E5%A4%AA%E9%95%BF%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在IDEA中连接MYSQL数据库时报错如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBMS: MySQL (no ver.)</span><br><span class="line">Case sensitivity: plain=mixed, delimited=exact</span><br><span class="line">Cannot run program "D:\IDEA\IntelliJ IDEA 2023.1.2\jbr\bin\java" (in directory "D:\college\javaWebStudy\hello-mp"): CreateProcess error=206, 文件名或扩展名太长。</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>卸载当前IDEA版本，更换新的IDEA版本。<br>本人：2023.1.2 -&gt;2024.3.6</p><p><strong>曾尝试过的无用方法：</strong><br>1.更换项目位置<br>将项目放在D盘下，没用</p><p>2.更改IDEA位置<br>卸载IDEA，更改IDEA的安装路径，使路径变短，没用。</p><p>3.配置 IntelliJ IDEA 的“Shorten command line”选项<br>没用<br><img src="/2025/07/07/others/IDEA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E2%80%9C%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%96%E6%89%A9%E5%B1%95%E5%90%8D%E5%A4%AA%E9%95%BF%E2%80%9D/file-20250707145907064.png" alt><br>4.配置 IntelliJ IDEA 使用短 Classpath<br>到 <code>Runner</code> 选项卡，勾选 <code>Delegate IDE build/run actions to Maven</code>，没用。<br><img src="/2025/07/07/others/IDEA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99%E2%80%9C%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%96%E6%89%A9%E5%B1%95%E5%90%8D%E5%A4%AA%E9%95%BF%E2%80%9D/file-20250707145726442.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> IntelliJ IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven安装依赖缓慢</title>
      <link href="/2025/07/03/others/Maven%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%BC%93%E6%85%A2/"/>
      <url>/2025/07/03/others/Maven%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%BC%93%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤一-更改settings-xml文件"><a href="#步骤一-更改settings-xml文件" class="headerlink" title="步骤一.更改settings.xml文件"></a>步骤一.更改settings.xml文件</h2><p>找到maven安装路径下的settings.xml文件，一般位于conf\setting.xml。<br>更改镜像配置如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">          &lt;id&gt;aliyun&lt;/id&gt;</span><br><span class="line">          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">          &lt;name&gt;aliyun Maven&lt;/name&gt;</span><br><span class="line">          &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;uk&lt;/id&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">            &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;CN&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;OSChina Central&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;internal nexus repository&lt;/name&gt;</span><br><span class="line">            &lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;</span><br><span class="line">            &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></p><h2 id="步骤二-Idea更改"><a href="#步骤二-Idea更改" class="headerlink" title="步骤二.Idea更改"></a>步骤二.Idea更改</h2><p>然后还要更改idea中maven的设置，选择自己maven所在位置，如下：<br>Maven home path选择自己的maven路径<br>User settings file选择自己的maven下的setting.xml<br>Local repository为本地仓库位置，一般会跟踪上述自动配置<br><img src="/2025/07/03/others/Maven%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%BC%93%E6%85%A2/file-20250703121619592.png" alt></p><h2 id="步骤三-刷新"><a href="#步骤三-刷新" class="headerlink" title="步骤三.刷新"></a>步骤三.刷新</h2><p><img src="/2025/07/03/others/Maven%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%BC%93%E6%85%A2/file-20250703121213440.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> IntelliJ IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub实现个人网站</title>
      <link href="/2025/05/30/others/GitHub%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
      <url>/2025/05/30/others/GitHub%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><p>仓库名字必须是 <code>&lt;你的用户名&gt;.github.io</code><br>Description可以不写<br>选择public<br><img src="/2025/05/30/others/GitHub%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/eaac9f755c400bcc0b7e6940dc95c02.png" alt></p><h2 id="2-本地创建文件夹"><a href="#2-本地创建文件夹" class="headerlink" title="2.本地创建文件夹"></a>2.本地创建文件夹</h2><p>文件夹内容如下，再让chatgpt随便写的内容用于测试<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-website/             ← 项目主文件夹</span><br><span class="line">├── index.html          ← 首页（主 HTML 文件）</span><br><span class="line">├── about.html          ← 其他页面（可选）</span><br><span class="line">├── contact.html        ← 其他页面（可选）</span><br><span class="line">├── css/                ← 所有样式文件</span><br><span class="line">│   └── style.css       ← 主样式表</span><br><span class="line">├── js/                 ← 所有 JavaScript 文件</span><br><span class="line">│   └── script.js       ← 主脚本文件</span><br><span class="line">├── images/             ← 图片资源</span><br><span class="line">│   ├── logo.png</span><br><span class="line">│   └── banner.jpg</span><br><span class="line">├── fonts/              ← 字体资源（可选）</span><br><span class="line">│   └── custom-font.woff</span><br><span class="line">├── assets/             ← 其他资源（视频、PDF 等，可选）</span><br><span class="line">│   └── brochure.pdf</span><br><span class="line">└── README.md           ← 项目说明文件（可选）</span><br></pre></td></tr></table></figure><br><img src="/2025/05/30/others/GitHub%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/file-20250530150135050.png" alt></p><h2 id="3-上传github-安装了Git-LFS"><a href="#3-上传github-安装了Git-LFS" class="headerlink" title="3.上传github(安装了Git LFS)"></a>3.上传github(安装了Git LFS)</h2><p>进入你的网站项目文件夹<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git lfs track "*.jpg"</span><br><span class="line">git lfs track "*.mp4" </span><br><span class="line">git add .</span><br><span class="line">git commit -m "初始提交，包含网站文件和 LFS 配置"</span><br><span class="line">git remote add origin https://github.com/你的用户名/你的仓库名.git.io</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></p><h2 id="4-访问网站"><a href="#4-访问网站" class="headerlink" title="4.访问网站"></a>4.访问网站</h2><p>提交后如上，使用<code>https://你的用户名.github.io/)</code>就可以访问了<br><img src="/2025/05/30/others/GitHub%E5%AE%9E%E7%8E%B0%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/file-20250530153126862.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 播客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置多个 GitHub 账号（SSH）</title>
      <link href="/2025/05/30/others/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%20GitHub%20%E8%B4%A6%E5%8F%B7%EF%BC%88SSH%EF%BC%89/"/>
      <url>/2025/05/30/others/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%20GitHub%20%E8%B4%A6%E5%8F%B7%EF%BC%88SSH%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>假设一个名字为aaa，一个名字为bbb</p><h2 id="1-为每个账号生成不同的-SSH-密钥"><a href="#1-为每个账号生成不同的-SSH-密钥" class="headerlink" title="1.为每个账号生成不同的 SSH 密钥"></a>1.为每个账号生成不同的 SSH 密钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为账号 aaa</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">"aaa@example.com"</span> -f ~/.ssh/id_ed25519_aaa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为账号 bbb</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">"bbb@example.com"</span> -f ~/.ssh/id_ed25519_bbb</span><br></pre></td></tr></table></figure><h2 id="2-将公钥添加到对应-GitHub-账户"><a href="#2-将公钥添加到对应-GitHub-账户" class="headerlink" title="2.将公钥添加到对应 GitHub 账户"></a>2.将公钥添加到对应 GitHub 账户</h2><p>进行下述操作，得到<code>.pub</code> 文件内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519_aaa.pub</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519_bbb.pub</span><br></pre></td></tr></table></figure><br>进入各自的 GitHub 账号页面：</p><ul><li>打开 GitHub → <strong>Settings → SSH and GPG keys → New SSH key</strong></li><li>把你生成的 <code>.pub</code> 文件内容粘贴进去</li></ul><h2 id="3-配置-SSH-配置文件-ssh-config"><a href="#3-配置-SSH-配置文件-ssh-config" class="headerlink" title="3.配置 SSH 配置文件 ~/.ssh/config"></a>3.配置 SSH 配置文件 <code>~/.ssh/config</code></h2><p>打开 SSH 配置文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">notepad ~/.ssh/config</span><br></pre></td></tr></table></figure></p><p>写入以下内容（每个账户一个 Host）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aaa 账号配置</span><br><span class="line">Host github-aaa</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_aaa</span><br><span class="line"></span><br><span class="line"># bbb 账号配置</span><br><span class="line">Host github-bbb</span><br><span class="line">  HostName github.com</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519_bbb</span><br></pre></td></tr></table></figure></p><h2 id="4-项目中使用不同的-SSH-地址"><a href="#4-项目中使用不同的-SSH-地址" class="headerlink" title="4.项目中使用不同的 SSH 地址"></a>4.项目中使用不同的 SSH 地址</h2><p>假设你有两个项目分别归属于不同账号：<br>aaa 账号的项目使用下述<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github-aaa:aaa/aaa-project.git</span><br></pre></td></tr></table></figure></p><p>bbb 账号的项目使用下述<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin git@github-bbb:bbb/bbb-project.git</span><br></pre></td></tr></table></figure></p><p>注意：此处 <code>github-aaa</code> 和 <code>github-bbb</code> 是你在 <code>~/.ssh/config</code> 中定义的别名，替代了默认的 <code>github.com</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> github </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode买卖股票专题C++</title>
      <link href="/2025/04/27/code/leetcode/LeetCode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E4%B8%93%E9%A2%98C++/"/>
      <url>/2025/04/27/code/leetcode/LeetCode%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E4%B8%93%E9%A2%98C++/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-121买卖股票的最佳时机"><a href="#LeetCode-121买卖股票的最佳时机" class="headerlink" title="LeetCode 121买卖股票的最佳时机"></a>LeetCode 121买卖股票的最佳时机</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。<br>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天买入（价格=1），在第 5 天卖出（价格=6），利润 = 6-1 = 5。</span><br><span class="line">     注意不能在第 1 天买入然后第 2 天卖出。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成，最大利润为 0。</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="解法一：一次遍历，维护最小价格"><a href="#解法一：一次遍历，维护最小价格" class="headerlink" title="解法一：一次遍历，维护最小价格"></a>解法一：一次遍历，维护最小价格</h3><p><strong>题目重点：</strong><br>最多只能买一支股票</p><p><strong>思路</strong><br>所以我们从左到右遍历，记录“当前最小的买入价格”，然后计算每一天“如果今天卖出，能赚多少”。每次更新最大利润即可。<br>也就是需要两个变量：</p><ul><li>一个记录当前最低买入价格</li><li>一个记录当前最大利润</li></ul><p><strong>代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, prices[i] - min_price);</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：<code>O(n)</code> —— 只遍历一次数组</li><li>空间复杂度：<code>O(1)</code> —— 只使用了两个变量</li></ul><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p><strong>题目重点：</strong><br>最多只能买一支股票</p><p><strong>思路：</strong><br>1.确定dp数组以及下标的含义</p><ul><li><code>dp[i][0]</code>：第 i 天 <strong>不持有</strong> 股票的最大收益。</li><li><code>dp[i][1]</code>：第 i 天 <strong>持有</strong> 股票的最大收益。<br>2.确定递推公式</li><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);</code><br>  要么今天什么都不做，要么今天卖出</li><li><code>dp[i][1] = max(dp[i-1][1], -prices[i]);</code><br>  要么今天什么都不做，要么今天买入<br>3.dp数组如何初始化</li><li><code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));</code>表示当天收益为0</li><li><code>dp[0][0] = 0</code>，第0天没持股</li><li><code>dp[0][1] = -prices[0]</code>，第0天买了股票<br>4.确定遍历顺序</li><li><code>for (int i = 1; i &lt; prices.size(); i++)</code></li></ul><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化 dp 数组</span></span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)); </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;           <span class="comment">// 第一天不持有股票，最大利润为 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];  <span class="comment">// 第一天持有股票，最大利润为负值（买入）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="comment">// 不持有股票的最大利润：要么前一天就不持有，要么今天卖出</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 持有股票的最大利润：要么前一天就持有，要么今天买入</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">           </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)<h2 id="LeetCode122买卖股票的最佳时机II"><a href="#LeetCode122买卖股票的最佳时机II" class="headerlink" title="LeetCode122买卖股票的最佳时机II"></a>LeetCode122买卖股票的最佳时机II</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。<br>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。(你可以在同一天买入并卖出一支股票，系统认为这是一笔完整交易，合法且有效)<br>返回 _你能获得的 <strong>最大</strong> 利润_ 。</li></ul><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天买入（价格=1），第 3 天卖出（价格=5），利润=4。</span><br><span class="line">      接着在第 4 天买入（价格=3），第 5 天卖出（价格=6），利润=3。</span><br><span class="line">      总利润 = 4 + 3 = 7。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天买入，在第 5 天卖出，利润=4。</span><br></pre></td></tr></table></figure></p><p><strong>示例 3：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下，无法完成任何交易，利润为 0。</span><br></pre></td></tr></table></figure></p><h3 id="解法一：贪心算法"><a href="#解法一：贪心算法" class="headerlink" title="解法一：贪心算法"></a>解法一：贪心算法</h3><p><strong>题目重点：</strong><br>可以多次买卖，甚至当天买卖，但手里只能有一支股票</p><p><strong>思路：</strong><br>只要今天的价格比昨天高，就在昨天买入、今天卖出。即：只要有利润就卖出。</p><ul><li>我们不关心买入卖出是哪一天，只要能赚钱就赚。</li><li>实际上，这相当于把所有的上升区间的利润都累加起来。<br></li></ul><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) {</span><br><span class="line">                res = res + prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="解法二：动态规划，每天持有-不持有两种状态"><a href="#解法二：动态规划，每天持有-不持有两种状态" class="headerlink" title="解法二：动态规划，每天持有/不持有两种状态"></a>解法二：动态规划，每天持有/不持有两种状态</h3><p><strong>题目重点：</strong><br>可以多次买卖，甚至当天买卖，但手里只能有一支股票</p><p><strong>思路：</strong><br>1.确定dp数组以及下标的含义</p><ul><li><code>dp[i][0]</code>：第 i 天 <strong>不持有</strong> 股票的最大收益。</li><li><code>dp[i][1]</code>：第 i 天 <strong>持有</strong> 股票的最大收益。<br>2.确定递推公式</li><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code><br>  要么今天什么都不做，要么今天卖出</li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code><br>  要么今天什么都不做，要么今天买入<br>3.dp数组如何初始化</li><li><code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));</code>表示当天收益为0</li><li><code>dp[0][0] = 0</code>，第0天没持股</li><li><code>dp[0][1] = -prices[0]</code>，第0天买了股票<br>4.确定遍历顺序</li><li><code>for (int i = 1; i &lt; prices.size(); i++)</code></li></ul><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">//dp[i][0]：第 i 天 不持有股票的最大收益</span></span><br><span class="line">        <span class="comment">//dp[i][1]：第 i 天 持有股票的最大收益。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一天不持股为最大利润</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><br>也可以使用下面的代码<br>两种可能：<br>    <code>dp0=dp0</code>：此时<code>dp0</code>已经是前一天的<code>dp0</code><br>    <code>dp0=dp1+prices[i]</code>：此时当天进行了卖出操作，但是可以当天买入卖出，所以合理<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp0 = <span class="number">0</span>; <span class="comment">//不持有股票</span></span><br><span class="line">        <span class="type">int</span> dp1 = -prices[<span class="number">0</span>]; <span class="comment">//持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0, dp1 + prices[i]);</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0 - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="解法三：动态规划-状态压缩（滚动数组）"><a href="#解法三：动态规划-状态压缩（滚动数组）" class="headerlink" title="解法三：动态规划 + 状态压缩（滚动数组）"></a>解法三：动态规划 + 状态压缩（滚动数组）</h3><p><strong>题目重点：</strong><br>可以多次买卖，甚至当天买卖，但手里只能有一支股票</p><p><strong>思路：</strong><br>只保留前一天的两个状态，不用数组，节省空间。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> dp0 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> new_dp0 = <span class="built_in">max</span>(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="type">int</span> new_dp1 = <span class="built_in">max</span>(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = new_dp0;</span><br><span class="line">            dp1 = new_dp1;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一天不持股为最大利润</span></span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><h2 id="LeetCode123买卖股票的最佳时机III"><a href="#LeetCode123买卖股票的最佳时机III" class="headerlink" title="LeetCode123买卖股票的最佳时机III"></a>LeetCode123买卖股票的最佳时机III</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>prices</code>，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。<br>设计一个算法来计算你所能获取的 <strong>最大利润</strong>。你最多可以完成 <strong>两笔交易</strong>。<br><strong>注意：</strong>  你 <strong>不能同时参与多笔交易</strong>（也就是说，你必须在再次购买前卖出股票）。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（价格 = 0）买入，在第 6 天（价格 = 3）卖出，利润 = 3 - 0 = 3。  </span><br><span class="line">     随后，在第 7 天（价格 = 1）买入，在第 8 天（价格 = 4）卖出，利润 = 4 - 1 = 3。  </span><br><span class="line">     总利润 = 3 + 3 = 6。</span><br></pre></td></tr></table></figure><br> <strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（价格 = 1）买入，第 5 天（价格 = 5）卖出，利润 = 5 - 1 = 4。  </span><br><span class="line">     注意：最多两笔交易，但一次交易已经获得最大利润。</span><br></pre></td></tr></table></figure><br> <strong>示例 3：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有交易获取利润，返回 0。</span><br></pre></td></tr></table></figure><br><strong>示例 4：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><h3 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><p><strong>题目重点：</strong><br>可以买卖两次，且手里最多持有一支股票</p><p><strong>思路：</strong><br>1.确定dp数组以及下标的含义</p><ul><li><code>dp[i][0]</code>：第 i 天 <strong>第一次买入</strong> 后的最大利润</li><li><code>dp[i][1]</code>：第 i 天 <strong>第一次卖出</strong> 后的最大利润</li><li><code>dp[i][2]</code>：第 i 天 <strong>第二次买入</strong> 后的最大利润</li><li><code>dp[i][3]</code>：第 i 天 <strong>第二次卖出</strong> 后的最大利润<br>2.确定递推公式<br><code>dp[i][0] = max(dp[i-1][0], -prices[i])</code>：第一次买入<br><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>：第一次卖出<br><code>dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i])</code>：第二次买入<br><code>dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i])</code>：第二次卖出</li></ul><p>3.dp数组如何初始化</p><ul><li><code>dp[0][0] = -prices[0]</code> ：第一天第一次买入</li><li><code>dp[0][1] = 0</code>  ：第一天第一次卖出（无交易）</li><li><code>dp[0][2] = -prices[0]</code>   ：第一天第二次买入</li><li><code>dp[0][3] = 0</code> ： 第一天第二次卖出</li></ul><p>4.确定遍历顺序<br><code>for (int i = 1; i &lt; prices.size(); i++)</code></p><p><strong>代码：</strong><br>这里之间参考<code>LeetCode122买卖股票的最佳时机II</code>的解法三，对动态规划数组进行状态压缩。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> first_buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> first_sell = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> second_buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> second_sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            first_buy = <span class="built_in">max</span>(- prices[i], first_buy);</span><br><span class="line">            first_sell = <span class="built_in">max</span>(first_sell, first_buy + prices[i]);</span><br><span class="line">            second_buy = <span class="built_in">max</span>(second_buy, first_sell - prices[i]);</span><br><span class="line">            second_sell = <span class="built_in">max</span>(second_sell, second_buy + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(second_sell, first_sell);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)<h2 id="LeetCode188买卖股票的最佳时机IV"><a href="#LeetCode188买卖股票的最佳时机IV" class="headerlink" title="LeetCode188买卖股票的最佳时机IV"></a>LeetCode188买卖股票的最佳时机IV</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3>给定一个整数 <code>k</code> 和一个数组 <code>prices</code>，其中 <code>prices[i]</code> 是一支股票第 <code>i</code> 天的价格。<br>设计一个算法来计算你所能获得的最大利润。你最多可以完成 <code>k</code> 笔交易。<br><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前卖出股票）。</li></ul><p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天买入，第 2 天卖出，利润 = 4 - 2 = 2</span><br></pre></td></tr></table></figure></p><p> 示例 2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">    第 2 天买入，第 3 天卖出，利润 = 6 - 2 = 4；</span><br><span class="line">    第 5 天买入，第 6 天卖出，利润 = 3 - 0 = 3；</span><br><span class="line">    总利润 = 4 + 3 = 7。</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 100</code></li><li><code>1 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code><h3 id="解法：动态规划-1"><a href="#解法：动态规划-1" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><strong>题目重点：</strong><br>可以买卖K次，且手里最多持有一支股票</li></ul><p><strong>思路</strong><br>1）特殊情况优化：<br>如果 <code>k &gt;= prices.size() / 2</code>，说明交易次数不再受限制 —— 相当于题目 122，可以无限交易：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (k &gt;= prices.<span class="built_in">size</span>() / <span class="number">2</span>) {</span><br><span class="line">    <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>2）正常动态规划：<br>参考<code>LeetCode123买卖股票的最佳时机III</code>压缩后的解法，这道题的不同之处在于变量多了。<br>1.确定dp数组以及下标的含义</p><ul><li><code>dp[j][0]</code>：<strong>最多进行了 j 次交易，当前</strong>手上<strong>没有股票</strong>的最大利润；</li><li><code>dp[j][1]</code>：<strong>最多进行了 j 次交易，当前</strong>手上<strong>持有股票</strong>的最大利润。<br>2.确定递推公式<br>对于第 <code>i</code> 天、第 <code>j</code> 次交易，有：</li><li><code>dp[j][0] = max(dp[j][0], dp[j][1] + prices[i])</code><ul><li>今天<strong>不操作</strong> or <strong>卖出股票</strong></li></ul></li><li><code>dp[j][1] = max(dp[j][1], dp[j-1][0] - prices[i])</code><ul><li>今天<strong>不操作</strong> or <strong>买入股票</strong><br>3.dp数组如何初始化<br>初始化第 0 天的情况（即 <code>i = 0</code>）：</li></ul></li><li>对于所有 <code>j</code>：<ul><li><code>dp[j][0] = 0</code>：不持股初始利润为 0</li><li><code>dp[j][1] = -prices[0]</code>：持股初始利润为负第 0 天价格<br>解释：</li></ul></li><li>可以认为在第 0 天就可以买入（花钱），但不可能在第 0 天前卖出（所以 <code>dp[j-1][0]</code> 初始化为 0 是合理的）<br>4.确定遍历顺序</li><li>外层：<code>for (int i = 1; i &lt; prices.size(); ++i)</code> 遍历每天</li><li>内层：<code>for (int j = 1; j &lt;= k; ++j)</code> 从第 1 次交易开始往上转移（必须从 1 开始，因为 <code>dp[j-1][0]</code> 要存在）</li></ul><p><strong>代码：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) {</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) {</span><br><span class="line">                    res = res + prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)dp[j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) {</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);<span class="comment">//卖出</span></span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);<span class="comment">//买入</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间与空间复杂度：</strong></p><ul><li><strong>时间复杂度：</strong> O(n*k)</li><li><strong>空间复杂度：</strong> O(k)</li></ul><h2 id="LeetCode714买卖股票的最佳时机含手续费"><a href="#LeetCode714买卖股票的最佳时机含手续费" class="headerlink" title="LeetCode714买卖股票的最佳时机含手续费"></a>LeetCode714买卖股票的最佳时机含手续费</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：  </span><br><span class="line">- 在价格为 1 时买入  </span><br><span class="line">- 在价格为 8 时卖出，利润为 8 - 1 - 2 = 5  </span><br><span class="line">- 在价格为 4 时买入  </span><br><span class="line">- 在价格为 9 时卖出，利润为 9 - 4 - 2 = 3  </span><br><span class="line">总利润 = 5 + 3 = 8</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,3,7,5,10,3], fee = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure></p><h3 id="解法一：贪心算法-1"><a href="#解法一：贪心算法-1" class="headerlink" title="解法一：贪心算法"></a>解法一：贪心算法</h3><p>和之前无手续费的版本（LeetCode 122）思路很像。</p><p><strong>题目重点：</strong><br>可以买卖多次，甚至当天买卖，但手里只能有一支股票，有手续费。</p><p><strong>思路：</strong> </p><ul><li>原来在 LeetCode 122（无手续费）里，遇到每次涨价就买卖就行了。</li><li>但是加了手续费以后，每次交易（卖出）就要扣掉一次 <code>fee</code>，所以不能贪心地频繁买卖了。需要做到 尽量延迟卖出，一口气吃最大的上涨收益，摊平手续费的影响。</li><li>维护两个变量：<ul><li><code>持有状态 hold</code>：表示截至到目前为止，持有一支股票后，最大可能的收益。</li><li><code>不持有状态 cash</code>：表示截至到目前为止，不持有股票的最大收益。</li></ul></li><li>贪心逻辑：每天看卖了更赚钱还是不动更赚钱，买了更赚钱还是不动更赚钱。<ul><li>卖出（如果卖了赚得多，就卖出，同时付手续费）。</li><li>买入（如果买了未来有希望赚更多，就买入）。</li></ul></li><li>更新 cash：<code>cash = max(cash, hold + prices[i] - fee);</code><ul><li>我可以选择继续不买不卖，那就保持昨天的 <code>cash</code>。</li><li>也可以选择把手里的股票卖掉，那就拿到卖股票的钱 <code>prices[i]</code>，加上之前持有股票的利润 <code>hold</code>，然后扣掉手续费 <code>fee</code>。</li></ul></li><li>更新 hold：<code>hold = max(hold, cash - prices[i]);</code><ul><li>我可以选择继续持有股票，那就保持昨天的 <code>hold</code>。</li><li>也可以选择今天买一支新股票，那就从现在的 cash 里扣掉买股票的钱 <code>prices[i]</code>。</li></ul></li></ul><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="type">int</span> cash = <span class="number">0</span>;<span class="comment">//不持有股票</span></span><br><span class="line">        <span class="type">int</span> hold = -prices[<span class="number">0</span>];<span class="comment">//持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            cash = <span class="built_in">max</span>(cash, hold + prices[i] - fee);<span class="comment">//更新不持有股票，卖出</span></span><br><span class="line">            hold = <span class="built_in">max</span>(hold, cash - prices[i]);<span class="comment">//更新持有股票，买入</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="解法二：动态规划，每天持有-不持有两种状态-1"><a href="#解法二：动态规划，每天持有-不持有两种状态-1" class="headerlink" title="解法二：动态规划，每天持有/不持有两种状态"></a>解法二：动态规划，每天持有/不持有两种状态</h3><p>和之前无手续费的版本（LeetCode 122）思路很像。</p><p><strong>题目重点：</strong><br>可以买卖多次，甚至当天买卖，但手里只能有一支股票，有手续费。</p><p><strong>思路：</strong><br>1.确定dp数组以及下标的含义</p><ul><li><code>dp[i][0]</code>：第 i 天 <strong>不持有</strong> 股票的最大收益。</li><li><code>dp[i][1]</code>：第 i 天 <strong>持有</strong> 股票的最大收益。<br>2.确定递推公式</li><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]-fee)</code>  <ul><li>要么继承昨天就不持股的状态；</li><li>要么昨天持股，今天卖出，同时扣掉手续费 <code>fee</code>。</li></ul></li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code>  <ul><li>要么继承昨天就持股的状态；</li><li>要么昨天不持股，今天买入，花了 <code>prices[i]</code> 的钱。<br>3.dp数组如何初始化</li></ul></li><li><code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0));</code>表示当天收益为0</li><li><code>dp[0][0] = 0</code>，第0天没持股</li><li><code>dp[0][1] = -prices[0]</code>，第0天买了股票<br>4.确定遍历顺序</li><li><code>for (int i = 1; i &lt; prices.size(); i++)</code></li></ul><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//不持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]; <span class="comment">//持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id="解法三：动态规划-状态压缩（滚动数组）-1"><a href="#解法三：动态规划-状态压缩（滚动数组）-1" class="headerlink" title="解法三：动态规划 + 状态压缩（滚动数组）"></a>解法三：动态规划 + 状态压缩（滚动数组）</h3><p>和之前无手续费的版本（LeetCode 122）思路很像。</p><p><strong>题目重点：</strong><br>可以买卖多次，甚至当天买卖，但手里只能有一支股票，有手续费。</p><p><strong>思路：</strong><br>只保留前一天的两个状态，不用数组，节省空间。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp0 = <span class="number">0</span>; <span class="comment">//不持有股票</span></span><br><span class="line">        <span class="type">int</span> dp1 = -prices[<span class="number">0</span>]; <span class="comment">//持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            </span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0, dp1 + prices[i] - fee);</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0 - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><h2 id="LeetCode309买卖股票的最佳时机含冷冻期"><a href="#LeetCode309买卖股票的最佳时机含冷冻期" class="headerlink" title="LeetCode309买卖股票的最佳时机含冷冻期"></a>LeetCode309买卖股票的最佳时机含冷冻期</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组<code>prices</code>，其中第  <code>prices[i]</code> 表示第 <code>_i_</code> 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1：</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: prices = [1,2,3,0,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">第 1 天买入股票 (价格 = 1)</span><br><span class="line">第 2 天卖出股票 (价格 = 2)，利润为 1</span><br><span class="line">第 3 天冷冻期 (不能买)</span><br><span class="line">第 4 天买入股票 (价格 = 0)</span><br><span class="line">第 5 天卖出股票 (价格 = 2)，利润为 2</span><br><span class="line">总利润 = 1 + 2 = 3</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p><strong>题目重点：</strong><br>可以买卖多次，甚至当天买卖，但手里只能有一支股票，有冷冻期。</p><p><strong>思路：</strong><br>1.确定 dp 数组和下标含义<br>定义：</p><ul><li><code>dp[i][0]</code>：第 i 天持有股票的最大利润。</li><li><code>dp[i][1]</code>：第 i 天不持有股票，且今天卖出（下一天处于冷冻期，不能买入）</li><li><code>dp[i][2]</code>：第 i 天不持有股票，且今天没有卖出（）下一天不再冷冻期<br>2.确定递推公式</li><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])</code><ul><li>今天持有股票 = （昨天就持有）或（昨天没股票且不是冷冻，今天买入）</li></ul></li><li><code>dp[i][1] = dp[i-1][0] + prices[i]</code><ul><li>今天卖出股票（进入冷冻期）= 昨天持有股票 + 今天卖掉赚钱</li></ul></li><li><code>dp[i][2] = max(dp[i-1][1], dp[i-1][2])</code><ul><li>今天啥也没干 = （昨天是冷冻期过来的）或（昨天就是空闲状态）<br>3.初始化<br>第 0 天：</li></ul></li><li><code>dp[0][0] = -prices[0]</code>：买入股票</li><li><code>dp[0][1] = 0</code>：不可能卖股票，所以是 0</li><li><code>dp[0][2] = 0</code>：没买没卖，也是 0<br>4.确定遍历顺序<br>自然是按照天数 <code>i = 1 -&gt; n-1</code> 顺序遍历。</li></ul><p><strong>代码：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">//持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//不持有股票且此天卖出（下一天冷冻期）</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">//不持有股票且此天不卖出（下一天不在冷冻期）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(n)<h3 id="解法二：动态规划-状态压缩（滚动数组）"><a href="#解法二：动态规划-状态压缩（滚动数组）" class="headerlink" title="解法二：动态规划 + 状态压缩（滚动数组）"></a>解法二：动态规划 + 状态压缩（滚动数组）</h3><strong>题目重点：</strong><br>可以买卖多次，甚至当天买卖，但手里只能有一支股票，有冷冻期。</li></ul><p><strong>代码：</strong><br>此处只可这样写，不可<code>dp0 = max(dp0, dp2 - prices[i]);dp1 = dp0 + prices[i];dp2 = max(dp2, dp1);</code></p><ul><li>因为这样在更新<code>dp2 = max(dp2, dp1)</code>时是错的，如果<code>dp2=dp1</code>，那就是有冷冻期的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) {</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        int dp0 = -prices[0]; //持有股票</span><br><span class="line">        int dp1 = 0; //不持有股票且此天卖出（下一天冷冻期）</span><br><span class="line">        int dp2 = 0; //不持有股票且此天不卖出（下一天不在冷冻期）</span><br><span class="line">        for (int i = 1; i &lt; n; i++) {</span><br><span class="line">            int new_dp0 = max(dp0, dp2 - prices[i]);</span><br><span class="line">            int new_dp1 = dp0 + prices[i];</span><br><span class="line">            int new_dp2 = max(dp2, dp1);</span><br><span class="line">            dp0 = new_dp0;</span><br><span class="line">            dp1 = new_dp1;</span><br><span class="line">            dp2 = new_dp2;</span><br><span class="line">        }</span><br><span class="line">        return max(dp1, dp2);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li></ul><p><strong>时间和空间复杂度</strong></p><ul><li>时间复杂度：O(n) </li><li>空间复杂度：O(1)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-买卖股票的最佳时机（LeetCode-121）"><a href="#1-买卖股票的最佳时机（LeetCode-121）" class="headerlink" title="1. 买卖股票的最佳时机（LeetCode 121）"></a><strong>1. 买卖股票的最佳时机（LeetCode 121）</strong></h3><ul><li><strong>特点</strong>：只能买卖一次。</li><li><strong>解法</strong>：<ul><li><strong>一次遍历</strong>：维护当前最低价格 <code>min_price</code> 和最大利润 <code>max_profit</code>。</li><li><strong>动态规划</strong>：定义 <code>dp[i][0]</code>（不持股）和 <code>dp[i][1]</code>（持股）的状态转移。</li></ul></li></ul><p><strong>2. 买卖股票的最佳时机 II（LeetCode 122）</strong></p><ul><li><strong>特点</strong>：无限次交易，无手续费。</li><li><p><strong>解法</strong>：</p><ul><li><strong>贪心</strong>：所有上涨日都买卖，累加利润。</li><li><strong>动态规划</strong>：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code>（卖出）；<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code>（买入）。</li></ul><p><strong>3. 买卖股票的最佳时机 III（LeetCode 123）</strong></p></li><li><strong>特点</strong>：最多完成 <strong>两笔</strong> 交易。</li><li><strong>解法</strong>：<ul><li><strong>动态规划</strong>：扩展状态为 <code>dp[i][0]</code>（第一次买入）、<code>dp[i][1]</code>（第一次卖出）、<code>dp[i][2]</code>（第二次买入）、<code>dp[i][3]</code>（第二次卖出）。</li><li><strong>状态转移</strong>：<ul><li>第一次买入：<code>dp[i][0] = max(-prices[i], dp[i-1][0])</code>。</li><li>第一次卖出：<code>dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1])</code>。</li><li>第二次买入：<code>dp[i][2] = max(dp[i-1][1] - prices[i], dp[i-1][2])</code>。</li><li>第二次卖出：<code>dp[i][3] = max(dp[i-1][2] + prices[i], dp[i-1][3])</code>。</li></ul></li></ul></li></ul><p> <strong>4. 买卖股票的最佳时机 IV（LeetCode 188）</strong></p><ul><li><strong>特点</strong>：最多完成 <strong>k 笔</strong> 交易。</li><li><strong>解法</strong>：<ul><li><strong>动态规划</strong>：状态 <code>dp[j][0]</code>（第 j 次交易后不持股）和 <code>dp[j][1]</code>（第 j 次交易后持股）。</li><li><strong>状态转移</strong>：<ul><li><code>dp[j][0] = max(dp[j][0], dp[j][1] + prices[i])</code>（卖出）。</li><li><code>dp[j][1] = max(dp[j][1], dp[j-1][0] - prices[i])</code>（买入）。</li></ul></li><li><strong>优化</strong>：若 <code>k &gt;= n/2</code>，退化为无限交易问题（贪心）。</li></ul></li></ul><p> <strong>5. 买卖股票的最佳时机含手续费（LeetCode 714）</strong></p><ul><li><strong>特点</strong>：无限次交易，每笔交易付手续费。</li><li><strong>解法</strong>：<ul><li><strong>贪心</strong>：延迟卖出以摊平手续费，更新 <code>cash</code>（不持股）和 <code>hold</code>（持股）：<ul><li><code>cash = max(cash, hold + prices[i] - fee)</code>。</li><li><code>hold = max(hold, cash - prices[i])</code>。</li></ul></li><li><strong>动态规划</strong>：与无限交易类似，卖出时扣除手续费。</li></ul></li></ul><p><strong>6. 买卖股票的最佳时机含冷冻期（LeetCode 309）</strong></p><ul><li><strong>特点</strong>：卖出后需等待一天才能买入。</li><li><p><strong>解法</strong>：</p><ul><li><strong>动态规划</strong>：分三种状态：<ul><li><code>dp[i][0]</code>：持股（来自前一天的持股或非冷冻期买入）。</li><li><code>dp[i][1]</code>：不持股且当天卖出（下一天冷冻）。</li><li><code>dp[i][2]</code>：不持股且非卖出（下一天可买入）。</li></ul></li><li><strong>状态转移</strong>：<ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])</code>。</li><li><code>dp[i][1] = dp[i-1][0] + prices[i]</code>。</li><li><code>dp[i][2] = max(dp[i-1][1], dp[i-1][2])</code>。</li></ul></li></ul><p><strong>通用技巧</strong></p></li></ul><ol><li><strong>状态定义</strong>：通常用 <code>dp[i][k][0/1]</code> 表示第 i 天、第 k 次交易、是否持股的利润。</li><li><strong>初始条件</strong>：<code>dp[0][k][1] = -prices[0]</code>（第一天买入）。</li><li><strong>空间优化</strong>：多数问题可通过滚动变量（如 <code>cash</code>、<code>hold</code>）将空间复杂度降至 O(1)。</li><li><strong>边界处理</strong>：注意 <code>k</code> 的取值（如 <code>k &gt;= n/2</code> 时退化为贪心）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题解决-VScode代码复制到别处每行有间隔</title>
      <link href="/2025/04/23/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-VScode%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%88%B0%E5%88%AB%E5%A4%84%E6%AF%8F%E8%A1%8C%E6%9C%89%E9%97%B4%E9%9A%94/"/>
      <url>/2025/04/23/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-VScode%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6%E5%88%B0%E5%88%AB%E5%A4%84%E6%AF%8F%E8%A1%8C%E6%9C%89%E9%97%B4%E9%9A%94/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>将vscode的代码复制到有些地方，两行之间会空一行<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Background Position 示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box position-center"</span>&gt;</span>center center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box position-left-top"</span>&gt;</span>left top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box position-right-bottom"</span>&gt;</span>right bottom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box position-right-top"</span>&gt;</span>right top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>在粘贴的时候使用<code>ctrl+shift+v</code><br>会粘贴为纯文本，能防止目标软件加上段落格式和空行。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode189轮转数组C++</title>
      <link href="/2025/04/23/code/leetcode/LeetCode189%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84C++/"/>
      <url>/2025/04/23/code/leetcode/LeetCode189%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84C++/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。<br><strong>示例 1:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><br><strong>示例 2:</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><h3 id="解法一：反转法（O-n-时间-O-1-空间）"><a href="#解法一：反转法（O-n-时间-O-1-空间）" class="headerlink" title="解法一：反转法（O(n) 时间 + O(1) 空间）"></a>解法一：反转法（O(n) 时间 + O(1) 空间）</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>先将整个数组反转，然后分别反转前 <code>k</code> 个和后 <code>n-k</code> 个元素。<br>比如： 原始数组：<code>[1, 2, 3, 4, 5, 6, 7]</code><br>步骤：</p><ol><li>整体反转 → <code>[7,6,5,4,3,2,1]</code></li><li>前 <code>k=3</code> 个反转 → <code>[5,6,7,4,3,2,1]</code></li><li>后 <code>n-k=4</code> 个反转 → <code>[5,6,7,1,2,3,4]</code></li></ol><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="解法二：使用额外数组（O-n-时间-O-n-空间）"><a href="#解法二：使用额外数组（O-n-时间-O-n-空间）" class="headerlink" title="解法二：使用额外数组（O(n) 时间 + O(n) 空间）"></a>解法二：使用额外数组（O(n) 时间 + O(n) 空间）</h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>我们想把数组向右轮转 <code>k</code> 个位置，也就是说，<strong>每个元素的新位置是原位置加上 <code>k</code>，然后对数组长度 <code>n</code> 取模</strong>，这样就不会越界。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            temp[(i + k) % n] = nums[i];</span><br><span class="line">        }</span><br><span class="line">        nums = temp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode双指针专题-一个原数组，一个新数组</title>
      <link href="/2025/04/22/code/leetcode/LeetCode%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98-%E4%B8%80%E4%B8%AA%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E6%95%B0%E7%BB%84/"/>
      <url>/2025/04/22/code/leetcode/LeetCode%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98-%E4%B8%80%E4%B8%AA%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="LeetCode27-移除元素"><a href="#LeetCode27-移除元素" class="headerlink" title="LeetCode27.移除元素"></a>LeetCode27.移除元素</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为<br><code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p>示例：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums = [3,2,2,3], val = 3</span><br><span class="line">输出: 2, nums = [2,2,_,_]</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出: 5, nums = [0,1,3,0,4,_,_,_]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ol><li><strong>双指针法：</strong><ul><li><code>fast</code>：遍历数组，负责查找有效数字；</li><li><code>slow</code>：标记新数组的位置，覆盖无效元素。</li></ul></li><li>如果 <code>nums[fast] != val</code>，则将 <code>nums[fast]</code> 移动到 <code>nums[slow]</code>，然后 <code>slow++</code>。</li><li>遍历完成后，<code>slow</code> 的值就是新数组的长度。</li></ol><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(1)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) {</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h2 id="LeetCode26-删除有序数组中的重复项"><a href="#LeetCode26-删除有序数组中的重复项" class="headerlink" title="LeetCode26.删除有序数组中的重复项"></a>LeetCode26.删除有序数组中的重复项</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2，并且原数组 nums 的前两个元素被修改为 1 和 2。无需考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>考虑到题目中提及是有序数组，所有可以使用下述方法</p><ol><li><strong>双指针法：</strong><ul><li><code>fast</code>：遍历数组，查找新数组的元素；</li><li><code>slow</code>：指向新数组的结尾元素。</li></ul></li><li>如果 <code>nums[fast] != nums[slow]</code>，就说明找到了新的元素，<code>slow++</code>，然后将将 <code>nums[fast]</code> 移动到 <code>nums[slow]</code></li><li>遍历完成后，<code>slow + 1</code> 的值就是新数组的长度。</li></ol><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(1)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;<span class="comment">//新数组的末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">1</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[slow]) {<span class="comment">//找到新元素</span></span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h2 id="LeetCode80-删除有序数组中的重复项"><a href="#LeetCode80-删除有序数组中的重复项" class="headerlink" title="LeetCode80.删除有序数组中的重复项"></a>LeetCode80.删除有序数组中的重复项</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个有序数组 <code>nums</code> ，请你原地删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。</p><p> <strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新的长度 5，并且前五个元素为：1, 1, 2, 2, 3。</span><br><span class="line">函数返回的值和 nums 中元素的前五个值都正确即可，后面剩下的元素可以忽略。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br></pre></td></tr></table></figure></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>考虑到题目中提及是有序数组，所有可以使用下述方法</p><ol><li><strong>双指针法：</strong><ul><li><code>fast</code>：遍历数组，查找新数组的元素；</li><li><code>slow</code>：指向新数组的结尾元素。</li></ul></li><li>找到新元素的两种情况<ul><li><code>nums[slow] != nums[fast]</code>，此时不等于新数组的结尾元素，符合</li><li><code>nums[slow] == nums[fast]&amp;&amp; nums[slow] != nums[slow - 1]</code>，此时等于新数组的结尾元素，那这个元素只能数新数组中出现两次的最后一次</li></ul></li></ol><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(1)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>)<span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">2</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) {</span><br><span class="line">            <span class="keyword">if</span> ((nums[slow] != nums[fast]) || </span><br><span class="line">                (nums[slow] == nums[fast] &amp;&amp; nums[slow] != nums[slow - <span class="number">1</span>])) {</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ul><li>当想要用额外空间解决问题的时候，想一想可不可以用双指针。<ul><li>一个指针指向原数组位置</li><li>一个指针指向新数组位置</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode27.移除元素</title>
      <link href="/2025/04/18/code/leetcode/LeetCode27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2025/04/18/code/leetcode/LeetCode27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p>示例：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums = [3,2,2,3], val = 3</span><br><span class="line">输出: 2, nums = [2,2,_,_]</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出: 5, nums = [0,1,3,0,4,_,_,_]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="方法1：笨方法"><a href="#方法1：笨方法" class="headerlink" title="方法1：笨方法"></a>方法1：笨方法</h3><p>找个数组存不等于val的元素，然后赋值回去。</p><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(n)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) {</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);  <span class="comment">// 收集所有有效元素</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            nums[i] = temp[i];  <span class="comment">// 重新覆盖原数组</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();  <span class="comment">// 返回新数组的有效长度</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h3><ol><li><strong>双指针法：</strong><ul><li><code>fast</code>：遍历数组，负责查找有效数字；</li><li><code>slow</code>：标记新数组的位置，覆盖无效元素。</li></ul></li><li>如果 <code>nums[fast] != val</code>，则将 <code>nums[fast]</code> 移动到 <code>nums[slow]</code>，然后 <code>slow++</code>。</li><li>遍历完成后，<code>slow</code> 的值就是新数组的长度。</li></ol><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(1)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) {</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul><li>当想要用额外空间解决问题的时候，想一想可不可以用双指针。<ul><li>一个指针指向原数组位置</li><li>一个指针指向新数组位置。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode27.移除元素C++</title>
      <link href="/2025/04/18/code/leetcode/LeetCode27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2025/04/18/code/leetcode/LeetCode27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p>示例：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入: nums = [3,2,2,3], val = 3</span><br><span class="line">输出: 2, nums = [2,2,_,_]</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出: 5, nums = [0,1,3,0,4,_,_,_]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="方法1：笨方法"><a href="#方法1：笨方法" class="headerlink" title="方法1：笨方法"></a>方法1：笨方法</h3><p>找个数组存不等于val的元素，然后赋值回去。</p><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(n)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) {</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);  <span class="comment">// 收集所有有效元素</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            nums[i] = temp[i];  <span class="comment">// 重新覆盖原数组</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();  <span class="comment">// 返回新数组的有效长度</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h3><ol><li><strong>双指针法：</strong><ul><li><code>fast</code>：遍历数组，负责查找有效数字；</li><li><code>slow</code>：标记新数组的位置，覆盖无效元素。</li></ul></li><li>如果 <code>nums[fast] != val</code>，则将 <code>nums[fast]</code> 移动到 <code>nums[slow]</code>，然后 <code>slow++</code>。</li><li>遍历完成后，<code>slow</code> 的值就是新数组的长度。</li></ol><p>时间复杂度： <code>O(n)</code><br>空间复杂度：<code>O(1)</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) {</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul><li>当想要用额外空间解决问题的时候，想一想可不可以用双指针。<ul><li>一个指针指向原数组位置</li><li>一个指针指向新数组位置。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode88. 合并两个有序数组C++</title>
      <link href="/2025/04/18/code/leetcode/LeetCode88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84C++/"/>
      <url>/2025/04/18/code/leetcode/LeetCode88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84C++/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意</strong>：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例：</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3  </span><br><span class="line">nums2 = [2,5,6], n = 3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="方法1：笨方法"><a href="#方法1：笨方法" class="headerlink" title="方法1：笨方法"></a>方法1：笨方法</h3><p>最简单粗暴的方法就是用一个数组来<br>存放nums1，将nums1当作最终结果数组。</p><p>时间复杂度：O(m + n)<br>空间复杂度：O(m)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>begin() + m)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums2[j]) {</span><br><span class="line">                nums1[cur] = nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                nums1[cur] = nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            cur++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m) {</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; m; i++) {</span><br><span class="line">                nums1[cur] = nums[i];</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n; j++) {</span><br><span class="line">                nums1[cur] = nums2[j];</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h3 id="方法2：从后往前"><a href="#方法2：从后往前" class="headerlink" title="方法2：从后往前"></a>方法2：从后往前</h3><p>由于 <code>nums1</code> 的末尾预留了足够空间，可以采用<strong>从后往前</strong>的双指针策略，这样就不会覆盖掉还没处理的元素！</p><ul><li><code>p1</code> 指向 <code>nums1</code> 的有效部分末尾（<code>m-1</code>）。</li><li><code>p2</code> 指向 <code>nums2</code> 的末尾（<code>n-1</code>）。</li><li><code>p</code> 指向 <code>nums1</code> 最后的填充位置（<code>m + n - 1</code>）。<br>依次比较 <code>nums1[p1]</code> 和 <code>nums2[p2]</code>，将较大的数放到 <code>nums1[p]</code>，指针相应后移，直到 <code>nums2</code> 全部处理完。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="type">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) {</span><br><span class="line">                nums1[cur] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                nums1[cur] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            cur--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) {</span><br><span class="line">            nums1[cur] = nums2[j];</span><br><span class="line">            j--;</span><br><span class="line">            cur--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul><li>要考虑正向填充和反向填充</li><li>当想要用额外空间解决问题的时候，想一想可不可以用双指针。<ul><li>一个指针指向原数组位置</li><li>一个指针指向新数组位置。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode背包专题C++</title>
      <link href="/2025/04/17/code/leetcode/LeetCode%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98C++/"/>
      <url>/2025/04/17/code/leetcode/LeetCode%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意<br>以下内容理论部分有参考《代码随想录》，推荐看了代码随想录得背包问题相关内容后再刷代码。<br><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">代码随想录</a></p></blockquote><p><img src="/2025/04/17/code/leetcode/LeetCode%E8%83%8C%E5%8C%85%E4%B8%93%E9%A2%98C++/file-20250410173038988.png" alt></p><h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个正在抢劫商店的小偷发现了<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个商品，第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="17.978ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7946.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(734,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">范</text></g><g data-mml-node="mi" transform="translate(1734,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">围</text></g><g data-mml-node="mi" transform="translate(2734,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="mo" transform="translate(3734,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(4012,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4512,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(4956.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5778.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6779.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7279.1,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(7557.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>个商品价值<code>value[i]</code>美元，重<code>weight[i]</code>磅，<code>value[i]</code>和<code>weight[i]</code>都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="2.371ex" height="1.595ex" role="img" focusable="false" viewbox="0 -683 1048 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g></g></g></svg></mjx-container>磅重的商品，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="2.371ex" height="1.595ex" role="img" focusable="false" viewbox="0 -683 1048 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"/></g></g></g></svg></mjx-container>是一个整数。他应该拿哪些商品呢？<br>（我们称这个问题是0-1背包问题，因为对每个商品，小偷要么把它完整拿走，要么把它留下；他不能只拿走一个商品的一部分，或者把一个商品拿走多次。）</p><h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h3><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p><strong>1.确定dp数组以及下标的含义</strong><br><code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少。</p><p><strong>2.确定递推公式</strong><br>对于物体<code>i</code>只有两种情况</p><ul><li>不放物品<code>i</code>：背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值是<code>dp[i - 1][j]</code>。</li><li>放物品<code>i</code>：背包空出物品<code>i</code>的容量后，背包容量为<code>j - weight[i]</code>，<code>dp[i - 1][j - weight[i]]</code>为背包容量为<code>j - weight[i]</code>且不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code>，就是背包放物品i得到的最大价值。<br>递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></li></ul><p><strong>3.dp数组如何初始化</strong><br>对于<code>i</code>：<br>    由递推公式的<code>dp[i-1][j]</code>知，需要考虑<code>dp[0][j]</code>的情况。<br>    当 <code>j &lt; weight[0]</code>的时候，<code>dp[0][j]</code>应该是 0，因为背包容量比编号0的物品重量还小。<br>    当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code>应该是<code>value[0]</code>，因为背包容量放足够放编号0物品。</p><p>对于<code>j</code>：<br>    如果背包容量j为0的话，即<code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p><p>故初始化代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) {  </span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) {</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p><strong>4.确定遍历顺序</strong><br>两种情况：</p><ul><li>先<code>i</code>后<code>j</code>，先物品后背包重量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>先<code>j</code>后<code>i</code>，先背包重量后物品<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p><strong>1.确定dp数组以及下标的含义</strong><br><code>dp[j]</code>表示：容量为<code>j</code>的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><strong>2.确定递推公式</strong><br>对于物体<code>i</code>只有两种情况</p><ul><li>不放物品<code>i</code>：背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值是<code>dp[j]</code>。</li><li>放物品<code>i</code>：背包空出物品<code>i</code>的容量后，背包容量为<code>j - weight[i]</code>，<code>dp[j - weight[i]]</code>为背包容量为<code>j - weight[i]</code>且不放物品i的最大价值，那么<code>dp[j - weight[i]] + value[i]</code>，就是背包放物品i得到的最大价值。<br>递归公式： <code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></li></ul><p><strong>3.dp数组如何初始化</strong><br>对于<code>j</code>：<br>    如果背包容量j为0的话，即<code>dp[0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p><p>故初始化代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>4.确定遍历顺序</strong><br>两种情况：</p><ul><li><p>先<code>i</code>后<code>j</code>，先物品后背包重量<br>  这里第二层循环背包重量是从大到小，为了保证物品<code>i</code>只被放入一次。<br>  因为如果是从小到大，假设对于物体<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.768ex" height="1.87ex" role="img" focusable="false" viewbox="0 -661 781.6 826.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(378,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>，它可能在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="5.869ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 2594.1 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(689.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1745.6,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>的时候满足条件，进入过一次背包，结果在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.486ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6402.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(689.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1745.6,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(2594.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(2983.1,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(4109.4,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="msub" transform="translate(5165.2,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(6013.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>的时候又满足条件，放进背包，这就不是01背包问题了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>先<code>j</code>后<code>i</code>，先背包重量后物品<br>  不可以！！！<br>  首先，要和上面一样，背包重量是从大到小。<br>  但是，这样的话，背包只能放一个物品。因为背包重量是从大到小，那<code>dp[j - weight[i]] + value[i]</code>其实用于是<code>0+value[i]</code>，也就是只能放一个物品。</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不可以这样写！！！！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= <span class="number">0</span>; j--) { <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h2 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h2><h3 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个 <strong>只包含正整数</strong> 的非空数组 <code>nums</code>，判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><ul><li><strong>示例 1：</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 5, 11, 5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分成 [1, 5, 5] 和 [11]，两个子集和相等。</span><br></pre></td></tr></table></figure></li><li><strong>示例 2：</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3, 5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为01背包问题：</strong><br>这个问题可以变成一个 01 背包问题：从 <code>nums</code> 中选出一部分数字，使得它们的和恰好是 <code>sum / 2</code>。</p><ul><li>如果数组的总和是奇数，那就肯定不能划分。</li><li>如果是偶数，就尝试用动态规划找出是否存在子集和为 <code>sum / 2</code>。<br>需要找到一些数，使数的和为sum/2;</li></ul><p><strong>动态规划步骤：</strong><br>1.确定dp数组以及下标的含义<br><code>dp[j]</code>表示和是否可以组成<code>j</code><br>2.确定递推公式<br><code>if(dp[j-nums[i]]==true)dp[j]=true</code><br>3.dp数组如何初始化<br><code>dp[0]=true</code><br>4.确定遍历顺序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=sum/<span class="number">2</span>;j&gt;=nums[i];j--)</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            sum = sum + nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= nums[i]; j--) {</span><br><span class="line">                <span class="keyword">if</span> (dp[j - nums[i]] == <span class="literal">true</span>)dp[j] = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="Leetcode-1049-最后一块石头的重量-II"><a href="#Leetcode-1049-最后一块石头的重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头的重量 II"></a>Leetcode 1049. 最后一块石头的重量 II</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出 <strong>任意两块</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果两块石头重量相同，那么它们都会被完全粉碎；</li><li>如果两块石头重量不同，那么较重的石头会剩下重量为 <code>较重 − 较轻</code> 的新石头。</li></ul><p>最后，最多剩下一块石头，返回这块石头的最小可能重量。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">    可能的一种方案是：</span><br><span class="line">    - (2,4) -&gt; 2</span><br><span class="line">    - (1,1) -&gt; 0</span><br><span class="line">    - (2,7) -&gt; 5</span><br><span class="line">    - (5,8) -&gt; 3</span><br><span class="line">    - (3,0) -&gt; 3</span><br><span class="line">    最小的可能重量为 1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 100</code></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为01背包问题：</strong></p><ul><li>设总重量为 <code>sum</code>，这道题的目的其实时尽可能将石头平均分成两堆，一堆小于等于<code>n/2</code>，一堆大于等于<code>n/2</code>。</li><li>所以本质就是一个 <strong>01 背包问题</strong>，目标是找到一组石头，它们的重量和 <code>s</code> 尽可能接近 <code>sum / 2</code>。</li></ul><p><strong>动态规划步骤：</strong><br>1.确定dp数组以及下标的含义<br><code>dp[j]</code>表示容量为 <code>j</code> 的背包最多能装多少重量的石头<br>2.确定递推公式<br><code>dp[j] = max(dp[j], dp[j - stone] + stone)</code><br>3.dp数组如何初始化<br><code>vector&lt;int&gt; dp(target + 1, 0);</code><br>4.确定遍历顺序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=sum/<span class="number">2</span>;j&gt;=nums[i];j--)</span><br></pre></td></tr></table></figure></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            sum = sum + stones[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) {</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode494-目标和"><a href="#LeetCode494-目标和" class="headerlink" title="LeetCode494. 目标和"></a>LeetCode494. 目标和</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p> <strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3  </span><br><span class="line">输出：5  </span><br><span class="line">解释：总共有 5 种方法让最终结果为 3：  </span><br><span class="line">-1 +1 +1 +1 +1 = 3  </span><br><span class="line">+1 -1 +1 +1 +1 = 3  </span><br><span class="line">+1 +1 -1 +1 +1 = 3  </span><br><span class="line">+1 +1 +1 -1 +1 = 3  </span><br><span class="line">+1 +1 +1 +1 -1 = 3</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 1  </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为01背包问题：</strong><br>设数组中所有数的和为 <code>sum</code>，我们要在这些数前加 + 或 -，使得总和为 <code>target</code>。<br>设加正号的那些数之和为 <code>P</code>，加负号的和为 <code>N</code>，则有：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P - N = target  </span><br><span class="line">P + N = sum</span><br></pre></td></tr></table></figure><br>解这个方程组得：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2P = target + sum  </span><br><span class="line">=&gt; P = (target + sum) / 2</span><br></pre></td></tr></table></figure><br>也就是说问题就变成了：<br><strong>从数组中选出若干个数，使得它们的和为 (target + sum) / 2</strong>，求这样的选法有多少种。</p><p><strong>动态规划步骤：</strong><br>1.确定dp数组以及下标的含义<br><code>dp[i]</code>表示使得和为i的选法种数<br>2.确定递推公式<br><code>dp[j] = dp[j] + dp[j - nums[0]];``3.dp数组如何初始化</code>vector<int> dp(weight + 1, 0);<code>` dp[0] = 1;</code><br>4.确定遍历顺序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight; j &gt;= nums[<span class="number">0</span>]; j--) </span><br></pre></td></tr></table></figure></int></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>||<span class="built_in">abs</span>(target)&gt;sum)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> weight = (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(weight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = weight; j &gt;= nums[i]; j--) {</span><br><span class="line">               dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[weight];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode-474-一和零"><a href="#LeetCode-474-一和零" class="headerlink" title="LeetCode 474. 一和零"></a>LeetCode 474. 一和零</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code>。<br>请你找出并返回 <strong>strs 的最大子集的大小</strong>，其中 <strong>最多有 <code>m</code> 个 0 和 <code>n</code> 个 1</strong>。<br>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的子集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3  </span><br><span class="line">输出：4  </span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"}，它们的大小是 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = ["10", "0", "1"], m = 1, n = 1  </span><br><span class="line">输出：2  </span><br><span class="line">解释：最多可选 {"0", "1"}</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为01背包问题：</strong></p><ul><li>背包容量是：<code>m</code> 个 0 和 <code>n</code> 个 1</li><li>物品是：每个字符串，它的“重量”是包含的 0 和 1 的个数</li><li>“价值”是：选择这个字符串后的子集大小</li></ul><p><strong>动态规划步骤：</strong><br>1.确定dp数组（dp table）以及下标的含义<br><code>Dp[i][j]</code>表示最多由<code>i</code>个0和<code>j</code>个1时最大子集的长度。<br>2.确定递推公式<br><code>Dp[i][j]=max(dp[i][j],Dp[i-m0][j-m1]+1);</code><br>3.dp数组如何初始化<br><code>vector&lt;int&gt; dp(m+1,vector&lt;int&gt;(n+1,0));</code><br>4.确定遍历顺序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;strs.<span class="built_in">size</span>();k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=m0;i++;)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=m1;j++)</span><br></pre></td></tr></table></figure></p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">strs01</span>(strs.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; strs[i].<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (strs[i][j] == <span class="string">'0'</span>)strs01[i][<span class="number">0</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (strs[i][j] == <span class="string">'1'</span>)strs01[i][<span class="number">1</span>]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; strs.<span class="built_in">size</span>(); k++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= strs01[k][<span class="number">0</span>]; i--) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= strs01[k][<span class="number">1</span>]; j--) {</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - strs01[k][<span class="number">0</span>]][j - strs01[k][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><h4 id="1-确定-dp-数组含义"><a href="#1-确定-dp-数组含义" class="headerlink" title="1. 确定 dp 数组含义"></a>1. 确定 <code>dp</code> 数组含义</h4><ul><li>定义一个一维或二维 <code>dp</code> 数组。</li><li>下标 <code>dp[i]</code> 表示容量为 <code>i</code> 时，背包能达到的最大值、最小值、组合数或可行性等状态。<ul><li><strong>Leetcode 416. 分割等和子集</strong>：<code>dp[i]</code> 表示是否能通过某些物品的组合，恰好凑成重量为 <code>i</code> 的背包。</li><li><strong>Leetcode 1049. 最后一块石头的重量 II</strong>：<code>dp[j]</code>表示容量为 <code>j</code> 的背包最多能装多少重量的石头</li><li><strong>Leetcode 494. 目标和</strong>：<code>dp[i]</code> 表示能够通过某些数值组合，达到 <code>i</code> 这个目标和的情况数。</li><li><strong>Leetcode 474. 一和零</strong>：<code>dp[i][j]</code> 表示能够使用 <code>i</code> 个零和 <code>j</code> 个一组成某个目标的子集数量。</li></ul></li></ul><h4 id="2-确定递推公式"><a href="#2-确定递推公式" class="headerlink" title="2. 确定递推公式"></a>2. 确定递推公式</h4><ul><li><strong>0-1背包</strong>的核心特征是：<strong>每个物品只能选择一次</strong>。</li><li>递推公式常见形式：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);  <span class="comment">// 求最大值</span></span><br><span class="line">dp[j] = <span class="built_in">min</span>(dp[j], dp[j - weight[i]] + value[i]);  <span class="comment">// 求最小值</span></span><br><span class="line">dp[j] = dp[j] + dp[j - weight[i]];  <span class="comment">// 求组合数/方案数</span></span><br><span class="line">dp[j] = <span class="literal">true</span> <span class="keyword">if</span> dp[j - weight[i]];  <span class="comment">// 判断可行性</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h4><p>根据问题类型，初始化方式有所不同：</p><div class="table-container"><table><thead><tr><th>问题类型</th><th>初始化方式</th></tr></thead><tbody><tr><td>求最小值</td><td><code>dp[0] = 0</code>, 其他为 <code>INT_MAX</code></td></tr><tr><td>求最大值</td><td><code>dp[0] = 0</code>, 其他为 <code>INT_MIN</code></td></tr><tr><td>判断可行性</td><td><code>dp[0] = true</code>, 其他为 <code>false</code></td></tr><tr><td>求方案数</td><td><code>dp[0] = 1</code>, 其他为 <code>0</code></td></tr></tbody></table></div><h4 id="4-遍历顺序"><a href="#4-遍历顺序" class="headerlink" title="4. 遍历顺序"></a>4. 遍历顺序</h4><ul><li><strong>物品在外层，容量在内层</strong>：从后往前遍历，避免重复计算。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = capacity; j &gt;= weight[i]; j--) {</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>有<code>N</code>件物品和一个最多能背重量为<code>W</code>的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><h3 id="求解思路-1"><a href="#求解思路-1" class="headerlink" title="求解思路"></a>求解思路</h3><h4 id="二维数组-1"><a href="#二维数组-1" class="headerlink" title="二维数组"></a>二维数组</h4><p><strong>1.确定dp数组以及下标的含义</strong><br><code>dp[i][j]</code>表示从下标为<code>[0-i]</code>的物品，每个物品可以取无限次，放进容量为<code>j</code>的背包，价值总和最大是多少。</p><p><strong>2.确定递推公式</strong><br>对于物体<code>i</code>只有两种情况</p><ul><li>不放物品<code>i</code>：背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值是<code>dp[i - 1][j]</code>。</li><li>放物品<code>i</code>：背包空出物品<code>i</code>的容量后，背包容量为<code>j - weight[i]</code>，<code>dp[i][j - weight[i]]</code>为背包容量为<code>j - weight[i]</code>且不放物品i的最大价值，那么<code>dp[i][j - weight[i]] + value[i]</code>，就是背包放物品i得到的最大价值。<br>递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);</code><br>也可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></li></ul><p>==注意：01背包中是 <code>dp[i - 1][j - weight[i]] + value[i])</code>==</p><p><strong>3.dp数组如何初始化</strong><br>对于<code>i</code>：<br>    不需要考虑<br>对于<code>j</code>：<br>    如果背包容量j为0的话，即<code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) {</span><br><span class="line">    dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>]; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p><strong>4.确定遍历顺序</strong><br> 先遍历物品再遍历背包：<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>先遍历背包再遍历物品：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h4 id="一维数组-1"><a href="#一维数组-1" class="headerlink" title="一维数组"></a>一维数组</h4><p><strong>1.确定dp数组以及下标的含义</strong><br><code>dp[j]</code>表示：容量为<code>j</code>的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><strong>2.确定递推公式</strong><br>对于物体<code>i</code>只有两种情况</p><ul><li>不放物品<code>i</code>：背包容量为<code>j</code>，里面不放物品<code>i</code>的最大价值是<code>dp[j]</code>。</li><li>放物品<code>i</code>：背包空出物品<code>i</code>的容量后，背包容量为<code>j - weight[i]</code>，<code>dp[j - weight[i]]</code>为背包容量为<code>j - weight[i]</code>且不放物品i的最大价值，那么<code>dp[j - weight[i]] + value[i]</code>，就是背包放物品i得到的最大价值。<br>递归公式： <code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></li></ul><p><strong>3.dp数组如何初始化</strong><br>对于<code>j</code>：<br>    如果背包容量j为0的话，即<code>dp[0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p><p>故初始化代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p><strong>4.确定遍历顺序</strong><br>先遍历背包再遍历物品：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>先遍历物品再遍历背包：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) { <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) { <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>注：<br>对于纯完全背包问题，其for循环的先后循环是可以颠倒的！<br>但如果题目稍稍有点变化，就会体现在遍历顺序上。<br>如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。</p><h2 id="LeetCode题目-1"><a href="#LeetCode题目-1" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h2><h3 id="LeetCode518-零钱兑换II"><a href="#LeetCode518-零钱兑换II" class="headerlink" title="LeetCode518.零钱兑换II"></a>LeetCode518.零钱兑换II</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。<br>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。<br>假设每一种面额的硬币有无限个。<br>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure></p><p><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: amount = 3, coins = [2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为完全背包问题：</strong></p><ul><li>每种硬币数量无限，目标是找到组合数，使它们的和恰好等于 <code>amount</code>。</li><li>硬币顺序不同视为同一种组合<br>所以本质上是完全背包问题（物品：硬币，容量：目标金额）。</li><li>这里和完全背包不同的是，这道题求的是方案数，而完全背包问题求得是最大价值。</li><li>==对于完全背包问题，物品顺序没有影响，所以遍历顺序也没有影响。==</li><li>==对于这道题，因为求的是方案数，所以遍历顺序有影响。</li><li>==因为硬币顺序不同是同一组合，此时只能先遍历物品再遍历容量。==</li></ul><p><strong>动态规划解题步骤：</strong><br>1.确定 <code>dp</code> 数组及含义<br><code>dp[j]</code> 表示：  凑出金额 j 所有组合的方案数。<br>2.确定递推公式<br>对于每一个硬币 <code>coin</code>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[j] = dp[j] + dp[j - coin]</span><br></pre></td></tr></table></figure><br>含义：</p><ul><li>如果不选 <code>coin</code>，方案数是 <code>dp[j]</code>（原来的）。</li><li>如果选 <code>coin</code>，剩下的金额是 <code>j - coin</code>，方案数是 <code>dp[j - coin]</code>。<br>3.dp数组如何初始化<br>必须初始化：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>意思是：金额为 <code>0</code> 时，不选任何硬币也算一种组合。<br>其他：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>表示还未计算。<br>4.确定遍历顺序</li><li>外层：遍历每一个硬币（保证组合顺序不重复，避免算重）。</li><li>内层：遍历每一个金额 <code>j</code>，从小到大更新（因为完全背包，允许硬币重复选）。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) </span><br></pre></td></tr></table></figure></li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>{</span><br><span class="line">        <span class="comment">//防溢出</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode377-组合总和IV"><a href="#LeetCode377-组合总和IV" class="headerlink" title="LeetCode377.组合总和IV"></a>LeetCode377.组合总和IV</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 2, 3], target = 4  </span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">所有可行的组合有：</span><br><span class="line">(1, 1, 1, 1)  </span><br><span class="line">(1, 1, 2)  </span><br><span class="line">(1, 2, 1)  </span><br><span class="line">(1, 3)  </span><br><span class="line">(2, 1, 1)  </span><br><span class="line">(2, 2)  </span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><br><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9], target = 3  </span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">解释：  </span><br><span class="line">9 &gt; 3，无法组成 target = 3，结果为0。</span><br></pre></td></tr></table></figure><br><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素互不相同。</li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为完全背包问题：</strong></p><ul><li>每个数字可以重复使用，目标是找到组合数，使它们的和恰好等于 <code>target</code>。</li><li>数字顺序不同视为不同组合（重要）。<br>所以本质上是<strong>完全背包问题</strong>（物品：数字，容量：<code>target</code>）。</li><li>这里和完全背包不同的是，这道题求的是最少的硬币个数，而完全背包问题求得是最大价值。</li><li>对于完全背包问题，物品顺序没有影响，所以遍历顺序也没有影响。</li><li>==对于这道题，因为求的是方案数，所以遍历顺序有影响。</li><li>==因为数字顺序不同是不同组合，此时只能先遍历容量再遍历物品。==</li></ul><p><strong>动态规划解题步骤：</strong><br>1.确定 <code>dp</code> 数组及含义<br><code>dp[j]</code> 表示：  凑成总和<code>j</code>的排列组合个数。<br>2.确定递推公式<br>对于每个目标总和 <code>j</code>，遍历 <code>nums</code> 中每一个数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[j] = dp[j] + dp[j - nums[i]]</span><br></pre></td></tr></table></figure><br>含义：</p><ul><li>如果不选 <code>nums[i]</code>，方案数是 <code>dp[j]</code>（原来的）。</li><li>如果选 <code>nums[i]</code>，剩下的是 <code>j - nums[i]</code>，方案数是 <code>dp[j - coin]</code>。<br>3.dp数组如何初始化<br>必须初始化：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>意思是：什么都不选，只有一种组合。<br>其他：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>表示还未计算。<br>4.确定遍历顺序</li><li><ul><li>外层遍历<strong>容量 <code>j</code></strong>，从 <code>0</code> 到 <code>target</code>；</li></ul></li><li>内层遍历<strong>物品 <code>num</code></strong>，考虑每个可用的数字。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums[i]) {</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= target; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i])dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode322-零钱兑换"><a href="#LeetCode322-零钱兑换" class="headerlink" title="LeetCode322.零钱兑换"></a>LeetCode322.零钱兑换</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。<br>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。<br>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3</span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><br><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><br><strong>示例 3：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><br><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为完全背包问题：</strong></p><ul><li>每个银币可以重复使用，目标是找到最少的硬币个数，使它们的和恰好等于 <code>amount</code>。</li><li>物品顺序没有影响<br>所以本质上是<strong>完全背包问题</strong>（物品：硬币，容量：目标金额）。</li><li>这里和完全背包不同的是，这道题求的是最少的硬币个数，而完全背包问题求得是最大价值。</li><li>对于完全背包问题，物品顺序没有影响，所以遍历顺序也没有影响。</li><li>==对于这道题，因为求的是最少的硬币个数，所以遍历顺序没有影响。==</li></ul><p><strong>动态规划解题步骤：</strong><br>1.确定 <code>dp</code> 数组及含义<br><code>dp[j]</code> 表示：  组成金额 <code>j</code> 所需的<strong>最少硬币数</strong>。<br>2.确定递推公式<br>对于每一个硬币 <code>coins[i]</code>，可以选择用或不用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>3.dp数组如何初始化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为是求最小值，先把 dp数组全初始化为一个最大值，表示尚未计算</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="comment">//凑出金额0，硬币数量为0</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>4.确定遍历顺序<br>都可以：</p><ul><li>外层遍历每个硬币，内层遍历从小到大遍历金额。</li><li>内层遍历每个硬币，外层遍历从小到大遍历金额。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {   <span class="comment">// 遍历物品（硬币）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) {  <span class="comment">// 遍历背包容量</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) {</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == amount + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode279-完全平方数"><a href="#LeetCode279-完全平方数" class="headerlink" title="LeetCode279.完全平方数"></a>LeetCode279.完全平方数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 <code>n</code> ，返回 _和为 <code>n</code> 的完全平方数的最少数量_ 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p>示例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为完全背包问题：</strong></p><ul><li>每个数字1², 2², 3², 4²,…，可以重复使用，目标是最少数量的完全平方数，组成总和为 <code>n</code>。</li><li>物品顺序没有影响<br>所以本质上是<strong>完全背包问题</strong>（物品：数字，容量：n）。</li><li>这里和完全背包不同的是，这道题求的是最少数量，而完全背包问题求得是最大价值。</li><li>对于完全背包问题，物品顺序没有影响，所以遍历顺序也没有影响。</li><li>==对于这道题，因为求的是最少的数量，所以遍历顺序没有影响。==</li></ul><p><strong>动态规划解题步骤：</strong><br>1.确定 <code>dp</code> 数组及含义<br><code>dp[j]</code> 表示：  和为 <code>j</code> 时，最少需要多少个完全平方数<br>2.确定递推公式<br>对于每一个完全平方数 <code>i*i</code>，可以选择放或不放：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i*i] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>3.dp数组如何初始化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为是求最小值，先把 dp数组全初始化为一个最大值，表示尚未计算</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="comment">//和为0，不需要任何数</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>4.确定遍历顺序<br>都可以：</p><ul><li>外层遍历每个数字，内层遍历从小到大遍历容量。</li><li>内层遍历每个容量，外层遍历从小到大遍历数字。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) {        <span class="comment">// 遍历物品，完全平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j++) {    <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j++) {</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="LeetCode139-单词拆分"><a href="#LeetCode139-单词拆分" class="headerlink" title="LeetCode139.单词拆分"></a>LeetCode139.单词拆分</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例1：<br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：s = "leetcode", wordDict = ["leet", "code"]</span><br><span class="line">输出：true</span><br><span class="line">解释：返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。</span><br></pre></td></tr></table></figure><br>示例2：<br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: s = "applepenapple", wordDict = ["apple", "pen"]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><br>示例3：<br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p><strong>转化为完全背包问题：</strong></p><ul><li>给定一个字符串 s（背包容量），字典单词 wordDict（物品集合，每个单词可以重复使用），判断是否能拼成 s。</li><li>数值顺序不同视为相同同组合（重要）。<br>所以本质上是<strong>完全背包问题</strong>（物品：单词，容量：<code>s</code>）。</li><li>这里和完全背包不同的是，这道题求的是能否组成，而完全背包问题求得是最大价值。</li><li>对于完全背包问题，物品顺序没有影响，所以遍历顺序也没有影响。</li><li>==对于这道题，因为求的是能否组成，所以遍历顺序没有影响。==</li></ul><p><strong>动态规划解题步骤：</strong><br>1.确定 <code>dp</code> 数组及含义<br><code>dp[i]</code>：表示 <code>s[0, i-1]</code>（前i个字符）能否由字典中的单词拼接而成。<br><code>dp[i] = true</code>，表示可以拆分。<code>false</code> 表示不行。<br>2.确定递推公式<br>对于每个 <code>word</code>，如果 <code>s</code> 在位置 <code>i - word.size()</code> 到 <code>i</code> 这个子串等于 <code>word</code>，且 <code>dp[i - word.size()] == true</code>，则说明 <code>dp[i] = true</code>。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dp[i - word.<span class="built_in">size</span>()] &amp;&amp; s.<span class="built_in">substr</span>(i - word.<span class="built_in">size</span>(), word.<span class="built_in">size</span>()) == word) {</span><br><span class="line">    dp[i] = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>3.dp数组如何初始化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>5.确定遍历顺序<br>都可以：</p><ul><li>外层遍历背包容量（从1到<code>s.size()</code>），内层遍历<code>wordDict</code>（推荐）</li><li>内层遍历背包容量（从1到<code>s.size()</code>），外层遍历<code>wordDict</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : wordDict) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= word.<span class="built_in">size</span>() &amp;&amp; dp[i - word.<span class="built_in">size</span>()] &amp;&amp; s.<span class="built_in">substr</span>(i - word.<span class="built_in">size</span>(), word.<span class="built_in">size</span>()) == word) {</span><br><span class="line">            dp[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordDict.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= wordDict[j].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">                    dp[i - wordDict[j].<span class="built_in">size</span>()]</span><br><span class="line">                    &amp;&amp; s.<span class="built_in">substr</span>(i - wordDict[j].<span class="built_in">size</span>(), wordDict[j].<span class="built_in">size</span>()) == wordDict[j]) {</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="题目总结-1"><a href="#题目总结-1" class="headerlink" title="题目总结"></a>题目总结</h3><h4 id="1-确定-dp-数组含义-1"><a href="#1-确定-dp-数组含义-1" class="headerlink" title="1.确定 dp 数组含义"></a>1.确定 <code>dp</code> 数组含义</h4><ul><li>定义一个一维/二维 <code>dp</code> 数组。</li><li>下标 <code>dp[i]</code> 表示 容量为 i 时，背包能达到的最大/最小/可能性等状态。</li><li>示例：<ul><li><strong>Leetcode 518 零钱兑换 II</strong>：<code>dp[i]</code> 表示总金额为 <code>i</code> 时的组合数（不同的顺序视为相同的情况）。</li><li><strong>Leetcode377 组合总和IV：</strong><code>dp[i]</code> 表示总和<code>i</code>的排列个数（不同的顺序视为不同的情况）。</li><li><strong>Leetcode 322 零钱兑换</strong>：<code>dp[i]</code> 表示金额为 <code>i</code> 时所需最少硬币数。</li><li><strong>Leetcode 279 完全平方数：</strong><code>dp[i]</code>: 和为<code>i</code> 所需的最少平方数个数</li><li><strong>Leetcode 139 单词拆分</strong>：<code>dp[i]</code> 表示前 <code>i</code> 个字符能否被字典中的单词拼出。</li></ul></li></ul><h4 id="2-确定递推公式-1"><a href="#2-确定递推公式-1" class="headerlink" title="2.确定递推公式"></a>2.确定递推公式</h4><ul><li><strong>完全背包</strong>的核心特征是：<strong>每个物品可以选多次</strong>。</li><li>所以公式一般形如：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);    <span class="comment">// 求最大值</span></span><br><span class="line">dp[j] = <span class="built_in">min</span>(dp[j], dp[j - weight[i]] + value[i]);    <span class="comment">// 求最小值</span></span><br><span class="line">dp[j] =dp[j] + dp[j - coins[i]];                           <span class="comment">// 求组合数/方案数</span></span><br><span class="line">dp[j] = <span class="literal">true</span> <span class="keyword">if</span> dp[j - word.<span class="built_in">size</span>()] &amp;&amp; s.<span class="built_in">substr</span>(...) <span class="comment">// 判断可行性</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-初始化-1"><a href="#3-初始化-1" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>根据问题不同，初始化有所不同：</p><div class="table-container"><table><thead><tr><th>问题类型</th><th>初始化方式</th></tr></thead><tbody><tr><td>求最小值</td><td><code>dp[0] = 0</code>, 其他为 <code>INT_MAX</code></td></tr><tr><td>求最大值</td><td><code>dp[0] = 0</code>, 其他为 <code>INT_MIN</code></td></tr><tr><td>判断是否可行</td><td><code>dp[0] = true</code>,其他为<code>False</code></td></tr><tr><td>求组合方案数</td><td><code>dp[0] = 1</code>,其他为<code>0</code></td></tr></tbody></table></div><h4 id="4-遍历顺序-1"><a href="#4-遍历顺序-1" class="headerlink" title="4.遍历顺序"></a>4.遍历顺序</h4><ul><li><strong>物品在外层，容量在内层</strong>：适用于求组合数。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) {</span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><strong>容量在外层，物品在内层</strong>：适用于求排列数或状态是否可达。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= coins[i]) dp[j] += dp[j - coins[i]];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode23合并K个升序链表C++</title>
      <link href="/2025/04/10/code/leetcode/LeetCode23%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8C++/"/>
      <url>/2025/04/10/code/leetcode/LeetCode23%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8C++/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>题目描述：</strong><br>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出: [1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [ [] ]</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h3 id="方法-1：逐对合并（分治法）"><a href="#方法-1：逐对合并（分治法）" class="headerlink" title="方法 1：逐对合并（分治法）"></a>方法 1：逐对合并（分治法）</h3><p>分治法的思路是将K个链表分成两部分，递归合并。</p><p><strong>时间复杂度：</strong></p><ul><li>O(N log K)，其中N是所有链表中元素的总数，K是链表的个数。</li><li>每次合并的时间复杂度是O(N)，但分治递归的深度是log K。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归分治合并 K 个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findRes1</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (right == left) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        ListNode* node1 = <span class="built_in">findRes1</span>(lists, left, mid);</span><br><span class="line">        ListNode* node2 = <span class="built_in">findRes1</span>(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findRes2</span>(node1, node2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个已排序链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">findRes2</span><span class="params">(ListNode* node1, ListNode* node2)</span> </span>{</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="literal">NULL</span> &amp;&amp; node2 != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;val &lt; node2-&gt;val) {</span><br><span class="line">                cur-&gt;next = node1;</span><br><span class="line">                node1 = node1-&gt;next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur-&gt;next = node2;</span><br><span class="line">                node2 = node2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node1 != <span class="literal">NULL</span>) cur-&gt;next = node1;</span><br><span class="line">        <span class="keyword">if</span> (node2 != <span class="literal">NULL</span>) cur-&gt;next = node2;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 K 个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findRes1</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="方法-2：最小堆（优先队列）"><a href="#方法-2：最小堆（优先队列）" class="headerlink" title="方法 2：最小堆（优先队列）"></a>方法 2：最小堆（优先队列）</h3><p>利用最小堆来合并所有链表。每次从所有链表中取出当前最小的节点，并将其添加到结果链表中。</p><p><strong>时间复杂度：</strong></p><ul><li>O(N log K)，其中N是所有链表中的节点总数，K是链表的数量。</li><li>堆的操作时间复杂度是log K，每次从堆中取出一个元素，最多会执行N次。<br><strong>代码实现：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">// 小根堆</span></span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Compare&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个链表的头节点加入堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> list : lists) {</span><br><span class="line">            <span class="keyword">if</span> (list) pq.<span class="built_in">push</span>(list);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中取出最小节点，加入结果链表，并将该节点的下一个节点加入堆</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            current-&gt;next = node;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next) {</span><br><span class="line">                pq.<span class="built_in">push</span>(node-&gt;next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法-3：迭代合并（超时）"><a href="#方法-3：迭代合并（超时）" class="headerlink" title="方法 3：迭代合并（超时）"></a>方法 3：迭代合并（超时）</h3><p>通过逐个链表合并，先将第一个和第二个链表合并，再与第三个链表合并，以此类推。</p><p><strong>时间复杂度：</strong></p><ul><li>O(KN)，其中K是链表的个数，N是每个链表的平均长度。</li><li>这个方法每次合并两个链表，时间复杂度是O(N)，但是需要执行K-1次合并。</li></ul><p><strong>代码实现：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* result = lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">            result = <span class="built_in">mergeTwoLists</span>(result, lists[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* current = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) {</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) {</span><br><span class="line">                current-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                current-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1) current-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2) current-&gt;next = l2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> CPP </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode300最长递增子序列C++（两种解法）</title>
      <link href="/2025/04/05/code/leetcode/LeetCode300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97C++%EF%BC%88%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%89/"/>
      <url>/2025/04/05/code/leetcode/LeetCode300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97C++%EF%BC%88%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的某些元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><br><strong>示例 2：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><br> <strong>示例 3：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-10⁴ &lt;= nums[i] &lt;= 10⁴</code></li></ul><p><strong>进阶：</strong></p><p>你能将算法的时间复杂度降低到 O(n log n) 吗？</p><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>这道题的目标是找出一个数组中最长的递增子序列的长度，子序列的意思是可以不连续，只要顺序保持不变。</p><p><strong>动态规划的方法：</strong></p><ol><li>用数组<code>dp</code>，其中 <code>dp[i]</code> 表示以第 <code>i</code> 个数结尾的最长递增子序列的长度。</li><li>初始时，每个位置的 <code>dp[i]</code> 都设为 1，表示最小长度是它自己。</li><li>然后我们遍历数组，对于每个 <code>nums[i]</code>，再往前找所有的 <code>nums[j]（j &lt; i）</code>，如果 <code>nums[j]</code> 小于 <code>nums[i]</code>，就说明 <code>nums[i]</code> 可以接在 <code>nums[j]</code> 的后面，这时候就可以更新 <code>dp[i] = max(dp[i], dp[j] + 1)</code>。</li><li>最终，我们从 dp 数组中找出最大的值，就是整个数组的最长递增子序列的长度。</li></ol><p><strong>时间复杂度：</strong><br>时间复杂度是 O(n²)，因为有两层循环。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) {</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p><h2 id="解法二：贪心-二分查找"><a href="#解法二：贪心-二分查找" class="headerlink" title="解法二：贪心 + 二分查找"></a>解法二：贪心 + 二分查找</h2><p><strong>解法：</strong><br>可以使用 <strong>贪心 + 二分查找</strong> 来实现，将问题转换为：</p><ul><li>我们维护一个数组 <code>sub</code>，<code>sub[i]</code> 表示长度为 <code>i+1</code> 的递增子序列结尾的最小元素；</li><li>对于每个数字 <code>num</code>，我们使用 <strong>二分查找</strong> 找到 <code>sub</code> 中第一个 ≥ <code>num</code> 的位置：<ul><li>如果找不到，说明 <code>num</code> 比所有元素都大，直接 <code>push_back</code>；</li><li>如果找到了，就替换掉原位置的值，让结尾更小，以便构造更优的子序列。<br><strong>时间复杂度：</strong></li></ul></li><li>每个元素最多执行一次二分查找：<strong>O(log n)</strong></li><li>总共 <code>n</code> 个元素：<strong>O(n log n)</strong><br><strong>示例：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10, 9, 2, 5, 3, 7, 101, 18]</span><br><span class="line">过程如下：</span><br><span class="line">1. 初始：tail = []</span><br><span class="line">2. num=10，tail为空，加入：tail = [10]</span><br><span class="line">3. num=9，小于10，用9替换10：tail = [9]</span><br><span class="line">4. num=2，小于9，用2替换9：tail = [2]</span><br><span class="line">5. num=5，大于2，加入：tail = [2,5]</span><br><span class="line">6. num=3，替换5：tail = [2,3]</span><br><span class="line">7. num=7，加入：tail = [2,3,7]</span><br><span class="line">8. num=101，加入：tail = [2,3,7,101]</span><br><span class="line">9. num=18，替换101：tail = [2,3,7,18]</span><br><span class="line">最终 tail 的长度是 4，表示最长递增子序列的长度是 4。</span><br></pre></td></tr></table></figure></li></ul><p><strong>代码：</strong><br>二分查找部分类似LeetCode35搜索插入位置<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sub;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = sub.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (sub[mid] &lt; nums[i]) {</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (left == sub.<span class="built_in">size</span>()) {</span><br><span class="line">                sub.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                sub[left] = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sub.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode使用服务器</title>
      <link href="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、连接服务器"><a href="#一、连接服务器" class="headerlink" title="一、连接服务器"></a>一、连接服务器</h2><blockquote><p>[!NOTE] 注意<br>不知道那一步让你选择Linux、Windows与Macos。<br>这里让你选择的是你要连接的远程服务器的操作系统类型，一般选Linux就行。</p></blockquote><p><strong>1）安装Remote-SSH插件</strong><br>搜索后安装就行<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/1743757113443.png" alt></p><p><strong>2）添加服务器连接配置</strong><br>安装完成之后会在左侧新增一个选项卡：远程资源管理器。<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/1743757204449.png" alt><br>然后点击SSH旁边的+号，输入远程服务器的地址，账号和ip根据实际情况进行修改。<br>格式如<code>ssh 用户名@服务器IP -p 端口号</code><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404170332289.png" alt><br>然后回车，保存刚刚输入的信息到配置文件<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404170441631.png" alt></p><p><strong>3）连接服务器</strong><br>选哪个都行<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/1743758490643.png" alt><br>然后输入密码。<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404171219102.png" alt><br>最后出现下面的界面就成功了<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404171309389.png" alt></p><h2 id="二、断开服务器"><a href="#二、断开服务器" class="headerlink" title="二、断开服务器"></a>二、断开服务器</h2><p>点击下方的服务器，然后点击<code>关闭远程连接</code><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404174652458.png" alt></p><h2 id="三、使用服务器"><a href="#三、使用服务器" class="headerlink" title="三、使用服务器"></a>三、使用服务器</h2><h3 id="1-打开终端用于操作服务器"><a href="#1-打开终端用于操作服务器" class="headerlink" title="1.打开终端用于操作服务器"></a>1.打开终端用于操作服务器</h3><p>如果下面没有显示终端，可以按如下操作打开。<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404171521232.png" alt></p><h3 id="2-下载服务器的代码"><a href="#2-下载服务器的代码" class="headerlink" title="2.下载服务器的代码"></a>2.下载服务器的代码</h3><p><strong>1）更推荐直接选择打开文件夹（也可以在终端输入命令）</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404172044294.png" alt><br><strong>2）选择对应文件后点击确定，这里会需要输入密码</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/1743758581597.png" alt><strong>3）选择对应的文件下载即可</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404172522696.png" alt><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404172459335.png" alt></p><h3 id="3-在服务器创建文件"><a href="#3-在服务器创建文件" class="headerlink" title="3.在服务器创建文件"></a>3.在服务器创建文件</h3><p><strong>1）在合适的文件创建文件或者文件夹</strong><br>如下，使用合适的指令</p><ul><li><strong><code>ls</code></strong>：列出当前目录下的文件和文件夹。</li><li><strong><code>cd</code></strong>：切换目录，比如 <code>cd ..</code> 退回上一级。</li><li><strong><code>mkdir</code></strong>：创建新文件夹，比如 <code>mkdir new_folder</code>。</li><li><strong><code>touch</code></strong>：创建空文件，比如 <code>touch file.txt</code>。<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404173125016.png" alt></li></ul><p><strong>2）打开指定的文件夹</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404172044294.png" alt></p><p><strong>3）编写代码</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404173425301.png" alt></p><h3 id="4-运行代码"><a href="#4-运行代码" class="headerlink" title="4.运行代码"></a>4.运行代码</h3><p><strong>1）编写代码</strong><br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404174128003.png" alt></p><p><strong>2）在终端输入指令运行代码</strong><br><strong>编译 C++ 代码</strong><br><code>g++ hello.cpp -o hello</code></p><ul><li><code>g++</code> 是 C++ 编译器，<code>hello.cpp</code> 是源代码文件，<code>-o hello</code> 指定编译后的可执行文件名为 <code>hello</code>。<br><code>./hello_world</code></li><li>运行可执行文件<br><img src="/2025/04/04/others/VSCode%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/file-20250404174231936.png" alt></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> VSCode </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo解决图片加载失败问题以及Obsidian管理博客</title>
      <link href="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="（一）问题"><a href="#（一）问题" class="headerlink" title="（一）问题"></a>（一）问题</h2><p><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402124859204.png"><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402124859204.png" alt><br>如上，出现图片加载不出来等问题</p><h2 id="（二）解决方法"><a href="#（二）解决方法" class="headerlink" title="（二）解决方法"></a>（二）解决方法</h2><p><strong>1）图片存放方式</strong><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402125028567.png" alt><br>图片要放在与博客名同名的文件夹中</p><p><strong>2）图片使用方式</strong><br>采用<code>![替代文本](图片路径)</code>方式使用图片</p><ul><li>替代文本：当图片无法加载时，会显示这个文本，方便读者理解图片内容，也对无障碍阅读有帮助。</li><li>图片路径：本地文件路径或网络 URL。<br>示例：<code>![](file-20250402125028567.png)</code></li></ul><p><strong>3）更改_config.yml文件</strong><br>找到<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: false</span><br></pre></td></tr></table></figure><br>替换成<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><br><code>post_asset_folder: true</code>开启文章资源文件夹（Post Asset Folder） 功能，这样每篇文章就可以有独立的资源目录。<br><code>marked.prependRoot: true</code>是解析 Markdown 时，自动加上站点根目录。<br><code>postAsset: true</code>让 Markdown 正确加载文章资源文件夹的内容。</p><p><strong>4）安装 <code>hexo-asset-image</code> 插件</strong><br>使用下面的指令安装<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image</span><br></pre></td></tr></table></figure><br>更改<code>/node_modules/hexo-asset-image/index.js</code> 这个文件，将它的内容替换为下面内容</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">'use strict';</span><br><span class="line">var cheerio = require('cheerio');</span><br><span class="line">     </span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) {</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">}</span><br><span class="line">     </span><br><span class="line">var version = String(hexo.version).split('.');</span><br><span class="line">hexo.extend.filter.register('after_post_render', function(data){</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder){</span><br><span class="line">       var link = data.permalink;</span><br><span class="line">   if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">      var beginPos = getPosition(link, '/', 1) + 1;</span><br><span class="line">   else</span><br><span class="line">      var beginPos = getPosition(link, '/', 3) + 1;</span><br><span class="line">   // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><br><span class="line">   var endPos = link.lastIndexOf('/') + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line">     </span><br><span class="line">    var toprocess = ['excerpt', 'more', 'content'];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++){</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line">      </span><br><span class="line">      var $ = cheerio.load(data[key], {</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      });</span><br><span class="line">     </span><br><span class="line">      $('img').each(function(){</span><br><span class="line">       if ($(this).attr('src')){</span><br><span class="line">           // For windows style path, we replace '\' to '/'.</span><br><span class="line">           var src = $(this).attr('src').replace('\\', '/');</span><br><span class="line">           if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">              !/^\s*\//.test(src)) {</span><br><span class="line">             // For "about" page, the first part of "src" can't be removed.</span><br><span class="line">             // In addition, to support multi-level local directory.</span><br><span class="line">             var linkArray = link.split('/').filter(function(elem){</span><br><span class="line">               return elem != '';</span><br><span class="line">             });</span><br><span class="line">             var srcArray = src.split('/').filter(function(elem){</span><br><span class="line">               return elem != '' &amp;&amp; elem != '.';</span><br><span class="line">             });</span><br><span class="line">             if(srcArray.length &gt; 1)</span><br><span class="line">               srcArray.shift();</span><br><span class="line">             src = srcArray.join('/');</span><br><span class="line">             $(this).attr('src', config.root + link + src);</span><br><span class="line">             console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src);</span><br><span class="line">           }</span><br><span class="line">       }else{</span><br><span class="line">           console.info&amp;&amp;console.info("no src attr, skipped...");</span><br><span class="line">           console.info&amp;&amp;console.info($(this));</span><br><span class="line">       }</span><br><span class="line">      });</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></table></figure><p>如果依然不成功，可能是图片文件名问题</p><h2 id="（三）Obsidian管理博客"><a href="#（三）Obsidian管理博客" class="headerlink" title="（三）Obsidian管理博客"></a>（三）Obsidian管理博客</h2><h4 id="1）打开博客文件的source文件夹"><a href="#1）打开博客文件的source文件夹" class="headerlink" title="1）打开博客文件的source文件夹"></a><strong>1）打开博客文件的source文件夹</strong></h4><p><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402130732068.png" alt><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402130735873.png" alt></p><h4 id="2）新建一个-drafts文件夹"><a href="#2）新建一个-drafts文件夹" class="headerlink" title="2）新建一个_drafts文件夹"></a><strong>2）新建一个_drafts文件夹</strong></h4><p>新建一个_drafts文件夹，为新Post存放位置。<br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402130858891.png" alt><br>然后<code>文件与链接-&gt;存放新建笔记的文件夹-&gt;_drafts</code>，将_drafts设为新Post存放位置。<br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402131130797.png" alt></p><h4 id="3）使用-Obsidian-模板快速创建文章"><a href="#3）使用-Obsidian-模板快速创建文章" class="headerlink" title="3）使用 Obsidian 模板快速创建文章"></a><strong>3）使用 Obsidian 模板快速创建文章</strong></h4><p><strong>1.在 <code>source</code> 目录下创建 <code>_obsidian</code> 文件夹，并创建一篇 <code>Post Template</code> 的文章（md文件），内容为：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: {{title}}</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">date: {{date}}</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br><strong>2.然后进入<code>核心插件-&gt;模板</code>，更改设置如下：</strong><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402131535932.png" alt><strong>3.新建文章后，点击侧边栏的<code>插入模板</code>按钮，即可使用模板</strong><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402131652244.png" alt></p><h4 id="4）更改图片设置"><a href="#4）更改图片设置" class="headerlink" title="4）更改图片设置"></a>4）更改图片设置</h4><p><strong>1.Obsidian安装插件<code>Custom Attachment Location</code></strong><br>第一个参数设置为 <code>./${filename}</code><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402132151892.png" alt></p><p><strong>2.在<code>文件与链接</code>中关闭Wiki选项</strong><br><img src="/2025/04/02/others/Hexo%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AObsidian%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2/file-20250402132548652.png" alt></p><p>此时，在博客中复制图片时会自动创建同名文件夹并存放图片。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode31下一个排列C++</title>
      <link href="/2025/03/15/code/leetcode/LeetCode31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97C++/"/>
      <url>/2025/03/15/code/leetcode/LeetCode31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97C++/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h1><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须原地修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong><br><strong>输入：</strong><code>nums = [1,3,4,2,2]</code><br><strong>输出：</strong>2</p><p><strong>示例 2：</strong><br><strong>输入：</strong><code>nums = [3,1,3,4,2]</code><br><strong>输出：</strong>3</p><p><strong>示例 3 :</strong><br><strong>输入：</strong><code>nums = [3,3,3,3,3]</code><br><strong>输出：</strong>3</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a><strong>解法</strong></h1><p><strong>首先，我们来说下一个排列是什么意思：</strong><br>下一个排列 本质上是在 当前排列的基础上寻找比它稍大一点的排列。如果 <code>nums</code> 已经是字典序最大的排列，那么 直接变成最小的排列<br>当前排列：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><br>后面所有可能的排列（按字典序排列）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,2,4,3,5,6← 目标（下一个排列）</span><br><span class="line">1,2,4,3,6,5  </span><br><span class="line">1,2,4,5,3,6</span><br><span class="line">1,2,4,5,6,3</span><br><span class="line">1,2,5,3,4,6</span><br></pre></td></tr></table></figure></p><p><strong>接下来我们看如何解决这道题，分两种情况讨论</strong></p><ol><li>当前的排列是字典序最大的：直接翻转排列，这样就变成了最小的</li><li>当前的排列不是字典序最大的：观察<code>1,2,3,6,5,4-&gt;1,2,3,4,5,6</code>，我们要找到下一个最大的，我们会找到3，因为<code>3&lt;4</code>。然后我们会在<code>6,5,4</code>中找最小的来与3交换，此时变成<code>1,2,4,6,5,3</code>。4后面的肯定要升序摆放，于是就变成<code>1,2,4,3,5,6</code>。所以可以得到步骤：<ol><li>从后向前找“下降点”：找到 <code>nums[i] &lt; nums[i+1]</code> 的 <code>i</code>。</li><li>在 <code>i</code> 右侧找到比 <code>nums[i]</code> 大的最小值，交换两者。</li><li>将 <code>i</code> 右侧的元素翻转，变成最小的排列（升序）。</li></ol></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = n - <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 步骤 1：找到第一个下降点</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) {</span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//步骤2：在i右侧找到比 nums[i] 大的最小元素(注意i右侧一定是降序排布)</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt;= nums[i]) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 步骤 3：将 i 右侧的元素翻转，使其成为最小排列</span></span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode75颜色分类C++</title>
      <link href="/2025/03/15/code/leetcode/LeetCode75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BBC++/"/>
      <url>/2025/03/15/code/leetcode/LeetCode75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BBC++/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h1><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例</strong></p><p><strong>输入:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a><strong>解法</strong></h1><p>使用三个指针：</p><ul><li>index0：0~(index0-1)存放的是0，也就是下一个0要放在index0</li><li>index2：(index2+1)~n-1存放的是2，也就是下一个2要放在index2</li><li>cur：当前遍历的元素位置</li></ul><p>那么有三种情况需要考虑：</p><ul><li><code>nums[cur]</code>为0，将<code>nums[cur]与nums[index0]</code>交换，此时index0要加1。cur也要加1，因为在交换前，index要么等于cur，要么<code>nums[index]</code>为1，对于这两种情况，都需要加1来寻找下一个更新index0与index2的机会。</li><li><code>nums[cur]</code>为1，直接cur+1，因为index0与index2都无法更新。</li><li><code>nums[cur]</code>为2，将<code>nums[cur]与nums[index2]</code>交换，此时index2要减1。不需要将cur加1，因为我们不知道交换器<code>nums[index2]</code>的值是什么情况。</li></ul><p>现在来思考while循环的终止条件：</p><ul><li>两种可能<code>cur&lt;index2</code>或者<code>cur&lt;=index2</code>。因为index2是下一个要放2的位置，所以我们并不知道<code>nums[index2]</code>的值，所以应该选择对index2位置的值进行处理，也就是<code>cur&lt;=index2</code>。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h1><pre><code class="lang-cpp">class Solution {public:    void sortColors(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int index0 = 0, index2 = n - 1, cur = 0;        while (cur &lt;= index2) {            if (nums[cur] == 0) {                swap(nums[cur], nums[index0]);                index0++;                cur++;            }            else if (nums[cur] == 2) {                swap(nums[cur], nums[index2]);                index2--;            }            else cur++;        }    }};</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><ul><li>每个元素最多被交换一次，因此遍历数组的时间复杂度是 <strong>O(n)</strong>，其中 <code>n</code> 是数组的长度。</li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a><strong>空间复杂度</strong></h2><ul><li>只使用了常数额外空间，因此空间复杂度是 <strong>O(1)</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode169多数元素</title>
      <link href="/2025/03/11/code/leetcode/LeetCode169%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0C++/"/>
      <url>/2025/03/11/code/leetcode/LeetCode169%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!NOTE]<br>以下内容包含Chatgpt的帮助</p></blockquote><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，找出其中出现次数超过 <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p> <strong>示例</strong></p><p><strong>示例 1：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p> <strong>进阶要求</strong></p><ul><li>你能在<strong>时间复杂度 O(n)</strong>、<strong>空间复杂度 O(1)</strong> 的条件下完成算法吗？</li></ul><hr><h1 id="解法-1：哈希表（map-计数）"><a href="#解法-1：哈希表（map-计数）" class="headerlink" title="解法 1：哈希表（map 计数）"></a><strong>解法 1：哈希表（map 计数）</strong></h1><p><strong>思路</strong></p><p>我们可以使用哈希表（<code>unordered_map</code>）统计每个元素出现的次数，然后找到出现次数超过 <code>⌊ n/2 ⌋</code> 的元素。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        count[num]++;</span><br><span class="line">        <span class="keyword">if</span> (count[num] &gt; n / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 理论上不会执行到这里，因为题目保证一定有多数元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，遍历数组一次统计出现次数。</li><li><strong>空间复杂度：O(n)</strong>，哈希表存储了最多 <code>n</code> 个不同的数。</li></ul><hr><h1 id="解法-2：排序"><a href="#解法-2：排序" class="headerlink" title="解法 2：排序"></a><strong>解法 2：排序</strong></h1><p><strong>思路</strong></p><ul><li>由于多数元素的出现次数超过 <code>⌊ n/2 ⌋</code>，如果我们对数组进行排序，<strong>中间的元素（索引 <code>n/2</code> 处）一定是多数元素</strong>。</li><li>直接返回 <code>nums[n/2]</code>。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];    <span class="comment">// 中间元素必定是多数元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n log n)</strong>（排序的开销）。</li><li><strong>空间复杂度：O(1)</strong>（原地排序）。</li></ul><hr><h1 id="解法-3：摩尔投票法"><a href="#解法-3：摩尔投票法" class="headerlink" title="解法 3：摩尔投票法"></a><strong>解法 3：摩尔投票法</strong></h1><p> <strong>思路</strong></p><ul><li>由于多数元素出现的次数超过 <code>⌊ n/2 ⌋</code>，如果我们用一个 <code>count</code> 计数器，每次遇到相同的元素就加一，不同的元素就减一：<ul><li><code>count == 0</code> 时，我们假设当前元素是多数元素，并将 <code>count</code> 设为 1。</li><li>继续遍历，最后剩下的 <code>candidate</code> 就是多数元素。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="type">int</span> candidate = nums[<span class="number">0</span>], count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) {</span><br><span class="line">            candidate = num;  <span class="comment">// 假设当前元素是多数元素</span></span><br><span class="line">        }</span><br><span class="line">        count += (num == candidate) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，遍历数组一次即可确定多数元素。</li><li><strong>空间复杂度：O(1)</strong>，只使用了额外的变量 <code>candidate</code> 和 <code>count</code>。</li></ul><h2 id="摩尔投票法的直觉"><a href="#摩尔投票法的直觉" class="headerlink" title="摩尔投票法的直觉"></a><strong>摩尔投票法的直觉</strong></h2><ul><li>假设 <code>x</code> 是多数元素，<code>y</code> 是非多数元素。</li><li><strong>多数元素的数量 &gt; 其他所有元素的总和</strong>，所以最终 <code>x</code> <strong>一定会占据主导地位</strong>。</li></ul><p><strong>数学证明</strong></p><p> 假设多数元素是<code>M</code>，它出现了 <code>k &gt; n/2</code> 次</p><p>假设整个数组长度为 <code>n</code>，其他所有元素的数量是 <code>n - k &lt; k</code>。</p><ol><li><p>最坏情况下，<code>M</code> 与其他元素交错排列</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M, X, M, X, M, X, M, X, M, ...</span><br></pre></td></tr></table></figure><ul><li><p>由于 <code>M</code> 的数量比 <code>X</code> 多，在投票过程中 <code>M</code> 仍然会剩余。</p></li><li><p>假设 <code>X</code> 们全部抵消 <code>M</code>，但 <code>M</code> 仍然有 <code>k - (n - k) = 2k - n</code> 个存活，而 <code>X</code> 被完全抵消。</p></li><li><p>因为 <code>k &gt; n/2</code>，所以 <code>2k - n &gt; 0</code>，即 <code>M</code> 仍然剩下，最终成为 <code>candidate</code>。</p></li></ul></li><li><p>无论 <code>M</code> 如何分布，它都不会被完全抵消</p><ul><li><p>设 <code>M</code> 的出现次数为 <code>x</code>，所有其他元素的出现次数总和为 <code>y</code>。</p></li><li><p>由于 <code>x &gt; y</code>，在遍历的过程中，<code>M</code> 可能会被 <code>y</code> 抵消掉 <code>y</code> 次，但 <code>M</code> 仍然剩余 <code>x - y</code> 次。</p></li><li><p>因此，最终 <code>M</code> 仍然是最多的，且一定会成为 <code>candidate</code>。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
            <tag> 摩尔投票法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode169多数元素C++</title>
      <link href="/2025/03/11/code/leetcode/LeetCode169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0C++/"/>
      <url>/2025/03/11/code/leetcode/LeetCode169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!NOTE]<br>以下内容包含Chatgpt的帮助</p></blockquote><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，找出其中出现次数超过 <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p> <strong>示例</strong></p><p><strong>示例 1：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure><p> <strong>进阶要求</strong></p><ul><li>你能在<strong>时间复杂度 O(n)</strong>、<strong>空间复杂度 O(1)</strong> 的条件下完成算法吗？</li></ul><hr><h1 id="解法-1：哈希表（map-计数）"><a href="#解法-1：哈希表（map-计数）" class="headerlink" title="解法 1：哈希表（map 计数）"></a><strong>解法 1：哈希表（map 计数）</strong></h1><p><strong>思路</strong></p><p>我们可以使用哈希表（<code>unordered_map</code>）统计每个元素出现的次数，然后找到出现次数超过 <code>⌊ n/2 ⌋</code> 的元素。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        count[num]++;</span><br><span class="line">        <span class="keyword">if</span> (count[num] &gt; n / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 理论上不会执行到这里，因为题目保证一定有多数元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，遍历数组一次统计出现次数。</li><li><strong>空间复杂度：O(n)</strong>，哈希表存储了最多 <code>n</code> 个不同的数。</li></ul><hr><h1 id="解法-2：排序"><a href="#解法-2：排序" class="headerlink" title="解法 2：排序"></a><strong>解法 2：排序</strong></h1><p><strong>思路</strong></p><ul><li>由于多数元素的出现次数超过 <code>⌊ n/2 ⌋</code>，如果我们对数组进行排序，<strong>中间的元素（索引 <code>n/2</code> 处）一定是多数元素</strong>。</li><li>直接返回 <code>nums[n/2]</code>。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());  <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];    <span class="comment">// 中间元素必定是多数元素</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n log n)</strong>（排序的开销）。</li><li><strong>空间复杂度：O(1)</strong>（原地排序）。</li></ul><hr><h1 id="解法-3：摩尔投票法"><a href="#解法-3：摩尔投票法" class="headerlink" title="解法 3：摩尔投票法"></a><strong>解法 3：摩尔投票法</strong></h1><p> <strong>思路</strong></p><ul><li>由于多数元素出现的次数超过 <code>⌊ n/2 ⌋</code>，如果我们用一个 <code>count</code> 计数器，每次遇到相同的元素就加一，不同的元素就减一：<ul><li><code>count == 0</code> 时，我们假设当前元素是多数元素，并将 <code>count</code> 设为 1。</li><li>继续遍历，最后剩下的 <code>candidate</code> 就是多数元素。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="type">int</span> candidate = nums[<span class="number">0</span>], count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) {</span><br><span class="line">            candidate = num;  <span class="comment">// 假设当前元素是多数元素</span></span><br><span class="line">        }</span><br><span class="line">        count += (num == candidate) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="built_in">majorityElement</span>(nums) &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><strong>时间复杂度：O(n)</strong>，遍历数组一次即可确定多数元素。</li><li><strong>空间复杂度：O(1)</strong>，只使用了额外的变量 <code>candidate</code> 和 <code>count</code>。</li></ul><h2 id="摩尔投票法的直觉"><a href="#摩尔投票法的直觉" class="headerlink" title="摩尔投票法的直觉"></a><strong>摩尔投票法的直觉</strong></h2><ul><li>假设 <code>x</code> 是多数元素，<code>y</code> 是非多数元素。</li><li><strong>多数元素的数量 &gt; 其他所有元素的总和</strong>，所以最终 <code>x</code> <strong>一定会占据主导地位</strong>。</li></ul><p><strong>数学证明</strong></p><p> 假设多数元素是<code>M</code>，它出现了 <code>k &gt; n/2</code> 次</p><p>假设整个数组长度为 <code>n</code>，其他所有元素的数量是 <code>n - k &lt; k</code>。</p><ol><li>最坏情况下，<code>M</code> 与其他元素交错排列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M, X, M, X, M, X, M, X, M, ...</span><br></pre></td></tr></table></figure><ul><li>由于 <code>M</code> 的数量比 <code>X</code> 多，在投票过程中 <code>M</code> 仍然会剩余。</li><li>假设 <code>X</code> 们全部抵消 <code>M</code>，但 <code>M</code> 仍然有 <code>k - (n - k) = 2k - n</code> 个存活，而 <code>X</code> 被完全抵消。</li><li>因为 <code>k &gt; n/2</code>，所以 <code>2k - n &gt; 0</code>，即 <code>M</code> 仍然剩下，最终成为 <code>candidate</code>。</li></ul></li><li>无论 <code>M</code> 如何分布，它都不会被完全抵消<ul><li>设 <code>M</code> 的出现次数为 <code>x</code>，所有其他元素的出现次数总和为 <code>y</code>。</li><li>由于 <code>x &gt; y</code>，在遍历的过程中，<code>M</code> 可能会被 <code>y</code> 抵消掉 <code>y</code> 次，但 <code>M</code> 仍然剩余 <code>x - y</code> 次。</li><li>因此，最终 <code>M</code> 仍然是最多的，且一定会成为 <code>candidate</code>。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
            <tag> 摩尔投票法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode136只出现一次的数字C++</title>
      <link href="/2025/03/11/code/leetcode/LeetCode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97C++/"/>
      <url>/2025/03/11/code/leetcode/LeetCode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97C++/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!NOTE]<br>以下内容包含Chatgpt的帮助</p></blockquote><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现<strong>一次</strong>以外，其余每个元素均出现<strong>两次</strong>。找出那个只出现了一次的元素。 </p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p> <strong>示例 1：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p> <strong>示例 3：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a><strong>解法</strong></h1><p>题目要求 O(n) 时间复杂度和 O(1) 空间复杂度，我们可以使用 <strong>异或（XOR）运算</strong> 来解决。</p><p> <strong>异或运算性质</strong></p><ol><li><strong><code>a ⊕ a = 0</code></strong>（任何数和自己异或结果为 0）</li><li><strong><code>a ⊕ 0 = a</code></strong>（任何数和 0 异或不变）</li><li><strong><code>a ⊕ b ⊕ c = a ⊕ c ⊕ b</code></strong>（异或运算满足交换律和结合律）</li></ol><p>由于数组中除了一个数出现 <strong>1 次</strong>，其余的数都出现 <strong>2 次</strong>，那么所有数字进行异或运算后：</p><ul><li><strong>成对出现的数会互相抵消变成 0</strong></li><li><strong>最终只剩下那个只出现一次的数</strong></li></ul><hr><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C++ 代码"></a><strong>C++ 代码</strong></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            result ^= num; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><hr><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h2><ul><li><strong>遍历一次数组</strong>，时间复杂度为 <strong>O(n)</strong></li><li><strong>仅用一个整数存储异或结果</strong>，空间复杂度为 <strong>O(1)</strong></li></ul><hr><h1 id="C-运算符知识补充"><a href="#C-运算符知识补充" class="headerlink" title="C++运算符知识补充"></a><strong>C++运算符知识补充</strong></h1><p>在 C++ 中，运算符（Operators）是对变量或值执行操作的符号。常见的运算符包括 <strong>算术运算符、位运算符、逻辑运算符、关系运算符、赋值运算符</strong> 等。</p><div class="table-container"><table><thead><tr><th>类型</th><th>主要运算符</th></tr></thead><tbody><tr><td>算术</td><td><code>+ - * / % ++ --</code></td></tr><tr><td>赋值</td><td><code>= += -= *= /= %=</code></td></tr><tr><td>关系</td><td><code>== != &gt; &lt; &gt;= &lt;=</code></td></tr><tr><td>逻辑</td><td>&amp;&amp; \</td><td>\</td><td>!</td></tr><tr><td>位运算</td><td><code>&amp;</code> \</td><td><code>^ ~ &lt;&lt; &gt;&gt;</code></td></tr><tr><td>杂项运算</td><td><code>? :</code> <code>sizeof</code></td></tr></tbody></table></div><h2 id="1-逻辑运算符（Logical-Operators）"><a href="#1-逻辑运算符（Logical-Operators）" class="headerlink" title="1. 逻辑运算符（Logical Operators）"></a><strong>1. 逻辑运算符（Logical Operators）</strong></h2><p>逻辑运算符通常用于布尔判断：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与（AND）：<strong>两者都为 <code>true</code> 才返回 <code>true</code></strong></td></tr><tr><td>`</td><td></td></tr><tr><td><code>!</code></td><td>逻辑非（NOT）：<strong>取反</strong></td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> a = <span class="literal">true</span>, b = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;  <span class="comment">// 0 (false)</span></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;  <span class="comment">// 1 (true)</span></span><br><span class="line">cout &lt;&lt; (!a) &lt;&lt; endl;      <span class="comment">// 0 (false)</span></span><br></pre></td></tr></table></figure><h2 id="2-位运算符（Bitwise-Operators）"><a href="#2-位运算符（Bitwise-Operators）" class="headerlink" title="2. 位运算符（Bitwise Operators）"></a><strong>2. 位运算符（Bitwise Operators）</strong></h2><p>位运算符用于直接操作<strong>二进制位</strong>：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与（AND）：两个位都为 <code>1</code>，结果才为 <code>1</code></td></tr><tr><td>\</td><td></td><td>按位或（Bitwise OR）：只要有一个位是 <code>1</code>，结果就是 <code>1</code></td></tr><tr><td><code>^</code></td><td>按位异或（XOR）：<strong>相同为 <code>0</code>，不同为 <code>1</code></strong></td></tr><tr><td><code>~</code></td><td>按位取反（NOT）：<strong>所有位取反</strong></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移（Left Shift）：<strong>向左移动 n 位，低位补 0</strong></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移（Right Shift）：<strong>向右移动 n 位，丢弃低位</strong></td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;  <span class="comment">// 5 = 0101, 3 = 0011</span></span><br><span class="line">cout &lt;&lt; (a &amp; b) &lt;&lt; endl;  <span class="comment">// 0001 = 1</span></span><br><span class="line">cout &lt;&lt; (a | b) &lt;&lt; endl;  <span class="comment">// 0111 = 7</span></span><br><span class="line">cout &lt;&lt; (a ^ b) &lt;&lt; endl;  <span class="comment">// 0110 = 6</span></span><br><span class="line">cout &lt;&lt; (~a) &lt;&lt; endl;     <span class="comment">// 取反 (按 32 位计算，~5 = -6)</span></span><br><span class="line">cout &lt;&lt; (a &lt;&lt; <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 1010 = 10  (左移一位)</span></span><br><span class="line">cout &lt;&lt; (a &gt;&gt; <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 0010 = 2   (右移一位)</span></span><br></pre></td></tr></table></figure><h2 id="3-条件（三目）运算符（Ternary-Operator）"><a href="#3-条件（三目）运算符（Ternary-Operator）" class="headerlink" title="3. 条件（三目）运算符（Ternary Operator）"></a><strong>3. 条件（三目）运算符（Ternary Operator）</strong></h2><p>格式：<br><code>(条件) ? (如果为 true 返回) : (如果为 false 返回);</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> minVal = (a &lt; b) ? a : b;</span><br><span class="line">cout &lt;&lt; minVal &lt;&lt; endl;  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++重载运算符</title>
      <link href="/2025/03/10/code/C++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/03/10/code/C++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!NOTE]<br>以下内容为Chatgpt生成后整理</p></blockquote><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h1><h3 id="1-什么是运算符重载？"><a href="#1-什么是运算符重载？" class="headerlink" title="(1)什么是运算符重载？"></a><strong>(1)什么是运算符重载？</strong></h3><p><strong>运算符重载</strong>（Operator Overloading）允许我们为已有的运算符（如 <code>+</code>、<code>-</code>、<code>*</code>、<code>==</code> 等）定义新的行为，以便这些运算符能够处理我们自定义的类型（如类）。换句话说，运算符重载让运算符能够支持自定义类的对象，使得这些对象在运算符使用时像内置数据类型一样工作。</p><h3 id="2-为什么需要运算符重载？"><a href="#2-为什么需要运算符重载？" class="headerlink" title="(2)为什么需要运算符重载？"></a><strong>(2)为什么需要运算符重载？</strong></h3><p>运算符重载能够让我们：</p><ul><li>提高代码的可读性和可维护性。</li><li>让自定义类的对象可以使用常见的运算符，方便直接参与运算。</li></ul><p>例如，考虑两个 <code>Complex</code> 类对象相加，如果没有运算符重载，我们可能需要调用复杂的成员函数来完成加法操作，而运算符重载可以让加法操作变得简洁直观。</p><ul><li><strong>C++ 允许重载的大部分运算符</strong></li><li><strong>不能重载的运算符</strong>：<ul><li><code>::</code>（作用域解析符）</li><li><code>.*</code>（成员指针访问运算符）</li><li><code>.</code>（成员访问运算符）</li><li><code>sizeof</code>（求大小）</li><li><code>typeid</code>（运行时类型识别）</li></ul></li></ul><hr><h1 id="2-重载运算符的方式"><a href="#2-重载运算符的方式" class="headerlink" title="2. 重载运算符的方式"></a><strong>2. 重载运算符的方式</strong></h1><ul><li><strong>作为成员函数</strong>（<code>operator+</code>、<code>operator==</code> 等）</li><li><strong>作为友元函数</strong>（<code>operator&lt;&lt;</code>、<code>operator&gt;&gt;</code> 等）<h3 id="1-作为成员函数"><a href="#1-作为成员函数" class="headerlink" title="(1)作为成员函数"></a>(1)作为成员函数</h3></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    返回类型 <span class="keyword">operator</span> 运算符(参数列表) {</span><br><span class="line">        <span class="comment">// 运算符重载的实现</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">````</span><br><span class="line">### (<span class="number">2</span>)作为非成员函数（友元函数）</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> 类名 {</span><br><span class="line">    <span class="keyword">friend</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表);</span><br><span class="line">};</span><br></pre></td></tr></table></figure><hr><h1 id="3-常见运算符重载示例"><a href="#3-常见运算符重载示例" class="headerlink" title="3. 常见运算符重载示例"></a><strong>3. 常见运算符重载示例</strong></h1><h2 id="1-重载-（加法运算符）"><a href="#1-重载-（加法运算符）" class="headerlink" title="(1) 重载 +（加法运算符）"></a><strong>(1) 重载 <code>+</code>（加法运算符）</strong></h2><p> <strong>1）为什么要重载 <code>+</code>？</strong></p><p>默认情况下，C++ <strong>仅支持内置类型的加法</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> c = a + b; <span class="comment">// ✅ 可以相加</span></span><br></pre></td></tr></table></figure><p>但如果你定义了一个<strong>类</strong>，默认情况下 <strong>对象不能相加</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector v1{<span class="number">1</span>, <span class="number">2</span>}, v2{<span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">    Vector v3 = v1 + v2; <span class="comment">// ❌ 错误，编译失败！</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>原因</strong>：</p><ul><li>C++ <strong>不知道如何相加</strong> <code>v1</code> 和 <code>v2</code>。</li><li>需要 <strong>重载 <code>operator+</code></strong>，告诉 C++ 该怎么加。</li></ul><p><strong>2) <code>operator+</code> 的基本语法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    返回类型 <span class="keyword">operator</span>+(<span class="type">const</span> ClassName&amp; other) <span class="type">const</span> {</span><br><span class="line">        <span class="comment">// 执行加法逻辑</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>📌 <strong>说明</strong>：</p><ul><li><code>operator+</code> <strong>必须是成员函数或友元函数</strong>。</li><li><code>const</code> <strong>保证不会修改原对象</strong>（推荐）。</li><li><code>other</code> <strong>是另一个参与相加的对象</strong>。</li><li><strong>返回新对象</strong>，而不是修改 <code>this</code>。</li></ul><p><strong>3) 示例：为 <code>Vector</code> 类重载 <code>+</code></strong></p><p>假设 <code>Vector</code> 表示二维向量 <code>(x, y)</code>，我们希望：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Vector v3 = v1 + v2; <span class="comment">// 结果 (4,6)</span></span><br></pre></td></tr></table></figure><p>我们可以这样实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `+`</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; other) <span class="type">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + other.x, y + other.y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Vector v3 = v1 + v2; <span class="comment">// ✅ 使用 `+` 运算符</span></span><br><span class="line">    v<span class="number">3.</span><span class="built_in">print</span>(); <span class="comment">// 输出: (4, 6)</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>关键点</strong>：</p><ul><li><code>Vector(int x, int y)</code> <strong>构造函数</strong> 用于创建对象。</li><li><code>operator+</code> <strong>返回一个新的 <code>Vector</code></strong>，表示相加的结果。</li><li><strong>不修改原对象</strong>，保持对象不可变性（<code>const</code>）。</li></ul><p><strong>4) <code>operator+</code> 的其他写法</strong></p><p> （1）使用友元函数</p><p>如果 <code>operator+</code> 需要访问 <code>private</code> 成员，就可以<strong>用友元函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数重载 `+`</span></span><br><span class="line">    <span class="keyword">friend</span> Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; v1, <span class="type">const</span> Vector&amp; v2);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现</span></span><br><span class="line">Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; v1, <span class="type">const</span> Vector&amp; v2) {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(v<span class="number">1.</span>x + v<span class="number">2.</span>x, v<span class="number">1.</span>y + v<span class="number">2.</span>y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Vector v3 = v1 + v2;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">print</span>(); <span class="comment">// 输出: (4, 6)</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>区别</strong>：</p><ul><li>友元函数 <strong>不是类的成员</strong>，但可以访问 <code>private</code> 成员。</li><li>适用于 <strong>操作两个不同类的对象</strong>（如 <code>Matrix + Vector</code>）。</li></ul><p>（2）支持 <code>+=</code> 运算</p><p>为了让 <code>+=</code> 也能使用，我们可以重载 <code>operator+=</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `+` 返回新对象</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; other) <span class="type">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + other.x, y + other.y);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `+=` 直接修改当前对象</span></span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Vector&amp; other) {</span><br><span class="line">        x += other.x;</span><br><span class="line">        y += other.y;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回自身</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    v1 += v2; <span class="comment">// ✅ 使用 `+=`</span></span><br><span class="line">    cout &lt;&lt; v<span class="number">1.</span>x &lt;&lt; <span class="string">", "</span> &lt;&lt; v<span class="number">1.</span>y &lt;&lt; endl; <span class="comment">// 输出: 4, 6</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>区别</strong>：</p><ul><li><code>operator+</code> <strong>返回新对象</strong>，不修改 <code>this</code>。</li><li><code>operator+=</code> <strong>修改当前对象</strong>，返回 <code>*this</code> 以支持 <strong>链式调用</strong>。</li></ul><hr><h2 id="2-重载-（比较运算符）"><a href="#2-重载-（比较运算符）" class="headerlink" title="(2) 重载 ==（比较运算符）"></a><strong>(2) 重载 <code>==</code>（比较运算符）</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `==`</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; other) <span class="type">const</span> {</span><br><span class="line">        <span class="built_in">return</span> (name == other.name &amp;&amp; age == other.age);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">25</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"相等"</span> &lt;&lt; endl;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"不相等"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>注意</strong>：</p><ul><li><code>operator==</code> <strong>必须返回 <code>bool</code></strong>。</li></ul><hr><h2 id="3-重载-lt-lt-（流插入运算符，打印对象）"><a href="#3-重载-lt-lt-（流插入运算符，打印对象）" class="headerlink" title="(3) 重载 <<（流插入运算符，打印对象）"></a><strong>(3) 重载 <code>&lt;&lt;</code>（流插入运算符，打印对象）</strong></h2><p>流插入运算符 <code>&lt;&lt;</code> 不能作为类成员函数 <strong>（因为 <code>cout</code> 在左侧，不属于 <code>Person</code> 类）</strong>，必须定义为<strong>友元函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `&lt;&lt;` 运算符（必须是友元函数）</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Person&amp; p) {</span><br><span class="line">        os &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; p.name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; p.age;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl; <span class="comment">// 自动调用 operator&lt;&lt;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>注意</strong>：</p><ul><li><code>&lt;&lt;</code> <strong>必须返回 <code>ostream&amp;</code>，否则 <code>cout &lt;&lt; p &lt;&lt; "hello";</code> 不能连续输出</strong>。</li></ul><hr><h2 id="4-重载-（索引运算符）"><a href="#4-重载-（索引运算符）" class="headerlink" title="(4) 重载 []（索引运算符）"></a><strong>(4) 重载 <code>[]</code>（索引运算符）</strong></h2><p>如果你希望 <code>obj[i]</code> 访问对象内部数据，可以重载 <code>operator[]</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() { <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) data[i] = i * <span class="number">10</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `[]`</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) {</span><br><span class="line">        <span class="keyword">return</span> data[index]; <span class="comment">// 允许修改</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Array arr;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 输出 20</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">    cout &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// 输出 99</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>注意</strong>：</p><ul><li><code>operator[]</code> 返回 <code>int&amp;</code> <strong>可以修改数组内容</strong>。</li></ul><hr><h2 id="5-重载-（函数调用运算符）"><a href="#5-重载-（函数调用运算符）" class="headerlink" title="(5) 重载 ()（函数调用运算符）"></a><strong>(5) 重载 <code>()</code>（函数调用运算符）</strong></h2><h4 id="1-为什么要重载-？"><a href="#1-为什么要重载-？" class="headerlink" title="1. 为什么要重载 ()？"></a><strong>1. 为什么要重载 <code>()</code>？</strong></h4><p>通常，我们调用函数的方式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 5</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但如果你想创建一个<strong>行为类似函数的对象</strong>，可以<strong>重载 <code>operator()</code></strong>，这样对象本身就能像函数一样使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Adder add;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 5</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里 <code>Adder</code> <strong>是一个对象，但它可以像函数一样调用！</strong></p><h4 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a><strong>2. 基本语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    返回类型 <span class="built_in">operator</span>()(参数列表) {</span><br><span class="line">        <span class="comment">// 函数体</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>operator()</code> 让对象变成 <strong>可调用对象</strong>，类似普通函数。</li><li>可以有 <strong>任意数量的参数</strong>。</li><li>可以有 <strong>返回值</strong>，与普通函数一样。</li></ul><h4 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a><strong>3. 代码示例</strong></h4><p><strong>示例 1：最简单的 <code>()</code> 重载</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multiply</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Multiply multiply;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 输出 12</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>Multiply</code> 类有一个 <code>operator()</code>，执行乘法。</li><li><code>multiply(3, 4)</code> <strong>看起来像函数调用</strong>，但 <code>multiply</code> 实际上是一个对象。</li></ul><p><strong>示例 2：用于 STL <code>std::sort</code> 的比较器</strong></p><p>STL 算法（如 <code>sort</code>）经常使用 <code>operator()</code> 作为<strong>自定义排序规则</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">Compare</span>()); <span class="comment">// 传入一个仿函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出: 9 5 4 3 1 1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>Compare</code> <strong>定义了 <code>operator()</code></strong>，用于比较两个数的大小。</li><li><code>sort</code> <strong>不需要函数指针，而是直接传入 <code>Compare()</code> 对象</strong>。</li></ul><p><strong>示例 3：存储状态的函数对象</strong></p><p>函数对象可以<strong>保存状态</strong>，而普通函数<strong>不能</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">count</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Counter counter;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; endl; <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">counter</span>() &lt;&lt; endl; <span class="comment">// 输出 3</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>Counter</code> 对象<strong>记住了之前的 <code>count</code> 值</strong>，每次调用 <code>()</code> 都会递增 <code>count</code>。</li><li><strong>普通函数不能存储状态</strong>，但<strong>函数对象可以！</strong></li></ul><p><strong>示例 4：多参数版本</strong></p><p><code>operator()</code> 可以有多个参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Power</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>{</span><br><span class="line">        <span class="type">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (exponent--) result *= base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Power power;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">power</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 输出 8</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>Power</code> 计算 <code>base^exponent</code>。</li><li><strong>多个参数</strong> 和普通函数一样！</li></ul><h4 id="4-operator-的高级用法"><a href="#4-operator-的高级用法" class="headerlink" title="4. operator() 的高级用法"></a><strong>4. <code>operator()</code> 的高级用法</strong></h4><p><strong>(1) 作为 Lambda 表达式的替代</strong></p><p><code>operator()</code> <strong>和 Lambda 很像</strong>，它可以代替 Lambda 表达式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaLike</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 仅返回偶数</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">LambdaLike</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出: 2 4 6</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>LambdaLike</code> <strong>像 Lambda 一样</strong>，筛选偶数。</li></ul><p><strong>(2) 在 <code>map</code> 中用作自定义比较器</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseCompare</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 使 `map` 变成降序</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    map&lt;<span class="type">int</span>, string, ReverseCompare&gt; myMap;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">"Three"</span>;</span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">"One"</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">"Two"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) {</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 3: Three</span></span><br><span class="line"><span class="comment">// 2: Two</span></span><br><span class="line"><span class="comment">// 1: One</span></span><br></pre></td></tr></table></figure><p>📌 <strong>理解</strong>：</p><ul><li><code>operator()</code> 让 <code>map</code> <strong>按键降序排序</strong>。</li></ul><h4 id="5-operator-的总结"><a href="#5-operator-的总结" class="headerlink" title="5. operator() 的总结"></a><strong>5. <code>operator()</code> 的总结</strong></h4><div class="table-container"><table><thead><tr><th>作用</th><th>适用场景</th><th>例子</th></tr></thead><tbody><tr><td>让对象像函数一样调用</td><td>计算、操作类</td><td><code>Multiply multiply; multiply(2,3);</code></td></tr><tr><td>作为 STL 自定义规则</td><td><code>sort()</code>、<code>map</code></td><td><code>sort(v.begin(), v.end(), Compare());</code></td></tr><tr><td>代替 Lambda</td><td><code>remove_if</code></td><td><code>nums.erase(remove_if(nums.begin(), nums.end(), LambdaLike()), nums.end());</code></td></tr><tr><td>具有状态的可调用对象</td><td>记忆历史调用</td><td><code>Counter counter; counter();</code></td></tr></tbody></table></div><hr><h2 id="6-重载-gt-（箭头运算符）"><a href="#6-重载-gt-（箭头运算符）" class="headerlink" title="(6) 重载 ->（箭头运算符）"></a><strong>(6) 重载 <code>-&gt;</code>（箭头运算符）</strong></h2><p>如果你的类包含指针对象，可以重载 <code>-&gt;</code> 使其像指针一样访问：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PtrWrapper</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PtrWrapper</span>(<span class="type">int</span> val) { ptr = <span class="keyword">new</span> <span class="built_in">int</span>(val); }</span><br><span class="line">    ~<span class="built_in">PtrWrapper</span>() { <span class="keyword">delete</span> ptr; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `-&gt;`</span></span><br><span class="line">    <span class="type">int</span>* <span class="keyword">operator</span>-&gt;() { <span class="keyword">return</span> ptr; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">PtrWrapper <span class="title">p</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; *(p.<span class="keyword">operator</span>-&gt;()) &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>📌 <strong>注意</strong>：</p><ul><li>适用于 <strong>智能指针</strong>，如 <code>std::unique_ptr&lt;T&gt;</code>。</li></ul><hr><h2 id="7-重载-（赋值运算符）"><a href="#7-重载-（赋值运算符）" class="headerlink" title="(7) 重载 =（赋值运算符）"></a><strong>(7) 重载 <code>=</code>（赋值运算符）</strong></h2><p>必须处理<strong>深拷贝</strong>问题：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) {</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() { <span class="keyword">delete</span>[] data; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 `=`</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>📌 <strong>注意</strong>：</p><ul><li><code>operator=</code> <strong>要检查自赋值，防止内存泄漏</strong>。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><div class="table-container"><table><thead><tr><th>运算符</th><th>作用</th><th>典型应用</th><th>备注</th></tr></thead><tbody><tr><td><code>operator+</code></td><td>加法</td><td><code>a + b</code></td><td>返回新对象</td></tr><tr><td><code>operator-</code></td><td>减法</td><td><code>a - b</code></td><td>返回新对象</td></tr><tr><td><code>operator==</code></td><td>比较</td><td><code>a == b</code></td><td>返回 <code>bool</code></td></tr><tr><td><code>operator&lt;&lt;</code></td><td>输出</td><td><code>cout &lt;&lt; obj</code></td><td>需要友元函数</td></tr><tr><td><code>operator[]</code></td><td>索引</td><td><code>obj[i]</code></td><td>允许修改数据</td></tr><tr><td><code>operator()</code></td><td>函数调用</td><td><code>obj(x, y)</code></td><td>仿函数</td></tr><tr><td><code>operator-&gt;</code></td><td>指针访问</td><td><code>obj-&gt;method()</code></td><td>适用于指针包装类</td></tr><tr><td><code>operator=</code></td><td>赋值</td><td><code>a = b</code></td><td>处理深拷贝</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> C++ </tag>
            
            <tag> 重载 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++自定义排序方式</title>
      <link href="/2025/03/06/code/C++%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/03/06/code/C++%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意<br>以下内容为Chatgpt生成后整理</p></blockquote><p>在 C++ 中，<strong>自定义比较函数</strong>（通常是一个函数或者函数对象）和<strong>仿函数</strong>（函数对象）都可以用于自定义排序规则或比较方式，但它们的实现方式和使用方法有所不同。</p><h3 id="1-自定义比较函数"><a href="#1-自定义比较函数" class="headerlink" title="1. 自定义比较函数"></a><strong>1. 自定义比较函数</strong></h3><p>自定义比较函数是指一个普通的函数，它用于定义如何比较两个对象。通常，这个函数有两个参数，返回值是一个布尔值，表示这两个对象之间的比较结果。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点</strong>：</h4><ul><li><strong>形式</strong>：自定义比较函数通常是一个独立的普通函数。</li><li><strong>使用方式</strong>：它可以作为参数传递给排序算法（如 <code>std::sort</code>）或数据结构（如 <code>std::priority_queue</code>）等，定义对象的排序或比较规则。</li><li><strong>返回类型</strong>：一般返回一个 <code>bool</code> 类型，表示是否满足某种条件（例如：<code>a &lt; b</code>，返回 <code>true</code> 表示 <code>a</code> 小于 <code>b</code>）。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;  <span class="comment">// 按升序排序</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), compare);  <span class="comment">// 使用自定义比较函数排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : v) {</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>compare</code> 函数定义了一个比较规则，<code>std::sort</code> 采用该规则对 <code>vector&lt;int&gt;</code> 进行排序。</p><blockquote><p>注意<br>在 C++ 的排序函数（比如 <code>sort</code>）中，这个 <code>compare</code> 函数的作用是告诉排序算法：当 <code>compare(a, b)</code> 返回 <code>true</code> 时，<code>a</code> 会排在 <code>b</code> 前面。</p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h4><ul><li>简单直接。</li><li>易于理解和使用。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4><ul><li>无法存储状态。如果需要在比较中保存某些信息或行为（如计数、配置等），就不太适合使用普通函数。</li></ul><hr><h3 id="2-仿函数（函数对象）"><a href="#2-仿函数（函数对象）" class="headerlink" title="2. 仿函数（函数对象）"></a><strong>2. 仿函数（函数对象）</strong></h3><p>仿函数是通过重载 <code>operator()</code> 来创建的对象，使得这个对象能够像函数一样被调用。换句话说，仿函数是一种行为类似于函数的类或结构体。它通常用于需要自定义行为且需要存储状态的场景。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a><strong>特点</strong>：</h4><ul><li><strong>形式</strong>：仿函数是一个类或结构体，类中重载了 <code>operator()</code>，使得对象可以像函数一样调用。</li><li><strong>使用方式</strong>：和普通函数一样，仿函数也可以作为参数传递给算法或数据结构，但它可以保存状态（例如：比较次数、特定的配置信息等）。</li><li><strong>返回类型</strong>：和自定义比较函数一样，仿函数通常返回 <code>bool</code> 类型，但它可以执行更加复杂的操作。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义仿函数（函数对象）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;  <span class="comment">// 按升序排序</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用仿函数排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : v) {</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Compare</code> 结构体重载了 <code>operator()</code>，使得它成为一个仿函数。我们在 <code>std::sort</code> 中使用了 <code>Compare()</code>，它会像一个函数一样进行排序。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点</strong>：</h4><ul><li>可以保存状态。仿函数是类，因此可以在类中定义成员变量，保存一些额外的状态信息，提供更强的灵活性。</li><li>可以定义复杂的比较行为，除了简单的比较，还可以使用成员函数、静态变量等。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4><ul><li>相比普通函数，仿函数的实现相对复杂，需要定义一个类或结构体并重载 <code>operator()</code>。</li></ul><hr><h3 id="3-自定义比较函数与仿函数的区别"><a href="#3-自定义比较函数与仿函数的区别" class="headerlink" title="3. 自定义比较函数与仿函数的区别"></a><strong>3. 自定义比较函数与仿函数的区别</strong></h3><div class="table-container"><table><thead><tr><th>特点</th><th>自定义比较函数</th><th>仿函数（函数对象）</th></tr></thead><tbody><tr><td><strong>实现形式</strong></td><td>普通函数</td><td>类或结构体，重载 <code>operator()</code></td></tr><tr><td><strong>使用方式</strong></td><td>作为参数传递给算法或数据结构（如 <code>std::sort</code>）</td><td>作为参数传递给算法或数据结构（如 <code>std::sort</code>）</td></tr><tr><td><strong>存储状态</strong></td><td>无法存储状态</td><td>可以存储状态，通过成员变量保存信息</td></tr><tr><td><strong>灵活性</strong></td><td>较简单，适用于简单的比较</td><td>更灵活，适合需要额外状态或行为的场景</td></tr><tr><td><strong>适用场景</strong></td><td>适合简单的比较和排序场景</td><td>适合需要动态行为或存储状态的复杂场景</td></tr></tbody></table></div><h3 id="4-各个容器和算法支持自定义比较器的区别"><a href="#4-各个容器和算法支持自定义比较器的区别" class="headerlink" title="4.各个容器和算法支持自定义比较器的区别"></a><strong>4.各个容器和算法支持自定义比较器的区别</strong></h3><h4 id="1-std-priority-queue（优先队列）"><a href="#1-std-priority-queue（优先队列）" class="headerlink" title="1. std::priority_queue（优先队列）"></a><strong>1. <code>std::priority_queue</code>（优先队列）</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;T, vector&lt;T&gt;, Compare&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>传入参数</strong>：<code>Compare(a, b)</code> 传入的是 <strong>父节点 <code>a</code>，子节点 <code>b</code></strong>。</li><li><strong>返回值含义</strong>：<ul><li>如果 <code>Compare(a, b) == true</code>，表示 <strong><code>a</code> 的优先级低于 <code>b</code></strong>，因此 <code>a</code> 会排在 <code>b</code> 的下方。</li><li><strong>默认是 <code>std::less&lt;T&gt;</code>（最大堆），要实现小顶堆，用 <code>std::greater&lt;T&gt;</code> 或自定义 <code>Compare</code></strong>。</li></ul></li></ul><p>📌 <strong>示例（小顶堆）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// `a` &gt; `b`，`a` 低优先级</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><code>pq.top()</code> 返回最小的元素。</li><li><strong>最小堆（小顶堆）：堆顶是最小的元素</strong>。</li></ul><h4 id="2-std-sort（排序）"><a href="#2-std-sort（排序）" class="headerlink" title="2. std::sort（排序）"></a><strong>2. <code>std::sort</code>（排序）</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(begin, end, Compare)</span><br></pre></td></tr></table></figure><ul><li><strong>传入参数</strong>：<code>Compare(a, b)</code> 传入的是 <strong>相邻的 <code>a</code> 和 <code>b</code></strong>。</li><li><strong>返回值含义</strong>：<ul><li>如果 <code>Compare(a, b) == true</code>，表示 <strong><code>a</code> 应该排在 <code>b</code> 前面</strong>。</li><li><strong>默认是 <code>std::less&lt;T&gt;</code>（升序），如果 <code>Compare(a, b) == a &gt; b</code>，则是降序排序</strong>。</li></ul></li></ul><p>📌 <strong>示例（降序排序）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// `a` 放前面，降序</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>};</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Compare</span>()); <span class="comment">// 排序后 v = {5, 4, 3, 1, 1}</span></span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><strong>返回 <code>true</code> 代表 <code>a</code> 应该在 <code>b</code> 前面</strong>。</li><li><strong>影响整个排序规则</strong>。</li></ul><h4 id="3-std-set-std-map（有序容器）"><a href="#3-std-set-std-map（有序容器）" class="headerlink" title="3. std::set / std::map（有序容器）"></a><strong>3. <code>std::set</code> / <code>std::map</code>（有序容器）</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;T, Compare&gt;</span><br><span class="line">map&lt;Key, Value, Compare&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>传入参数</strong>：<code>Compare(a, b)</code> 传入的是 <strong>两个元素</strong>（<code>set</code> 的值 或 <code>map</code> 的键）。</li><li><strong>返回值含义</strong>：<ul><li>如果 <code>Compare(a, b) == true</code>，表示 <strong><code>a</code> 应该排在 <code>b</code> 前面</strong>。</li><li><strong>如果 <code>Compare(a, b) == false &amp;&amp; Compare(b, a) == false</code>，说明 <code>a == b</code>，此时 <code>set</code> / <code>map</code> 认为元素已存在，不会插入</strong>。</li><li><strong>默认是 <code>std::less&lt;T&gt;</code>（升序），如果 <code>Compare(a, b) == a &gt; b</code>，则是降序存储</strong>。</li></ul></li></ul><p>📌 <strong>示例（降序 <code>set</code>）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// `a` 放前面，降序存储</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">set&lt;<span class="type">int</span>, Compare&gt; s = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>}; <span class="comment">// 存储后 {5, 4, 3, 1}</span></span><br></pre></td></tr></table></figure><p>📌 <strong>示例（自定义 <code>map</code> 排序）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>(); <span class="comment">// 按字符串长度排序</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">map&lt;string, <span class="type">int</span>, Compare&gt; m;</span><br><span class="line">m[<span class="string">"apple"</span>] = <span class="number">1</span>;</span><br><span class="line">m[<span class="string">"banana"</span>] = <span class="number">2</span>;</span><br><span class="line">m[<span class="string">"kiwi"</span>] = <span class="number">3</span>; <span class="comment">// 按长度排序，`kiwi` 会在 `apple` 前面</span></span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><strong><code>set</code> / <code>map</code> 的顺序由 <code>Compare</code> 控制</strong>。</li><li><strong>必须保证 <code>Compare</code> 是严格弱序（Strict Weak Ordering），否则行为未定义</strong>。</li></ul><h4 id="4-std-multiset-std-multimap（可重复有序容器）"><a href="#4-std-multiset-std-multimap（可重复有序容器）" class="headerlink" title="4. std::multiset / std::multimap（可重复有序容器）"></a><strong>4. <code>std::multiset</code> / <code>std::multimap</code>（可重复有序容器）</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiset&lt;T, Compare&gt;</span><br><span class="line">multimap&lt;Key, Value, Compare&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>规则和 <code>set</code> / <code>map</code> 一样，但允许重复元素</strong>。</li><li><strong>多个相等的元素会按照 <code>Compare</code> 规定的顺序存储</strong>。</li></ul><p>📌 <strong>示例（降序 <code>multiset</code>）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; ms = {<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>};</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><strong>内部按 <code>greater&lt;int&gt;</code> 存储，顺序为 <code>{3, 3, 2, 2, 1}</code></strong>。</li></ul><h4 id="5-std-unordered-set-std-unordered-map"><a href="#5-std-unordered-set-std-unordered-map" class="headerlink" title="5. std::unordered_set / std::unordered_map"></a><strong>5. <code>std::unordered_set</code> / <code>std::unordered_map</code></strong></h4><ul><li><strong><code>unordered_set</code> 和 <code>unordered_map</code> 不能使用 <code>Compare</code>，因为它们使用哈希函数 (<code>hash&lt;T&gt;</code>) 进行存储，而不是比较器。</strong></li><li><strong>但可以自定义 <code>hash</code> 和 <code>operator==</code> 以影响存储方式。</strong></li></ul><p>📌 <strong>示例（自定义哈希）：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyHash</span> {</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; p)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p.first ^ p.second; <span class="comment">// 自定义哈希计算</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">unordered_set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, MyHash&gt; uset;</span><br></pre></td></tr></table></figure><p><strong>行为</strong>：</p><ul><li><strong><code>unordered_set</code> 允许使用自定义 <code>hash</code> 影响存储，但不支持 <code>Compare</code> 影响顺序</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><div class="table-container"><table><thead><tr><th>STL 容器 / 算法</th><th><code>Compare(a, b)</code> 作用</th><th><code>true</code> 的含义</th><th>默认比较器</th></tr></thead><tbody><tr><td><code>priority_queue&lt;T, vector&lt;T&gt;, Compare&gt;</code></td><td>传入 (父节点, 子节点)</td><td><code>a</code> 优先级低于 <code>b</code>（<code>a</code> 在 <code>b</code> 下面）</td><td><code>std::less&lt;T&gt;</code>（大顶堆）</td></tr><tr><td><code>sort(begin, end, Compare)</code></td><td>传入 (左元素, 右元素)</td><td><code>a</code> 在 <code>b</code> 前面</td><td><code>std::less&lt;T&gt;</code>（升序）</td></tr><tr><td><code>set&lt;T, Compare&gt;</code></td><td>传入 (元素1, 元素2)</td><td><code>a</code> 在 <code>b</code> 前面</td><td><code>std::less&lt;T&gt;</code>（升序）</td></tr><tr><td><code>map&lt;Key, Value, Compare&gt;</code></td><td>传入 (键1, 键2)</td><td><code>a</code> 在 <code>b</code> 前面</td><td><code>std::less&lt;T&gt;</code>（升序）</td></tr><tr><td><code>multiset&lt;T, Compare&gt;</code></td><td>传入 (元素1, 元素2)</td><td><code>a</code> 在 <code>b</code> 前面</td><td><code>std::less&lt;T&gt;</code>（升序）</td></tr><tr><td><code>multimap&lt;Key, Value, Compare&gt;</code></td><td>传入 (键1, 键2)</td><td><code>a</code> 在 <code>b</code> 前面</td><td><code>std::less&lt;T&gt;</code>（升序）</td></tr><tr><td><code>unordered_set</code> / <code>unordered_map</code></td><td><strong>不能用 <code>Compare</code></strong>，只能用 <code>hash&lt;T&gt;</code></td><td>-</td><td><code>hash&lt;T&gt;</code></td></tr></tbody></table></div><ol><li><strong><code>priority_queue</code></strong>：<code>true</code> = <strong><code>a</code> 优先级低（更靠下）</strong>。</li><li><strong><code>sort</code></strong> / <strong><code>set</code></strong> / <strong><code>map</code></strong>：<code>true</code> = <strong><code>a</code> 应该在 <code>b</code> 前面</strong>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 代码 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++堆及实现，priority_queue</title>
      <link href="/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!NOTE]<br>以下内容为Chatgpt生成后整理</p></blockquote><p>堆（Heap）是一种特殊的树形数据结构，通常用来实现优先队列、排序算法等功能。堆是一种完全二叉树，它满足特定的顺序性质。我们可以分为最大堆和最小堆两种。</p><h3 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h3><p>堆是一个完全二叉树，其节点满足堆的性质：</p><ul><li><strong>最大堆（Max Heap）</strong>：每个父节点的值大于或等于其子节点的值，即根节点是树中的最大值。</li><li><strong>最小堆（Min Heap）</strong>：每个父节点的值小于或等于其子节点的值，即根节点是树中的最小值。</li></ul><p>堆的特点：</p><ul><li><strong>完全二叉树</strong>：除了最底层外，其他层的节点都是满的，最底层的节点从左到右排列。完全二叉树的结构保证了堆的高效性。</li><li><strong>堆的顺序性质</strong>：堆中任意节点的值与其子节点的值有顺序关系，最大堆的父节点值大于子节点，而最小堆则相反。</li></ul><h3 id="2-堆的基本操作"><a href="#2-堆的基本操作" class="headerlink" title="2. 堆的基本操作"></a>2. 堆的基本操作</h3><p>堆主要支持以下几种基本操作：</p><ol><li><strong>插入元素（Insert）</strong>：<ul><li>在堆的末尾插入一个新元素，并通过“上浮”操作将其放到正确的位置，以保持堆的顺序性质。</li><li>上浮操作：如果新插入的元素比父节点大（最大堆）或小（最小堆），则与父节点交换位置，直到堆顺序性质被恢复。交换不会破环堆得性质，不需要堆化，因为父节点得值大于所有得子节点。</li></ul></li><li><strong>删除根节点（Delete）</strong>：<ul><li>删除堆的根节点，并将堆的最后一个元素放到根位置。然后通过“下沉”操作将其放到正确的位置，以恢复堆的顺序性质。</li><li>下沉操作：将根节点与其子节点中较大的（最大堆）或较小的（最小堆）子节点交换，直到堆顺序性质被恢复。需要使用堆化。</li></ul></li><li><strong>堆化（Heapify）</strong>：<ul><li>堆化是将一个无序数组转换成一个堆结构。它的过程是从数组的最后一个非叶子节点开始，逐步执行“下沉”操作，直到堆顺序性质得到恢复。</li></ul></li><li><strong>获取最大（最小）元素</strong>：<ul><li>在最大堆中，根节点存储着最大元素；在最小堆中，根节点存储着最小元素。这个操作的时间复杂度是O(1)。<h3 id="3-堆的应用"><a href="#3-堆的应用" class="headerlink" title="3. 堆的应用"></a>3. 堆的应用</h3></li></ul></li></ol><p>堆广泛应用于以下场景：</p><ul><li><strong>优先队列</strong>：堆可以用来实现优先队列，保证插入和删除操作都能按照优先级进行。</li><li><p><strong>堆排序（Heap Sort）</strong>：利用堆的性质，可以对元素进行排序。首先将元素插入堆中，然后逐个删除根节点，即得到一个有序序列。</p><h3 id="4-堆的时间复杂度"><a href="#4-堆的时间复杂度" class="headerlink" title="4. 堆的时间复杂度"></a>4. 堆的时间复杂度</h3></li><li><p><strong>插入操作</strong>：O(log n)，插入元素后最多需要上浮h层，所有为O(log n)</p></li><li><strong>删除根节点操作</strong>：O(log n)，删除根节点后需要执行下沉操作，也需要log(n)次比较和交换。</li><li><strong>堆化操作</strong>：O(n)，从最后一个非叶子节点开始执行下沉操作，整体的时间复杂度是O(n)。</li></ul><blockquote><p>[!NOTE] 堆得高度为什么是O(log n)<br>对一棵完全二叉树，<br><strong>第 0 层</strong>（根节点）有 1 个结点。<br><strong>第 1 层</strong> 有 2个结点。<br><strong>第 2 层</strong> 有 4个结点。<br><strong>第 h 层</strong> 最多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></g></svg></mjx-container> 个结点。<br>因此，<strong>最多的总结点数</strong>：1+2+4+⋯+<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></g></svg></mjx-container>=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></g></svg></mjx-container>+1−1<br>设堆的结点总数为 n，则：n≤<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.285ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 1894 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>-1<br>    n+1≤<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.285ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 1894 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container><br>    <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.894ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4815 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"/><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"/></g><g data-mml-node="mn" transform="translate(1311,-241.4) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="2061" d=""/></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2103.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2925.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3926,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4426,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>≤h+1<br>    h≥ <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.168ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6704.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"/><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"/></g><g data-mml-node="mn" transform="translate(1311,-241.4) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="2061" d=""/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1881.2,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1211.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2211.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2711.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g><g data-mml-node="mo" transform="translate(5203.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6204.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container><br>    h=O(log n)</p></blockquote><h3 id="5-堆的实现"><a href="#5-堆的实现" class="headerlink" title="5. 堆的实现"></a>5. 堆的实现</h3><p>堆通常用数组来实现，因为完全二叉树的结构适合用数组来表示：</p><ul><li>数组中下标为 <code>i</code> 的元素的左子节点在下标 <code>2*i + 1</code>，右子节点在下标 <code>2*i + 2</code>，父节点则在下标 <code>(i-1) / 2</code>。<br><strong>代码：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;  <span class="comment">// 使用vector存储堆元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆化操作，从下标i开始，调整堆。（加上left(i)与right(i)都是最大堆）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="type">int</span> largest = i;           <span class="comment">// 假设当前节点是最大值</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;      <span class="comment">// 左子节点下标</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;     <span class="comment">// 右子节点下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子节点比当前节点大，更新largest</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; heap[left] &gt; heap[largest]) {</span><br><span class="line">            largest = left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右子节点比当前节点大，更新largest</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; heap[right] &gt; heap[largest]) {</span><br><span class="line">            largest = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果largest不等于i，说明需要交换</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) {</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[largest]);</span><br><span class="line">            <span class="built_in">heapify</span>(largest, n);  <span class="comment">// 递归调整下去</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);  <span class="comment">// 将新元素插入到堆的末尾</span></span><br><span class="line">        <span class="type">int</span> i = heap.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 上浮操作：如果新插入的元素比父节点大，则交换</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; heap[i]) {</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 更新i为父节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆顶元素（根节点）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteRoot</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"Heap is empty!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将堆的最后一个元素移动到根节点</span></span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 调整堆，使其重新满足堆的性质</span></span><br><span class="line">        <span class="built_in">heapify</span>(<span class="number">0</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆操作，调整整个数组为一个堆，以为最后一个结点的父节点为(n-2)/2,也就是n/2-1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，进行堆化操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="built_in">heapify</span>(i, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆的元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printHeap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : heap) {</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆顶元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRoot</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="string">"Heap is empty!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回一个无效值</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MaxHeap maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after insertion: "</span>;</span><br><span class="line">    maxHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆顶元素</span></span><br><span class="line">    maxHeap.<span class="built_in">deleteRoot</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after deleting root: "</span>;</span><br><span class="line">    maxHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆操作</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>};</span><br><span class="line">    MaxHeap customHeap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : arr) {</span><br><span class="line">        customHeap.<span class="built_in">insert</span>(val);</span><br><span class="line">    }</span><br><span class="line">    customHeap.<span class="built_in">buildHeap</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after building from array: "</span>;</span><br><span class="line">    customHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6.priority_queue"></a>6.priority_queue</h3><p><code>priority_queue</code> 是 C++ 标准库中的 <strong>优先队列</strong>，底层通常由 <strong>堆（heap）</strong> 实现。默认情况下，它是一个 <strong>最大堆</strong>（大顶堆），即 <strong>每次取出的元素都是当前最大的</strong>。如果想要最小堆（小顶堆），需要进行一些特殊处理。</p><h6 id="1-priority-queue-的基本用法"><a href="#1-priority-queue-的基本用法" class="headerlink" title="1.priority_queue 的基本用法"></a><strong>1.<code>priority_queue</code> 的基本用法</strong></h6><p> <strong>头文件</strong><br><code>priority_queue</code> 需要包含 <code>&lt;queue&gt;</code> 头文件：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><strong>定义 <code>priority_queue</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;  <span class="comment">// 默认是最大堆（大顶堆）</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;, </span><br><span class="line">          <span class="keyword">class</span> Compare = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>参数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>T</code></td><td>队列中存储的元素类型</td></tr><tr><td><code>Container</code></td><td>存储数据的底层容器，默认是 <code>std::vector&lt;T&gt;</code></td></tr><tr><td><code>Compare</code></td><td>比较器，默认是 <code>std::less&lt;T&gt;</code>（大顶堆）</td></tr></tbody></table></div><p><strong>常用操作</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>push(x)</code></td><td>插入元素 <code>x</code></td></tr><tr><td><code>pop()</code></td><td>删除堆顶元素</td></tr><tr><td><code>top()</code></td><td>返回堆顶元素</td></tr><tr><td><code>empty()</code></td><td>判断是否为空</td></tr><tr><td><code>size()</code></td><td>返回元素个数</td></tr></tbody></table></div><p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"堆顶元素: "</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 5（最大值）</span></span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">pop</span>();  <span class="comment">// 删除 5</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"新的堆顶元素: "</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆顶元素: 5</span><br><span class="line">新的堆顶元素: 4</span><br></pre></td></tr></table></figure></p><hr><h6 id="2-小顶堆（最小堆）"><a href="#2-小顶堆（最小堆）" class="headerlink" title="2. 小顶堆（最小堆）"></a><strong>2. 小顶堆（最小堆）</strong></h6><p>默认情况下，<code>priority_queue</code> 是 <strong>最大堆</strong>，如果需要 <strong>最小堆</strong>，可以使用 <strong><code>std::greater&lt;T&gt;</code></strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"堆顶元素: "</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 1（最小值）</span></span><br><span class="line"></span><br><span class="line">    minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"新的堆顶元素: "</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆顶元素: 1</span><br><span class="line">新的堆顶元素: 3</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE] <strong><code>std::greater&lt;T&gt;</code>std::greater<t><code>是 C++ 标准库</code><functional>` 头文件中的一个</functional></t></strong>函数对象（仿函数）<strong>，用于 </strong>比较两个值的大小<strong>，它的作用是</strong>定义”大于”（&gt;`）的比较规则**。</p></blockquote><hr><h6 id="3-存储-pair（结构体、对象）"><a href="#3-存储-pair（结构体、对象）" class="headerlink" title="3. 存储 pair（结构体、对象）"></a><strong>3. 存储 <code>pair</code>（结构体、对象）</strong></h6><p>有时，我们需要让 <code>priority_queue</code> 存储 <strong>更复杂的数据类型</strong>，例如 <code>pair&lt;int, int&gt;</code>，可以通过 <strong>自定义比较方式</strong> 来决定排序规则。</p><p><strong>(1)按第一个元素降序（默认）</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><p>这样 <code>pair&lt;int, int&gt;</code> <strong>会按第一个元素降序排列</strong>，也就是最大堆。<br>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">5</span>, <span class="number">200</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">4</span>, <span class="number">400</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(5, 200)</span><br><span class="line">(4, 400)</span><br><span class="line">(3, 100)</span><br><span class="line">(1, 300)</span><br></pre></td></tr></table></figure><hr><p><strong>(2) 按第一个元素升序（小顶堆）</strong></p><p>如果希望 <strong>按 <code>pair</code> 的第一个元素升序排列</strong>，可以使用 <code>std::greater&lt;&gt;</code>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">5</span>, <span class="number">200</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">4</span>, <span class="number">400</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p> <strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1, 300)</span><br><span class="line">(3, 100)</span><br><span class="line">(4, 400)</span><br><span class="line">(5, 200)</span><br></pre></td></tr></table></figure><hr><h6 id="4-自定义比较函数"><a href="#4-自定义比较函数" class="headerlink" title="4. 自定义比较函数"></a><strong>4. 自定义比较函数</strong></h6><p>如果需要更复杂的排序规则（如按照 <code>pair.second</code> 排序），可以使用 <strong>lambda 表达式或函数对象</strong>。</p><p> <strong>(1) 使用 <code>lambda</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">};</span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">2</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">200</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2, 100)</span><br><span class="line">(3, 200)</span><br><span class="line">(1, 300)</span><br></pre></td></tr></table></figure><hr><p><strong>(2) 使用 <code>struct</code></strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure><hr><h6 id="5-priority-queue-时间复杂度"><a href="#5-priority-queue-时间复杂度" class="headerlink" title="5. priority_queue 时间复杂度"></a><strong>5. <code>priority_queue</code> 时间复杂度</strong></h6><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>插入 (<code>push</code>)</td><td>O(log⁡n)</td></tr><tr><td>取堆顶 (<code>top</code>)</td><td>O(1)</td></tr><tr><td>删除堆顶 (<code>pop</code>)</td><td>O(log⁡n)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> C++ </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode二分查找专题</title>
      <link href="/2025/02/26/code/leetcode/LeetCode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
      <url>/2025/02/26/code/leetcode/LeetCode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>二分查找是一种在有序数组中查找特定元素的算法，它通过不断将搜索区间减半来快速定位目标元素。对于搜索区间的定义有三种方式，分别是左闭右闭，左闭右开和左开右开。</p><p><img src="https://pica.zhimg.com/v2-b3a26dbc877a99eb9364fb6d73186392_1440w.jpg" alt></p><p><strong>这三者之间的主要区别在于以下两点</strong><br>(1)每次折半的时候两端的坐标应该移到mid的位置上还是多偏移一个元素<br>(2)while判断结束的条件是 <code>left&lt;right</code>,<code>left&lt;=right</code>,还是<code>left&lt;right-1</code>  </p><ul><li><p>left和right的偏移区别  </p><ul><li>左闭右闭区间，要找的值比<code>target</code>小，那么<code>right=mid-1</code>，因为<code>mid</code>已经被检查过了，<code>mid-1</code>保证了闭区间不重复，要找的值比<code>target</code>大，那么<code>left=mid+1</code>。</li><li>左闭右开区间，要找的值比<code>target</code>小，那么<code>right=mid</code>，保证了右开区间，要找的值比<code>target</code>大，那么<code>left=mid+1</code>。</li><li>左开右开区间，要找的值比<code>target</code>小，那么<code>right=mid</code>，要找的值比<code>target</code>大，那么<code>left=mid</code>，这样保证了每次缩小的区间都是左开右开的。</li></ul></li><li><p>while判断结束的条件</p><ul><li>左闭右闭区间，因为搜索的范围包括区间的两个端点，所以当<code>left=right</code>的时候，搜索的范围仍然存在，所以while判断结束的条件是<code>left&lt;=right</code>。</li><li>左闭右开区间，因为搜索的范围包括区间的左端点，不包括区间的右端点，所以当<code>left=right</code>的时候，搜索的范围已经不存在了，所以while判断结束的条件是<code>left&lt;right</code>。</li><li>左开右开区间，因为搜索的范围不包括区间的两个断点，所以当<code>left=right-1</code>的时候，搜索的范围已经不存在了，所以while判断结束的条件是<code>left&lt;right-1</code>。</li></ul></li></ul><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//缩小范围到[mid+1,right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;<span class="comment">//缩小范围到[left,mid-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右开区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//缩小范围到[mid+1,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;<span class="comment">//缩小范围到[left,mid)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左开右开区间 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">-1</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;<span class="comment">//缩小范围到(mid,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;<span class="comment">//缩小范围到(left,mid)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么使用mid = l + (r - l) / 2</strong><br><code>mid = l + (r - l) / 2</code>这个计算方式避免了直接使用<code>(l+ r) / 2</code>可能导致的整数溢出问题。</p><blockquote><p>[!NOTE]<br>以下代码都在左闭右闭的情况下写。</p></blockquote><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p><strong>题目：</strong><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:<br>输入: <code>nums = [1,3,5,6],</code> <code>target = 5</code><br>输出: 2<br>示例 2:<br>输入: <code>nums = [1,3,5,6]</code>, <code>target = 2</code><br>输出: 1<br>示例 3:<br>输入: <code>nums = [1,3,5,6]</code>, <code>target = 7</code><br>输出: 4</p><p>提示:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 无重复元素 的 升序 排列数组</li><li>-<code>104 &lt;= target &lt;= 104</code></li></ul><p><strong>思路：</strong><br>以left作为参考标准，也就是return left。<br>因为当left，right重叠时，mid也在此处：<br>    如果<code>nums[mid] &lt; target</code>，因为此时<code>nums[mid]</code>比target小，而<code>nums[mid+1]</code>比target大，插入位置为<code>mid+1</code>，所有<code>left=mid+1</code>。<br>    如果<code>nums[mid] &gt; target</code>，因为此时<code>nums[mid]</code>比target大，而<code>nums[mid-1]</code>比target小，插入位置为<code>mid</code>，所有<code>left=mid</code>，也就是left不变。<br>    如果<code>target==nums[mid]</code>，则left不变，刚好为所在位置。<br>综上：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p><strong>题目</strong><br>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 <code>[-1, -1]</code>。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。<br>示例 1：<br>输入：nums =<code>[5,7,7,8,8,10]</code>, target = 8<br>输出：<code>[3,4]</code><br>示例 2：<br>输入：nums =<code>[5,7,7,8,8,10]</code>, target = 6<br>输出：<code>[-1,-1]</code><br>示例 3：<br>输入：nums = [], target = 0<br>输出：<code>[-1,-1]</code></p><p>提示：<br><code>0 &lt;= nums.length &lt;= 105</code><br><code>109 &lt;= nums[i] &lt;= 109</code><br><code>nums</code>是一个非递减数组<br><code>-109 &lt;= target &lt;= 109</code></p><p><strong>思路：</strong><br> <strong>查找开始位置</strong>：<br>    使用二分查找，调整查找条件，使得找到目标值时，继续向左搜索即<code>right=mid-1</code>，直到找到第一个出现的目标值。<br> <strong>查找结束位置</strong>：<br>    使用类似的二分查找，调整查找条件，找到目标值时，继续向右搜索即<code>left=mid+1</code>，直到找到最后一个出现的目标值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">findLeft</span>(nums, target);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">findRight</span>(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLeft</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; </span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><p><strong>题目：</strong><br>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p>示例 1：<br>输入：<code>nums = [4,5,6,7,0,1,2]</code>, target = 0<br>输出：4<br>示例 2：<br>输入：<code>nums = [4,5,6,7,0,1,2]</code>, target = 3<br>输出：-1<br>示例 3：<br>输入：<code>nums = [1]</code>, target = 0<br>输出：-1</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p><strong>思路：</strong><br>考虑<code>left=mid+1</code>的情况<br>1.<code>nums[0]&lt;=nums[mid]</code>，此时mid一定在前半有序部分。<br>    若<code>target&lt;nums[0]</code>，则一定在<code>[mid+1,right]</code>中寻找。例：<code>[4,5,6,7,8,0,1,2]</code>中<code>mid</code>为7，<code>target</code>为1。<br>    如果<code>nums[0]&lt;target&amp;&amp;target&gt;nums[mid]</code>,则一定在<code>[mid+1,right]</code>中寻找。例<code>[4,5,6,7,8,9,1,2]</code>中<code>mid</code>为7，<code>target</code>为9。<br>2.<code>nums[0]&gt;nums[mid]</code>，此时mid一定在后半有序部分。<br>    则要想向后寻找，不仅要<code>target&gt;nums[mid]</code>，还有<code>target&lt;nums[0]</code></p><p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>]&lt;=nums[mid]&amp;&amp;(nums[mid]&lt;target||target&lt;nums[<span class="number">0</span>])) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[mid] &amp;&amp; target&lt;nums[<span class="number">0</span>] &amp;&amp; target&gt;nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h2><p><strong>题目</strong><br>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到<code>[4,5,6,7,0,1,2]</code></li><li>若旋转 7 次，则可以得到<code>[0,1,2,4,5,6,7]</code><br>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code>旋转一次 的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</li></ul><p>给你一个元素值 互不相同 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为<code>O(log n)</code> 的算法解决此问题。</p><p>示例 1：<br>输入：<code>nums = [3,4,5,1,2]</code><br>输出：1<br>解释：原数组为<code>[1,2,3,4,5]</code> ，旋转 3 次得到输入数组。</p><p>示例 2：<br>输入：nums = <code>[4,5,6,7,0,1,2]</code><br>输出：0<br>解释：原数组为<code>[0,1,2,4,5,6,7]</code>，旋转 4 次得到输入数组。</p><p>示例 3：<br>输入：nums = <code>[11,13,15,17]</code><br>输出：11<br>解释：原数组为 <code>[11,13,15,17]</code> ，旋转 4 次得到输入数组。</p><p><strong>思路：</strong><br>此时需要思考何时向左缩小，合适向右缩小。<br>下面考虑合适向右缩小，即<code>left=mid+1</code><br>    当最小值在右侧时，一定是mid在前半有序部分，即<code>nums[mid]&gt;nums[0]</code>。注意到可以旋转K次，即没有旋转。那还需<code>nums[0]&gt;nums[nums.size()-1]</code>。故为<code>nums[0] &lt;= nums[mid] &amp;&amp; nums[0] &gt; nums[nums.size() - 1]</code></p><p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid] &amp;&amp; nums[<span class="number">0</span>] &gt; nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>])left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p><strong>题目：</strong><br>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>示例 1：<br>输入：<code>nums1 = [1,3], nums2 = [2]</code><br>输出：<code>2.00000</code><br>解释：<code>合并数组 = [1,2,3] ，中位数 2</code></p><p>示例 2：<br>输入：<code>nums1 = [1,2], nums2 = [3,4]</code><br>输出：<code>2.50000</code><br>解释：<code>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</code></p><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><p><strong>思路：</strong><br><a href="https://www.bilibili.com/video/BV1DL4y1E7ai/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b8bc0462592327f4a9dfd55c480d4863">【LeetCode 每日一题】4. 寻找两个正序数组的中位数 | 手写图解版思路 + 代码讲解_哔哩哔哩_bilibili</a></p><p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>() + nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保证nums1短，nums2长</span></span><br><span class="line">        <span class="keyword">if</span> (nums<span class="number">1.</span><span class="built_in">size</span>() - i &gt; nums<span class="number">2.</span><span class="built_in">size</span>() - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(nums2, j, nums1, i, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nums1没有元素</span></span><br><span class="line">        <span class="keyword">if</span> (nums<span class="number">1.</span><span class="built_in">size</span>() == i)<span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个数组k/2位置</span></span><br><span class="line">        <span class="type">int</span> idx1 = <span class="built_in">min</span>((<span class="type">int</span>)nums<span class="number">1.</span><span class="built_in">size</span>(), i + k / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> idx2 = j + k - k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[idx1 - <span class="number">1</span>] &lt; nums2[idx2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//丢弃nums1的[i,idx1)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(nums1, idx1, nums2, j, k - (idx1 - i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//丢弃nums2的[j,idx2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(nums1, i, nums2, idx2, k - (idx2 - j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> 力扣 </tag>
            
            <tag> CPP </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纵横四海EP38《时间贫困》一个人的时间花在哪里,是看得见的</title>
      <link href="/2025/02/24/podcosts/%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7EP38%E3%80%8A%E6%97%B6%E9%97%B4%E8%B4%AB%E5%9B%B0%E3%80%8B%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%E8%8A%B1%E5%9C%A8%E5%93%AA%E9%87%8C,%E6%98%AF%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84/"/>
      <url>/2025/02/24/podcosts/%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7EP38%E3%80%8A%E6%97%B6%E9%97%B4%E8%B4%AB%E5%9B%B0%E3%80%8B%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%E8%8A%B1%E5%9C%A8%E5%93%AA%E9%87%8C,%E6%98%AF%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是可支配时间与时间贫困"><a href="#什么是可支配时间与时间贫困" class="headerlink" title="什么是可支配时间与时间贫困"></a><strong>什么是可支配时间与时间贫困</strong></h1><h2 id="可支配时间"><a href="#可支配时间" class="headerlink" title="可支配时间"></a>可支配时间</h2><p><strong>可支配时间</strong>就是花在想做之事上的时间，就是你想干嘛就干嘛的那种时间。</p><h2 id="可支配时间和生活满意度之间的关联"><a href="#可支配时间和生活满意度之间的关联" class="headerlink" title="可支配时间和生活满意度之间的关联"></a>可支配时间和生活满意度之间的关联</h2><p><strong>可支配时间每天&lt;2小时</strong>：会陷入时间贫困。</p><p><strong>可支配时间每天&gt;5小时</strong>：会失去目标感和成就感</p><h2 id="两个增加快乐，让我们过得更幸福的启示"><a href="#两个增加快乐，让我们过得更幸福的启示" class="headerlink" title="两个增加快乐，让我们过得更幸福的启示"></a>两个增加快乐，让我们过得更幸福的启示</h2><ol><li>我们要至少我们要在一天中找到让我们不限于时间贫困的这个时间，理想的话至少是2小时以上。</li><li>下一步要做的是看看这两小时我们应该怎么使用能够让我们更加快乐，这才是重点。</li></ol><h2 id="时间贫困是一种主观感觉"><a href="#时间贫困是一种主观感觉" class="headerlink" title="时间贫困是一种主观感觉"></a>时间贫困是一种主观感觉</h2><p>时间贫困指的其实并不仅仅是可支配时间小于2小时，他指的也是一种感觉。时间贫困是一种主观的判断，是一种我自己内心深处的这种快乐的感觉。假设如果我每天的那可支配时间是2小时，但是这两小时我没有好好的利用的话，其实我的快乐指数也很低。</p><h1 id="两种基本形式的动力"><a href="#两种基本形式的动力" class="headerlink" title="两种基本形式的动力"></a>两种基本形式的动力</h1><div class="table-container"><table><thead><tr><th><strong>积极聚焦</strong></th><th>聚焦于积极结果</th><th>时间充裕时倾向</th><th>对一切的信心都会提升</th></tr></thead><tbody><tr><td><strong>预防聚焦</strong></td><td>聚焦于回避消极结果</td><td>时间紧张时倾向</td><td>不愿意去探索</td></tr></tbody></table></div><h1 id="如何感觉拥有更多的时间"><a href="#如何感觉拥有更多的时间" class="headerlink" title="如何感觉拥有更多的时间"></a>如何感觉拥有更多的时间</h1><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>从三个因素上让我们自己感觉到时间更加的充裕</p><ul><li><p><strong>自信心</strong></p><p>  对自己的信心越足，就越觉得自己是时间充裕的。</p><p>  <strong>自我效能感</strong>，指的是一个人相信自己可以做到自己想做的事情的那个信心的程度。</p><p>  影响自我效能感的因素</p><ol><li><p><strong>过往的经验</strong></p></li><li><p><strong>替代经验</strong></p><p> 如果你能够观察到别人成功的完成了类似的任务，尤其是当成功的那个人跟自己有相似之处时，这个时候你的自我效能感也会提高。</p></li><li><p><strong>言语劝导</strong></p><p> 来自于他人的积极反馈</p></li><li><p><strong>情绪和生理的状态</strong></p><p> 当我在感觉良好的时候，放松的时候，那我的自我效能感就是高</p></li><li><p><strong>社会和环境因素</strong></p></li></ol></li><li><p><strong>运动</strong></p><p>  有研究表明运动会提升我们的自我效能感。</p><p>  可以尝试去满足每天走30分钟，这个目标非常的容易。当你一开始的时候，你发现你完成了目标，你的整个感觉真的就瞬间变好了。然后我就觉得这一天我有时间去干很多别的事情。没有过久你就会发现，确实对于整个身体的状态有改变。</p><p>  <strong>实践：</strong>从现在往后数的七天内，请大家坚持至少每天找出半小时的时间，打电话也好，听播客也好，听书也好，拿出半小时的时间出去走一圈。</p></li><li><p><strong>行善</strong></p><p>  帮助他人其实是一种能够显著提高自我效能感的活动。因为你能够帮到他人，那你就说明你们认同自身的能力，会让我们看到我们对别人的生活造成的影响，会增加我们的目标感，增加我们的成就感。</p><p>  当你愿意去帮助别人的时候，你就会自然而然觉得我一定是有时间我才会去帮别人的。</p><p>  实践：就是本周抽时间随机做两件善事，一件给你的亲友，一件给陌生人。</p></li><li><p><strong>敬畏感</strong></p><p>  其实就是当我们产生一种我们超越了我们个体的极限，我们产生了一种敬畏心的时候，我们就会感觉时间变充裕。</p><p>  获得敬畏感的方式：</p><ol><li>比如，看完了电影之后，我的心中那一刻是平静的。是没有觉得我没有时间坐这，暂时就不会回到时间贫困的心态中去。而反而会生出我有很多的时间，我的人生有更大的理想，我可能想要去做更多的事情。</li><li>社交互动也是可以获得敬畏感的。就当我们进入到一段比较好的高质量的很深的人际关系，他突然之间让我们觉得这段关系超出了我们个人的界限。</li><li>艺术肯定是能让你沉醉其中的。那种产生共鸣的艺术总是让能让人平静下来，忘记时间的。每个人都可以找到最打动自己的艺术形式。</li><li>还有成就这件事情，不是你自己的成就，是人类所取得的成就，它也能够让我们产生敬畏感</li></ol></li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>要至少给我们找出两小时的可支配时间。</p><p>所有有些事情就是要少做。如果你要是连续刷5个小时的手机，那就是可以节留出很多的时间来。</p><p>可是我们忙碌的人生中有很多东西是没有办法节流的。节流也就只能截到那儿，一天也就只有24小时</p><h1 id="快乐是一种主动的选择"><a href="#快乐是一种主动的选择" class="headerlink" title="快乐是一种主动的选择"></a>快乐是一种主动的选择</h1><p>当我们用我没有时间叉叉叉这样的句式来造句的时候，第一时间浮现到我们脑海，当然就是我想做的事情。可是让我们心底真正想要去做的事情，这么快乐的事情，我为什么就是想不起来去做呢？咱是不是就应该优先考虑先把这些事情填满我们的时间？</p><p>快乐不是我们的本能，快乐不是我们下意识就一定会做的事情。快乐其实就是一种主动的选择，或者说快乐其实是一种需要你后天培养的能力，而且是需要你主动经常想到我要做让我快乐的事情，我要主动去管理我的快乐。</p><h2 id="记录时间与快乐值"><a href="#记录时间与快乐值" class="headerlink" title="记录时间与快乐值"></a>记录时间与快乐值</h2><p>那怎么去主动努力呢？很简单的方法就是你一定要把自己的时间花在快乐的事情上。</p><p>所有你要看你一天24小时，你的每1个小时是花在了什么事情上，而这件事情让你有多快乐，这个原理非常的重要。</p><p>我们要做两件事情。第一记录你的时间，第二记录你每一个事件的快乐值</p><h3 id="记录时间"><a href="#记录时间" class="headerlink" title="记录时间"></a>记录时间</h3><ul><li><p><strong>方式</strong></p><ol><li><p>如果说我正在PC机上或者安卓上的，直接使用谷歌的日历。如果我是在苹果电脑上，我就会使用苹果电脑自带的那个日历。</p></li><li><p>一定要有一个好用的备忘录，备忘录里面记下，说我这段时间在干嘛，他大概花了多长时间。你再把这个时间重新补到日历上就可以了。</p></li><li><p>以15分钟为单位来记录的</p></li><li><p>分类，按色块</p><p> 尽量的要给不同的时间安排上不同的色块，这个色块就对应着不同的类别。</p><p> 大家可以随着你的使用不断的去进行思考，不断的去进行调整。在这个调整中渐渐的你就会找到你自己最好的分类和最好的颜色。</p></li></ol></li><li><p><strong>内容</strong></p><p>  日历的记录它其实不光是时间的记录，它也是一个非常有用的小的时间生活笔记的一个记录表。记录尽量详细一点，因为你的这个记录是为了对自己的时间使用有更清晰的认知，对自己有更清晰的认知。</p></li><li><p><strong>意义</strong></p><p>  记录时间的意义就是帮助你更好的理解你的时间花在了哪里。我你的时间花在哪里，你就会肉眼可见的看到自己成为一个什么样的人，你的经历构成了今天的你。</p><p>  记录时间不光光是能够帮助了解你个人，还能够给你更多的动力去把你的作息调整的非常的健康。</p><p>  发现后来就是一定要留出这一天的娱乐时间来。</p><p>  以及在这一天的效率非常的高的情况下，就算你今天能够12点前睡觉，整个恢复不过来。你会严重的影响到第二天的效率。</p></li></ul><h3 id="记录快乐值"><a href="#记录快乐值" class="headerlink" title="记录快乐值"></a>记录快乐值</h3><p>我们可以以十分制来记录，一分就是不快乐，对吧？那个十分就是非常快乐，分数越高越快乐，大家自己凭感觉。</p><p>这里要注意的是，我们一定要区分真正的快乐和多巴胺驱动。快乐其实分成两个层级，就是当下的快乐和未来的快乐。</p><h2 id="快乐的三个元素"><a href="#快乐的三个元素" class="headerlink" title="快乐的三个元素"></a>快乐的三个元素</h2><ol><li><p><strong>投入程度</strong></p><p> 当你投入程度越高的时候，你的感觉上就会越快乐。而且你投入的话，你不但当下比较快乐，你得到的成果比较好，对将来你也比较快乐吧。</p></li><li><p><strong>有质量的社交</strong></p></li><li><p><strong>成就感、意义感、目标感</strong></p></li></ol><p>寻找快乐的第一个目标并不是去做更多快乐的事情。我们首先要削减那些让我们不快乐的事情。</p><h2 id="快乐和意义的四个象限"><a href="#快乐和意义的四个象限" class="headerlink" title="快乐和意义的四个象限"></a>快乐和意义的四个象限</h2><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d5f13d55-2b6b-48e4-b70a-4b1b036c0c2d/0437c18e-fadf-42db-9e1d-8b4deb39b15d/dfb234c8f167abea933014cee265522.jpg" alt="dfb234c8f167abea933014cee265522.jpg"></p><ol><li><p><strong>第一类：既快乐又有意义。</strong></p><p> 这个不用想，无论是现在还是未来肯定都是快乐的时间。</p></li><li><p><strong>第二类是：快乐和意义只占其一的这个事情</strong></p><p> 我们把它叫做无聊的事情。</p></li><li><p><strong>第三类：既不快乐又没有意义</strong></p><p> 当然就是浪费的时间。我们希望我们的快乐直升增加，其实第一步首先要去处理的就是浪费的时间这一类里边所有的事情。</p></li></ol><p>每一个人其实对这些事件的分类都不一样。总之在你自己的这个象限里边，每个人都有自己的意义值，每个人都有自己的快乐值。</p><h2 id="快乐跟踪"><a href="#快乐跟踪" class="headerlink" title="快乐跟踪"></a>快乐跟踪</h2><p>会更明白对你来说这些事件都在你的哪个象限。</p><ol><li><p><strong>首先我们可以写下我们最快乐的三件事</strong></p><p> 就是对我来说又快乐又有意义的三件事。</p><p> 今天开始记录时间，往后的一周你不但记录你的时间段，而且你的每一段时间在当下凭感觉凭直觉有一个分值，然后写下十分分值的三类事情。</p></li><li><p><strong>写下你最不快乐的三件事</strong></p></li><li><p><strong>在你最快乐的三件事和最不快乐的三件事上分别去找共同点</strong></p><p> 写的时候每一件事情都要写出时间、地点、人物、事件。</p><p> 例：作者就发现他所有让他开心的事情的地点都有一个特点，就是户外。在人物方面他发现让他快乐的社交必须是一对一的交谈。</p></li></ol><aside> 💡对大多数人来说，最快乐的事情都是有质量的人际关系，以及跟大自然去建立连接。</aside><h2 id="亲密关系诱导任务"><a href="#亲密关系诱导任务" class="headerlink" title="亲密关系诱导任务"></a>亲密关系诱导任务</h2><p>增加大家能够从人际关系中得到的快乐的方法</p><ol><li>把学生两两分成一组，互相回答三组问题。首先用两分钟回答第一组问题，这些是很基本的问题。比如说你叫什么名字？你来自哪里？</li><li>五分钟回答第二组问题。这些是个人兴趣、目标、经历相关的问题。比如说你喜欢做什么？你的爱好是什么？如果你可以去世界上任何地方旅行，你会去哪里？为什么？你最想改变的一个习惯是什么？这是第二组问题。</li><li>然后剩下的八分钟回答第三组问题。这一组问题开始就相对比较私人，比如说认识新的人对你来说是困难还是容易呢？为什么？描述你最近一次感到孤独的时刻，你最害怕的事情是什么？最近有什么让你感到自豪的事情吗？</li></ol><h2 id="不快乐的三个障碍"><a href="#不快乐的三个障碍" class="headerlink" title="不快乐的三个障碍"></a>不快乐的三个障碍</h2><ol><li><p><strong>关联性</strong></p><p> 就是人际关系，就是跟他人产生真正的链接。如果你阻碍了这个链接，让你觉得你跟世界，你跟他人没有链接，让你觉得孤独的，那肯定就是不快乐。</p></li><li><p><strong>自主性</strong></p><p> 这个很好理解一件你自己本来自己做的是很开心的事情，别人命令你去做，你马上就不开心了。</p></li><li><p><strong>能力</strong></p><p> 也就是说这件事情让我阻碍了我对自己产生能力，就是产生了自我贬低自卑的感觉，让我就是成就感的反面，那这个时候肯定是不快乐的</p></li></ol><h2 id="情绪兴奋剂：做了以后都会觉得很开心"><a href="#情绪兴奋剂：做了以后都会觉得很开心" class="headerlink" title="情绪兴奋剂：做了以后都会觉得很开心"></a>情绪兴奋剂：做了以后都会觉得很开心</h2><ol><li><strong>运动</strong></li><li><strong>睡眠</strong></li></ol><h2 id="无法避免不快乐事件时，我们该怎么办"><a href="#无法避免不快乐事件时，我们该怎么办" class="headerlink" title="无法避免不快乐事件时，我们该怎么办"></a>无法避免不快乐事件时，我们该怎么办</h2><ol><li><p><strong>外包</strong></p><p> 如果你的家务劳动很很繁重的话，很简单的解决方法就是家务外包</p></li><li><p><strong>快乐捆绑</strong></p><p> 就是把你喜欢的事情跟你不喜欢的事情绑在一起。</p><p> 比如说我家务没有办法，我一定要做，那我做家务的时候我就要听播客，我就要听有声书。</p></li><li><p><strong>目标感，意义感，联结感</strong></p><p> 工作上要找到快乐，其实我们的方法就是找到你的目标感和意义感。一定要在工作上积极的寻找朋友，在职场上一定要给你一种人际关系的联结感，才能够弥补你们缺乏意义感和目标感的那种痛苦。</p></li></ol><aside> 💡**寻找自己的目标：使用5Y法**一定要找到一个问题的根源，你不能够停留在第一个Y上。</aside><h2 id="如何让平凡的生活变得更快乐"><a href="#如何让平凡的生活变得更快乐" class="headerlink" title="如何让平凡的生活变得更快乐"></a>如何让平凡的生活变得更快乐</h2><aside> 💡**享乐适应**我们在持续反复接触一样事物的时候，会产生一种适应性。因为熟悉的东西对我们来说是安全的，我们总是去探索新的东西，因此对于熟悉的东西，我们的快乐值就会逐渐的下降，这个就叫做**享乐适应**，他就会削弱曾经的美好经历给我们带来的感受。</aside><p><strong>方法：</strong></p><h3 id="1-计算剩余时间"><a href="#1-计算剩余时间" class="headerlink" title="1.计算剩余时间"></a><strong>1.计算剩余时间</strong></h3><p>随着年龄的增长，人们对于平凡事件所赋予的快乐值会不断的升高，最终会跟不平凡的事件的快乐值等同。</p><p>如何计算：</p><ol><li><p><strong>计算你已经花在这件事情上的时间</strong></p><p> 过去这么多年加起来一共花在这件事情上的次数或者是时间都可以。</p></li><li><p><strong>计算你未来预估会花在这件事情上的时间</strong></p><p> 对未来的预估一定要考虑到各种意外事件。然后预估一个比较合理的你剩下的时间或者是次数。</p></li><li><p><strong>计算一下你剩下的没做的那个部分占总时间的比例</strong></p></li></ol><p>例：我想到我跟我儿子一起散步在这条路上的进度只剩下20%的时候，我突然之间觉得每一天去幼儿园的路都非常值得珍惜。这个快乐值就一下子上来了。</p><p>这个计算进度对我们真的有很深重的影响。我们立刻就能够意识到普通时刻的美。也许做这样的计算，有些人会感到惶恐不安。我自己也觉得有时候计算这样的事情很扎刀子在心里面。但是只有做了这样的计算，你才能够更珍惜所拥有的一切。</p><h3 id="2-仪式感"><a href="#2-仪式感" class="headerlink" title="2.仪式感"></a>2.仪式感</h3><p>仪式感可以让平凡的事情变得不再平凡</p><h3 id="3-中场休息"><a href="#3-中场休息" class="headerlink" title="3.中场休息"></a>3.中场休息</h3><p>大多数的事情其实都是可以使用中场休息的概念，切换很重要，要顺应我们身体的这个韵律，一般来说90分钟就差不多了。但是不同的事件所用用中场休息的时间是不一样。要靠大家自己从实践中自己去摸索。</p><p>也可以多样性，比如运动，不要每次都是一样的运动，你可以变着来。</p><h2 id="活在当下"><a href="#活在当下" class="headerlink" title="活在当下"></a>活在当下</h2><p>当你投入越高的时候，你的快乐程度就是越高</p><ol><li><p><strong>像度假那样的去度过你的周末</strong></p><p> 有研究表明说度假对满足感、健康、创造，乃至工作表现都有非常积极的影响。</p><p> 度假如此神奇的改变你的体验，就是因为度假就是一种当下在度假的时候，你就会自动把更多的时间安排给快乐，更少去做不快乐的事情。</p></li><li><p><strong>练习冥想，推荐无感冥想</strong></p><p> <strong>做法：</strong>在你的周围寻找找五件能看到的事物，四件能摸到的事物，三件能听到的事物，两件能闻到的食物，一件能尝到的食物。</p><p> 在这种无感练习中能够锻炼感受到实实在在的事物，也就是当下的能力。</p></li><li><p><strong>戒网，就是戒网瘾</strong></p><p> 建议我们可以每周找一天的时间进行断网，可以结合前面的周末度假。</p><p> 实在做不到全天断网的话，至少你可以做到说我在这个时间大家找我，不要期望我秒回。这个周末只会早中晚看三次手机来回复大家的消息。所有的社交媒体你都不要刷。</p></li></ol><h1 id="储时罐"><a href="#储时罐" class="headerlink" title="储时罐"></a>储时罐</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>时间管理就像这个桶，当你放入大石块的时候，你还有很多的空隙，你再放入小石子儿，你还是可以填进去。你放完小石子之后，你会发现它还有空隙，能够让细沙再进来。放完细沙之后你再放水，水就能够渗透到整个桶里。但是如果你反过来，你不按照这个顺序你乱来。如果你在这个桶里面先把沙子填满了，那你是不是就放不进石块，也放不进石子。</p><p><strong>时间管理就是一定要给自己的工作划分优先级</strong>，那些重要的东西是大事块，你先把那个大事块填进去，然后你在中间填小石子，然后你再填细沙。</p><p><strong>大石块</strong>：优先级最高的事件，比如说家人和健康这两件事情</p><p><strong>小石块</strong>：优先级稍微次一点的事情，工作上一些重要非紧急的项目</p><p><strong>细沙</strong>：可有可无的小事儿</p><p>我们一定要按顺序来使用我们的时间，就是先保证你的时间上一定要有这些重要的事情。</p><h2 id="细沙陷阱"><a href="#细沙陷阱" class="headerlink" title="细沙陷阱"></a>细沙陷阱</h2><p>就是不知不觉的时候，我们把那些可有可无，不是那么重要的事情填满了我们的时间。那你的大石块，你的小石子儿，你就进不去了，是不是？这个就叫<strong>细沙陷阱</strong>。</p><p>三种常见的细沙陷阱：</p><ol><li><p><strong>刷手机</strong></p><p> 可以我不是不允许自己刷手机，我只是要先把今天所有的这些事情全做了，把这个事情填了，我再来刷手机好不好。</p></li><li><p><strong>回复消息</strong></p><p> 如果你有消息你不在，你不集中在一个时间段去回复，而是有消息你看到的时候，你就会你会发现如果你记录时间的话，你会发现这种时间是很多的。</p></li><li><p><strong>过度承诺</strong></p><p> 就是我们对时间的感受非常不准确，所以很容易过度承诺出去说我未来要做什么。</p><p> 比如说人家邀请你参加一件事情，你当下觉得好像是有点意思，反正就是那天还很空我就先答应下来。结果到了那一天你会发现说，我有很多比他更重要的事情。</p></li></ol><h2 id="细沙陷阱的过滤器"><a href="#细沙陷阱的过滤器" class="headerlink" title="细沙陷阱的过滤器"></a>细沙陷阱的过滤器</h2><ol><li><p><strong>目标过滤器</strong></p><p> 一旦你有很明确的目标，你就能够过滤掉一切不在你这条目标线路上的东西</p></li><li><p><strong>快乐过滤器</strong></p><p> 现在我觉得我们把大石块、小石子都填进去之后，剩下的这个快乐过滤器要过滤的就是要给自己时间去做这些让自己能够快乐的事情。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>我们一开始的时候讲到了可支配时间在2到5小时。如果低于2小时，我们就会陷入时间贫困。如果高于5小时，我们就会陷入缺乏目标感和意义感的无所事事的痛苦。</li><li>首先我们第一步是希望我们能够从这个节流这一方面，找出每天至少可支配时间2小时。</li><li>第二步我们就要进行开源，开源的部分是从主观感受上让自己更加的感到时间充裕，包括运动，做善事，包括让自己感到有些敬畏感。</li><li>接下来我们就要记录我们的时间了。在日历上今天给大家分享了我是怎么用日历这个工具来记录我的时间，以及在这个上面安排快乐值的。</li><li>对于不快乐的事件，比如说占据我们时间最多的像是通勤、家务和工作，都分别给出了让它变得更快乐的方法。</li><li>对于快乐的时间，比如说日常中的美、小确信，我们也讨论了怎么能够从平凡中发现，持续发现美，去摆脱享乐适应的这个问题的方法，我们讨论了活在当下。</li><li>我们也最后讲了这个储蓄罐的概念，就是一定要优先安排大石头和小石子。</li></ol><p>今天讲的内容非常的多，但是如果大家只能记住一点的话，我希望大家记住的就是快乐不是一种本能，快乐是一件我们需要主动去管理，甚至主动去安排时间的事情。快乐是一种需要学习和锻炼的能力，不是与生俱来的。</p><h1 id="部分记录"><a href="#部分记录" class="headerlink" title="部分记录"></a>部分记录</h1><p>就是宇宙中其实存在着很多很多的两种循环，要不然就是良性循环，要不然就是恶性循环。这两个时间漩涡，你踏出的每一步它都不是独立存在的，它都是踏进了一个或良性或恶性的循环。宇宙是熵增的对吧？所以踏出恶性循环的那一步远远比踏出正向循环的那一步要轻松非常多。所以每是我们踏出那一步的时候，总觉得说，就这一次有什么关系。</p><p>第二个是你会发现这一天的效率非常的高的情况下，就算你今天能够12点前睡觉，整个恢复不过来。第二天真的所以你会严重的影响到第二天的效率。如果两天加总在一起，其实你就相当于头一天的这个高校就被抵消掉了。那何苦？那我为什么不在这一天稍微做的少一点，有一种意犹未尽的感觉。我第二天在高校，通常你每一天都保持一种稳定的高效，你整个效率就是最高的。</p><p>我觉得如果你觉得时间记录很累，时间记录很繁琐，很不自由，就是没有意识到你对于时间的判断有多么的不准确，也没有意识到我们人类是天生不擅长让自己快乐的。我需要主动的去安排我的时间以获得我的快乐值，我就会有很有动力，就觉得时间记录是一件必须的事情。而且当记录变成一种习惯之后，其实你对时间的判断会越来越准确。现在我会更加准确的安排明天大概这些时间，大概什么时间点，大概我能完成什么。你看其实时间记录并不是让你不自由，时间记录反而会让你更自由。因为你能够更准确的预估你的时间应该怎么使用，你就能够更自由的去掌控你的时间。</p><p>在我很喜欢的一本书叫做写出我心，里面有一句话我很喜欢，作者说我原本以为自由代表中为所欲为，自由其实意味着自己知道自己是谁，在这世上应该做什么，然后切实的履行自己的责任。我觉得我特别有共鸣，就是真正的自由其实并不是为所欲为，并不是随心所欲。真正的自由是我非常清楚我是什么样的人我非常的清楚我想要什么。并且我能够向着我的北极星进发，去履行我在这个世界上的使命，这个就是真正的自由。如果你不记录自己的时间，你对自己的认知就不是准确，你就不能够最高效率的履行自己的责任，你就不能够空出时间来在这些时间数据的基础上不断的思考，我在这个世界应该做什么，你其实就是不自由的。</p>]]></content>
      
      
      <categories>
          
          <category> 播客笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 播客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 时间 </tag>
            
            <tag> 个人成长 </tag>
            
            <tag> 纵横四海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>独树不成林98-如何抵抗互联网上越来越重的戾气和恶意？</title>
      <link href="/2025/02/24/podcosts/%E7%8B%AC%E6%A0%91%E4%B8%8D%E6%88%90%E6%9E%9798-%E5%A6%82%E4%BD%95%E6%8A%B5%E6%8A%97%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%87%8D%E7%9A%84%E6%88%BE%E6%B0%94%E5%92%8C%E6%81%B6%E6%84%8F%EF%BC%9F/"/>
      <url>/2025/02/24/podcosts/%E7%8B%AC%E6%A0%91%E4%B8%8D%E6%88%90%E6%9E%9798-%E5%A6%82%E4%BD%95%E6%8A%B5%E6%8A%97%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%87%8D%E7%9A%84%E6%88%BE%E6%B0%94%E5%92%8C%E6%81%B6%E6%84%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>大家好，欢迎来到读书不成林。今天咱们这个播客讨论的是我最近的一些想法，那就是如何抵抗互联网上越来越重的戾气和恶意。</p><p>我相信这个现象不需要我来论证，是不是我们大家都可以注意到，越来越多的人不愿意在网上发表自己的观点，越来越多我们原来尊重、喜爱甚至崇拜的对象，可以在一夜之间因为一些言论或者行为触犯了某一些规则和共识，或者说他过去的言论和行为被揭露，一夜之间成为了过街老鼠，被人攻击，被人审判，被人居高临下的审视，这种戾气和恶意无处不在，变得越来越普遍。</p><p>我们就事论事的话，可能会觉得，哎，这个人好像确实做了一些错事，确实不应该说这些话，确实不应该做这些行为，确实值得被深挖他个人历史里令人讨厌的或者说表里不一的一些事迹，这个人确实值得被发展成一门学科。就事论事的话，我们会觉得这种戾气和恶意，它并不是完全毫无理由的。但是如果我们退一步，从广义上来观察这个现象，这一整个公共讨论环境又被这些越来越常见的一瞬间就可以翻涌上来，包裹摧毁，你的戾气和恶意，变得这个公共环境变得乌烟瘴气，不但让越来越多的人失去了说话的欲望，甚至会创建一个人人自危的环境，让越来越多的人恐惧而不敢说话，让越来越多的人自愿的加入围观审判的大众，加入施加恶意和利器的审判方。==审判别人，不但能够给予我们道德上的满足感，更重要的是它能够让我们感到自保安全。当你把审判的手指指向别人的时候，起码在那个时刻你是安全的。但是退一步讲，这样的一个大环境是一个越来越不友好的大环境，一个充满了戾气和恶意的公共讨论环境，是一个我们可以预设路人是残忍的看客的公共讨论环境，而不是心怀善意的听众。==</p><h1 id="三个恶习"><a href="#三个恶习" class="headerlink" title="三个恶习"></a>三个恶习</h1><p>==今天这一期播客我想要对立三种恶习，这三种恶习分别是残忍、虚伪和傲慢。我认为互联网上绝大多数的恶意和戾气，都是出于对于后面两种恶习的过于不容忍。我们过于讨厌他人的虚伪，也过于讨厌他人的傲慢，以至于我们忘了自己的虚伪和自己的傲慢。我们忘了虚伪是人性的一部分，傲慢也是人性的一部分。==如果我们能够把互联网想象成一个极端民主的环境的话，因为人人都可以在上面发声。我觉得一个民主的社会，一个民主环境，他对于虚伪和傲慢这两种品质拥有着天然的敌意乃至于恶意。今天我们要讨论的其实就是虚伪和傲慢这两种品质。</p><p>你可以把这一期播客理解成是我对于虚伪和傲慢的维护。与其说是维护，不如说是我想要好好的展开讨论一下，这两个品质究竟意味着什么。==我觉得这是每一个人身上人性身上共存的特质。但是在民主社会，在互联网这个民主的语境中，我们过于习惯指责他人身上这两种充满了人性的平常的恶习。我们拿着放大镜不停地去审判他人身上的虚伪和傲慢。在几乎所有情况下，这种审判只能够加重我们自己身上的虚伪和我们自己的傲慢。与此同时，在审判别人的虚伪和傲慢的同时，他会加重我们自己第三个恶习。我觉得这第三个恶习才是对于公共环境伤害最大的一个恶。==</p><p>可惜那就是残忍，它会让我们变得更加残忍。我刚才讲的这三种不好的品质，三种恶习，残忍带来的是一定程度的冷漠。虚伪带来的是一定程度的说一套做一套，言行不一，行为和语言上的不自洽。傲慢带来的是我们对于自己所在群体感到的一种优越感。</p><p>我相信，我们都可以承认，残忍、傲慢和虚伪都不是什么好东西，都是一个良善的人应该要尽可能克服的恶习。一个良善的人应该要尽可能的减少他的残忍，他的虚伪和他的傲慢。但是我想说的是，与此同时，这三种恶习都是极其平常的恶习。==如果我们拿着放大镜转而放到自己身上的话，会发现我们每一个人都或多或少的有点残忍，有点虚伪，有点傲慢，这是每一个人身上难以避免的品质。我的观察是在一个人人都可以发声的互联网环境中，我们对于虚伪和傲慢过于不宽容，我们甚至会要求其他人完全不虚伪，完全不傲慢，一旦发现了他们的虚伪和傲慢，就可以立刻开始审判他们。这种行为是一种残忍，残忍它也是一个恶习，我甚至愿意说它是一个比后后面两者更危险、更有危害的恶习。==</p><p>==因为虚伪和傲慢很难成为一整个公众特质，但是残忍可以成为公众的特质，一大群人可以极其残忍而不自知，甚至为此感到沾沾自喜，因为他们感到自己正在做一件消除其他不好的东西、其他恶习的行为。我们正在消除他人的虚伪和他人的傲慢，这种庞大的、广泛的残忍会造成一个充满了恶意和利器的公共环境。==</p><p>今天讨论的内容的灵感来自于我最近重温的一本我非常喜欢的20世纪女性政治理论家rude clare施克莱写的一本书，叫做平常的ordinary vices。所以我可以把我的结论先放在开头，我想说的是如何抵抗一个越来越充满了戾气恶意的公共讨论环境。==那就是我觉得我们作为一个又一个独立的个体，在听播客的，你不是公众，你是一个人，可以尝试着对于人身上普通的恶更加宽容，当然不是完全接受这些恶，但是我们可以更加宽容别人的虚伪和傲慢，不是因为虚伪和傲慢不值得鄙视，而是因为我们自己也挺虚伪，也挺傲慢的。而且通常在我们对他人的虚伪和傲慢表示残忍的审判的时候，这个行为在绝大多数时候也是我们自己傲慢和虚伪的体现。反思带来的宽容，是我能过一个平凡而艰巨的道德生活，作为一个个体我能做出的努力。我觉得一个完全不宽容、虚伪和傲慢的社会，必将是一个残忍的社会。==</p><p>这可能是被科技民主化之后的社会，现代社会最残忍的形态。哪怕我们不反感残忍，但是一个残忍的社会将是一个难以生存的社会。它是一个没有温情的社会，没有善意的社会。这会是一个让你感到面目全非，不知所措，从而只能一言不发的社会。所以今天接下来的内容，我想要讨论我刚才说的这三个恶习，虚伪、傲慢和残忍。讨论这些平常的恶的目的不是为了把它们简化。简化并不能够使这些品质在我们心中更加明晰，恰恰相反，我想要把它们复杂化。通过使它们变得更加复杂，我们对于这些品质的体会也会更加明晰。</p><h1 id="虚伪"><a href="#虚伪" class="headerlink" title="虚伪"></a>虚伪</h1><p>OK我们先来说一说虚伪。虚伪它有一个反义词，虚伪的反义词是什么？虚伪的反义词是真诚。==我们讨厌虚伪，是因为现代人把真诚当做一种美德。==</p><p>现代社会，尤其是互联网上，有一个极其普遍的观念，那就是真诚是美德，我一无所有，只有真诚，这是很多人的宣言，不是吗？甚至可以更进一步。==我这个人就是充满了各种不好的品质，我没礼貌，我一事无成，我干了很多坏事儿，我没素质，我没有美德。但是我真诚地展示着我的平庸，甚至是我的恶劣。只要我真诚，我就可以招人喜欢我觉得所谓互联网自媒体时代，绝大多数人都感到真诚是我需要的唯一品质。我一我一无所有，只有真诚，甚至那就够了。我只要能够真诚的分享那就够了。 其实在互联网时代的政治也是一样，政客最讨人喜欢的品质是真诚，哪怕是你在真诚地描述自己做的一些坏事儿。只要你能够让选民或者是大众觉得你是诚实的，你不虚伪，你就可以获得他们的喜爱。他们喜欢你就可以超过那个他们觉得虚伪的对手。==</p><p>我不知道大家记不记得2016年，特朗普作为一匹政治黑马，他在16年之前都不是共和党员，当时所有人都觉得特朗普不可能战胜希拉里。我之前在那个特朗普选民都是什么人呢？那期播客里讨论过，在2016年的时候，民调显示98%点几，显示希拉里能够战胜特朗普，成为2016届的总统这个结局。当然咱们知道特朗普打败了希拉里，成为了当时的美国总统。其实他们在进行辩论的时候，有一个著名的时刻，让特朗普获得了很多美国选民的青睐，也让我当时觉得哇哦这个人有点东西。 就是在希拉里跟特朗普辩论，我忘了是第一次还是第二次辩论那个台上，希拉里准备了一记重拳，准备挥向特朗普。希拉里说，特朗普，你是一个狡猾的商人，你是一个不好的公民。因为你之前偷税漏税，不是非法的偷税漏税。因为美国人的税务制度里有很多合法的机制，可以帮助你在在法律范围内灰色地带规避你纳税的方式。希拉里为此指责特朗普，他说，你之前盈利的那些钱，都被你通过规避税收的手段，没有向税务局缴纳你应该缴纳的税，就你这种素质低下的公民，你凭什么来领导美国人成为美国的一把手？ 那个时候特朗普他的回复是什么呢？特朗普使用了真诚，他用他典型的那个表情，他耸耸肩一摊手。他说对，没错，我就是一个狡猾的商人，我用合法的手段偷税漏税，因为我是一个好商人，聪明人就是要干这种龌龊的事情，我偷税漏税是因为我是一个好的商人。特朗普说出这句话之后一片哗然，因为他是美国历史上第一个公开承认他就是干了这么一件合法的偷鸡摸狗的事儿的这样的一个总统候选人。当特朗普讲出这句话的时候，我其实就理解为什么会有这么多老百姓网友喜欢特朗普。因为他真诚，他的真诚，他真诚的承认了他自己就是干了偷鸡摸狗的事，合法的偷鸡摸狗。它看起来比希拉里这种诡辩的、成熟的、遮遮掩掩的职业政客要来的招人喜欢的多。一个真诚的小人比起一个虚伪的君子，在现代社会更招人喜欢。</p><p>听到这里，你可能想说，这有什么问题吗？我们要求政客能够言行一致，我们希望社会可以完全开放、完全透明、完全诚实。我们希望公众人物可以透明地承认自己的贪婪，透明地承认自己的花心，透明地承认自己的野心，透明地承认自己做事情有什么不择手段，不对公众隐瞒任何事情。一旦发现这个人有什么虚伪的行为，我们要么试图将这个虚伪根除，要么试图去痛斥这种虚伪，这有什么问题吗？想要一个开放、诚实、透明的社会有什么问题吗？</p><p>我们可以看到，在西方民主社会，他们对于公众、对于政客虚伪行径的反感变得越来越激烈。在英国和美国，他们发现这种政府高官首相boris Johnson制定了新冠疫情聚众派对的规则之后，自己违反了这些规定，群众对于他们的反感之激烈就像是一场政治斗争一样，我们知道这个boris Johnson下台就是因为所谓的派对门事件，他被英国记者爆出来说，他没有遵守自己制定的这个疫情期间公众呃，聚众派对的规则，这是一种虚伪，这种虚伪使民主老百姓恼火，越来越多的西方民主政客因为被发现不坚守自己的规则，言行不一从而毁掉了自己的政治生涯听到这里，你会理所当然的觉得这种对于虚伪的厌恶不是很好吗？我竟然想要维护虚伪，站在这些政客的角度去维护虚伪，我是不是有病？==虚伪当然不是一件好事儿，我在这不是试图在论证虚伪是一件好事，但是恰恰是因为虚虚伪它是一件非常平常的恶习，它不是一件好事儿，我们想要消除它这种消除虚伪的欲望，在我的观察中，它不但无法消除虚伪，而且在很多时候它会带来一种残忍。我的观察是，公众对于虚伪的讨伐，在几乎在所有时候都是一项自欺欺人的运动。==</p><p>自欺欺人的原因有2，第一点是，如果我们要求透明，我们要求人人言行一致，我们要求公众人物不对大众进行任何的隐瞒，我们要求建立一个完全开放、完全诚实、完全透明的社会，并且以此为标准去要求我们的公众人物，不管他是政治人物还是明星。这种透明化的运动只会迫使政客和其他的公众人物寻找更加隐秘的地方，来隐藏他们不想被人知晓的事情。==一个完全要求公开的文化带来的结果并不会是完全的公开带来的结果通常是原来的那些秘密会被隐藏在更深更黑暗的角落。== 我的第二个观察，他为什么是自欺欺人的？这种对于虚伪的讨伐，==他更重要的自欺欺人的原因是因为他是一个自相矛盾的运动。最终我们去观察它给社会带来的改变，并不是虚伪的减少，而是虚伪的增加。我们看到的不是越来越多真诚的人，我们看到的是越来越多虚伪的真诚的人。所有的人都会变得更加虚虚伪的真诚，假装真诚。==</p><p>其实让我想做一个播客。讨论虚伪和真诚的有一个重要原因是前几天我不知道被一个什么杂志的记者采访，忘了是什么杂志了。这个作者，这个记者在听完了我有一期讲互联网的播客之后，应该是如何哗众取宠给我发邮件，他说他在写一个文章说现在人人都要当博主，旅游博主、知识博主、读书博主、离职博主、离婚博主、结婚博主、生娃博主、丁克博主，年轻人渴望通过在互联网上自我表达来获得共鸣。这个记者听完我的播客之后，因为我在播客里面说，能够在互联网上成功的哗众取宠获得尊重，你需要的一定不是真诚的表达自我，你需要的是有保有保留的表达自我。这个记者感到很困惑，就连连追问。他说年轻人要如何通过自我表达，真诚的自我表达来达到共鸣呢？真诚的自我表达和获得别人的关注，这两件事情如果有冲突，那该怎么办呢？</p><p>我跟这个记者聊了1个小时，我觉得他就是没有办法放弃这个执念，放弃真诚是一件好事。这个执念他的这个执念，我觉得是跟互联网网上很多把真诚视为一种美德的年轻人心中怀有的执念是一模一样的那就是他觉得寻找自己一定要通过放弃伪装，放弃虚伪，摒弃虚伪，一定要通过无所保留，说实话不做一个伪君子，保持绝对的诚实和透明，==一个绝对诚实的自己才是一个真实的自己，一个虚伪的自己就不是一个真实的自己。这是一个非常普遍的执念，对吧？我觉得这个想法被很多现代人当做成是一个真理。所以当这个执念就是我不能虚伪，我一定要做一个真诚的人。==</p><p>当这个执念跟现实起了冲突的时候，我们会觉得现实有问题，现实糟透了，现实是腐败的。当时我觉得我没有试图让这个记者理解我想要表达的一个观点，我只能够在播客里自己自言自语地表达。==我当时是这么跟他说的，我说我不认为寻找自我需要的是真诚，这是一种浪漫化的自我，浪漫主义的自我，这是一个极端。只有你浪漫化了一个所谓的自我，你才会觉得失意的、直接的、不加思索的、没有隐藏的、毫无保留的、完全透明的自我表达，就可以开启一条路，让你直接通往真正的自己。==</p><p>现在很多成年的年轻人不理解小朋友都理解的事情。那就是在一个小朋友跟他最好的朋友描绘一件事情的方式，跟这个小朋友跟他妈妈描绘这个事情的方式，跟这个小朋友跟班主任描绘这个事情的方式，一定是有所差别的，有所隐藏的。没有一种描绘方式是完全真诚的，每一种描绘方式都包含了某种隐藏。这种隐藏我们可以说它是一种虚伪，我们也可以说它是一种成熟。这种小朋友都知道的虚伪，他背后需要的是是一种是一种实践智慧，也就是古典美德中亚里士多德认为仅次于知识上的智慧。索菲亚的另外一种现实生活中的实践智。So funy用英文来说，知识上的智慧是wisdom，实践中的智慧是prudent。</p><p>==所有的家长在教育小孩的时候，都需要运用这种言行不一的虚伪，我们可以叫做伪君子的那套，家长教育小孩的时候一定是说一套做一套的，一定是言行不一的==。家长在教育小朋友的时候会跟他说，做人就是不能撒谎，这不代表家长这辈子不会撒谎。家长跟小朋友说我们不能做坏事，这不代表家长没有做过坏事。家长跟小孩说未成年不能够抽烟喝酒发生性关系，这不代表家长自己未成年的时候没有做过这个事儿。家长跟小孩说，你要好好学习，要把作业做完，不要抄袭。这不代表这个家长自己小时候就好好学习了，就做完作业了，就没有抄袭了。</p><p>==现代人一旦发现了家长是一个表里不一的伪君子，就会立刻像小人得得志似的，揪着这种虚伪反过来指责家长，说你凭什么这么要求我，这是你自己都没有做到的事情，对吧？这是一种表里不一。我们假设一个百分之百真诚的家长，一个不虚伪的家长，他从小跟小孩说真诚的实话，他在社会上摸打滚爬获得的残酷的真理，他跟小孩说这个社会就是一个吃人的社会，好人没好报，做坏事也不一定有报应。苦读书多半不能让你改变阶级。看到摔倒的老人，你最好不要上去扶，防止他讹你。看见有权有势的人，你要多去八点。我们对比一下刚才这个虚伪的家长和现在这个真诚的家长。我相信这个对比会让大家意识到这个真诚的家长他不是一个好家长。==</p><p>为什么不是一个好家长？==因为在不同的社会关系中，在不同的场合里，对不同的人我们就是要说一些不同的话。如何说不同的话，去隐藏一些绝对真实的观点，如何适当的虚伪，这需要要的是实际生活中的智慧soproni一个过于把真诚当做美德的社会，是一个把无知当做个性的社会。作为一个成熟的人，有时候我们不光光要通过自我表达来寻找自我，我们还要通过自我隐藏来寻找真实的自我。学会如何在不同的人面前说不同的话，在晚辈面前说晚辈该听的话，在长辈面前说给长辈听的话，在互联网上有所保留的说话，在现实生活中有所保留的说话，这是虚伪。但是这也是一种实践的智慧，这需要的是一种实践上的知识，这才是美德，毫无保留的真诚不是美德，我们顶多可以说它不是一件坏事儿。==</p><p>所以咱们话说回特朗普，特朗普作为一个民粹主义领袖，他之所以能够在极短的时间内在2016年崛起，我觉得他的选民喜欢的重要原因就是因为他看起来比其他虚伪的政客更加真诚，我觉得我跟特朗普有一个共同点，那就是我们都可以让听我们讲话的人感觉到我们很真诚。但是实际上我想说的是，特朗普我不知道，毕竟我也不认识他，我就说我自己。==我想说的是我之所以能够让很多人感觉到很真诚，并不是因为我真的很真诚，而是因为我掌握了真诚的艺术。换句话说，我知道如何虚伪的有所保留的让自己假装真诚。==这一点是我在如何哗众取宠那期播客里讲的重点。从我自己蔓延出去，我坚信所有能够以真诚作为个人特质而讨人喜欢的公众人物，他们到那个层次了之后，一定不是纯粹的真诚，他们一定是掌握了一种真诚的艺术。真诚的艺术只不过是用更加漂亮的话来描绘一种虚伪而已。 特朗普地毯下的秘密还少吗？我并不认为他在地毯下的那些肮脏事儿要少于他批评认为他不够真诚的那些华盛顿的其他职业政客。但是他在演讲的时候，他懂得如何把自己的真诚呈现给用令人讨讨人喜欢的方式，令人信服的方式呈现给他的选民。让他的选民我不知道你们有没有去听过特朗普竞选演讲的时候，对于他支持者的那些采访。他的支持者非常统一的，相对常见的一个声音就是他们会说这个政客特朗普不像其他政客一样在骗我。特朗普知道如何让别人觉得他很真诚，这是一种真诚的艺术，the art of appearing authentic.</p><p>特朗普在很多时候是如何展示他的真诚呢？我觉得他是在使用一种残忍的方式。特朗普是一个把残忍当做自己名片的政客，他展现自己真诚的方式很多时候就是在展现他的残忍。他对于他对手的残忍，他对于美国一整个既有的政治体系所维系的这种假惺惺政客之间贸易的残忍，他对于攻击他的人的残忍。</p><p>为什么特朗普在2016年可以撕碎共和党体制内的政客以及撕碎希拉里？就是因为他会残忍地直指对手的缺点，毫不留情面地用一种不给对手留后路的方式去挑起他人对于她对手的攻击。比如说他说我们要把希拉里给搞起来locker up，比如说他嘲笑他的那些共和党竞选的对手给他起的那些外号，他羞辱和攻击他讨厌的媒体。你可以说这个就是特朗普讨人喜欢的原因，他真诚地攻击他的对手，他不虚伪。但是在听完了特朗普如何改变美国政治布局的那期播客的朋友，我换一个方式来总结我那期播客的一个主要的观察，就是在特朗普之后，美国政局之所以变得更加极端，就是因为总体来说，大家都变得更加残忍了。</p><p>特朗普介绍到政治舞台上的这些攻击别人的方式，那种不留后路地撕碎别人脸面的直接讨论，政客私生活领域的这些平时不会放到台面上的这种攻击方式。在他之后，这种残忍进入了美国民主政治的讨论领域。他真诚地承认自己就是一个骗子，他真诚地承认自己就是合法的偷税漏税了。他真诚的承认自己就是在婚内出轨，睡了一个雁行。这种真诚其实是一种厚颜无耻的真。</p><p>==我的观察是在互联网上运行的这种民主社会公众极端厌恶虚伪，乃至于我们甚至会奖励厚颜无耻的真诚，哪怕这种真诚他是残忍的真诚，也会有人拍手叫好，也会有人说好歹他是真实的。但是我想要对这种拍手叫好泼一盆来自于我的冷水。我觉得想要创造一个没有那么有恶意和戾气的环境，我们需要的是对于这种厚颜无耻的真诚少一点拍手叫好。==</p><p>18世纪的法国哲学家拉UQ有一句非常著名的话，说的是伪善是恶习，在向美德致敬。我觉得当然真君子要好过伪君子。我们这个社会，我相信大家都可以感到真君子是越来越少了。但是我们面临的这个局面，好像更像是一群厚颜无耻的真小人在那里赶尽杀绝，还愿意假装向美德致敬的伪君子，仅仅是因为他们虚伪？我的想法是一个真小人横行霸道的腐败社会是不可能出现真君子的，我们需要的是一个对伪君子拥有更多宽容的社会。我宁愿先做一个向美德致敬的伪君子，我也不想做做一个真小人，因为哪怕暂时还没有良好的德行，我也不想完全的放弃我对于美德的向往。</p><h1 id="傲慢"><a href="#傲慢" class="headerlink" title="傲慢"></a>傲慢</h1><p>OK接下来我们要说的傲慢，傲慢也是一个让公众非常厌恶的品质，我们极其警醒他人的傲慢，并且出于本能的厌恶他人的傲慢，非常有意思。这个播客讨论的三种常见的恶习，残忍、傲慢和虚伪。我刚才说我们不厌恶残忍，但是我们极端的反感虚伪和傲慢。我们几乎本能的就可以发现他人身上的虚伪和傲慢。==我觉得我们对于傲慢的厌恶甚至要更甚于虚伪，因为建立在民主人人平等之上的，人人都可以发声的互联网这种社会的应然是他他的道德准则是人人平等。我们应该平等，我们或多或少应该是一样的，或者至少应该平等的对待彼此。==</p><p>哪怕我们可以容忍差异，但是我们不允许我们的差异能够使一些人凌驾于他人之上。民主社会的特质就是反对任何凌驾于他人之上的特权。有关于傲慢，我想要提出两个我自己的两个方面的观察。我认为傲慢有两种展现形式。==第一种是你对于自己社会地位的一种广泛的傲慢，这种傲慢是广义上的。第二种是你对于具体对象产生的一种具体的傲慢。==</p><p>==我们先从第一种广泛的、广义的傲慢开始讲。不管怎么样，我们可以把傲慢定义为一种优越感。这种优越感它脱离了事物真正的内在价值，它是建立在一种我们认为不公平的外在优势之上的。傲慢之所以使我们感到愤怒，并不是因为我们愤怒于这个人他的优越感本身。我们愤怒的是他的这个优越感的根基是建立在某种不公之上的。我们认为这种根基不应该给予这个人优越感。==</p><p>我给大家举几个最直白的例子。前几天我的好朋友状元姐来找我吃饭。状元姐考了江苏省理科状元之后，就去了香港大学学习。他来我们家吃饭的时候，他跟我说，前几天他在纽约参加港大校友会的时候，遇到了各个年龄阶层的港大毕业生，有他这种三十多岁的，还有70后，甚至还有50后。他跟我说，那个70后的校友在校友会上摆明了他自己是一个精英，是一个纽约律所的管理合伙人，在那个校友会上大放厥词，就是说我的微信我不加合伙人以下的人，我看不起年薪多少数字以下的，我的朋友圈那都是只有华人精英才能够进入我的朋友圈。这是一个有点令人搞笑的傲慢的一个人，对吧？状元姐跟我讲这个故事的时候，她带着一种鄙夷的态度跟我描述这个故事。因为他觉得这个70后在校友校友会上，当着师兄师姐的面，直接就说他看不起低于某个社会阶层的人，或者说那个社会阶层的人不配拥有他的微信，这是一种非常广泛的傲慢。</p><p>第二个故事也是状元姐的故事，我不知道为什么状元姐是混社会的人，所以她认识的坏人比较多。我身边都是身家清白的书呆子，所以见舞蹈这种乱七八糟的人说。云姐跟我说，她公司有一个跟她关系很好的男同事，每天醉生梦死，兴趣爱好就是开着豪车去社交软件上约会漂亮性感的女孩，跟她们发生性关系。 状元姐跟我说，她最匪夷所思的地方就在于这个男同事他一方面可以做着这件事情，另外一方面他真诚的觉得自己是一个传统顾家的好男人，他以后人生的规划就是去找一个单纯的好女孩，年轻漂亮单纯的好女孩，成为他的妻子，组建一个家庭。他对于这个能够成为他妻子的女人的要求也是有一种非常粗暴的，硬性的，关于外貌、年龄、身材和长相的要求，低于这个要求的人他看都不看，我们可以说这也是一种傲慢，对吧？这个男士他在两性关系上对于女人的想象非常傲慢。我刚才举了两个我觉得在社会上非常常见的例子。状元姐跟我说的这两个人都是相对极端的傲慢。我们可以想象到我们身边肯定会有没有那么极端的，但是持有差不多态度的傲慢态度的人。这种傲慢使我们感到自然而然的愤怒。我觉得我们这个社会解决这种愤怒的方式，通常现在是试图去实行更加全面的平等主义。</p><p>==我们拒绝承认任何身份能够给予人在任何层面的优越感，拒绝承认任何人在任何情况下能够在理性基础上产生任何高下之分，拒绝承认我们能够在一切合理的基础上产生合理的优越感。在原则上，我们希望通过这个方法来排除任何人仅仅因为自己拥有过权力或者权威，受过良好的教育，拥有着身高美美貌和浓密的头发，拥有着高薪工作，就可以凌驾于他人之上的这种傲慢。我们希望在原则上可以排除这种人感到优越感的途径，这是一种民主社会的极端平等主义。但是实际上这种极端平等主义在现实生活中它是有点反人性的对吧？==</p><p>哪怕我们想在原则上宣称极端的平等主义，没有人能够因为任何身份就高人一等。==但是人作为一个社会性的生物，我们在社会上大家都能观察到，自然而然的就会形成身份上的高低之分，这是理论上的平等主义没有办法扭转的人性。人性不但会自然而然的对各种各样的身份进行自然的高低之分，人性还有另外一个特征，那就是我们渴望为了我们自己的一些身份感到骄傲，哪怕我们不想要分一个高下。但是骄傲就意味着我们要做一个区分，我们想要为女性的身份感到骄傲，这就意味着如果有选择，我们不会去做一个男的。如果做男的做女的都一样这样的话，那我们为什么要为做女的感到骄傲呢？==</p><p>==骄傲意味着你要对你的身份做一种区分，区别就意味着要做一种隐藏的高下之分。只不过现在很多为自己感到骄傲的人，他捂着耳朵，他自欺欺人，他不承认这是一种高下之分。当我们想要为自己中国人的身份感到骄傲的时候，就一定意味着你不想要做美国人。你不能够再为自己是一个中国人感到骄傲的同时你又是一个美国人。==这不是一个可以并存的东西，因为骄傲意味着一种区分，你为这种区分感到骄傲，你就不能够再为自己是一个同性恋的身份感到骄傲的同时，又渴望成为一个直男。这两种东西是不能够同时存在的这也就意味着在西方非常流行的这种为了某个身份感到骄傲，它其实就是一种高下之分。</p><p>这是一种在隐藏在平等主义躯壳之下的高下区分。他们拒绝承认自己的这种不自洽，他们想要鱼和熊掌兼得。==一方面他们想要呼吁绝对的平等，另外一方面他们又想要为自己感到骄傲。而感到骄傲就必然意味着一种优越感。这是一种你认为你自己所带表的身份背后的价值要高于其他身份，或者说没有身份的一种价值判断。==</p><p>所以我在这里说的这个问题在于什么呢？问题就在于我觉得我们过于极端的想要消灭一切身份特权带来的优越感和随之而来的傲慢。我们消灭了旧的身份特权，但是我们并没有解决这个问题。==在我的眼中，我觉得我们永远都没有办法解决我们根据身份而自然而然感到的一种由衷的自豪和优越感。这种优越感当他达到了一定的极端之后，它的体现方式就会变成傲慢。==消灭了旧的身份特权，我们还会创造新的身份特权。在这里，我想说的是，旧的身份特权和新的身份特权在我眼里并没有理论上的好坏之分，他们都是值得进行公共辩论的。</p><p>我们需要讨论的不是特权应不应该存在，我们要讨论的是特权应该以什么形式存在。什么样的特权是有内在价值的？什么样的特权是不公正的特权？什么样的优越感它是有内在价值的？什么样的优越感它是没有内在价值的优越感。</p><p>比如说我为我是一个中国人感到骄傲、感到自豪这种优越感和我为我是一个有钱人感到骄傲、感到自豪这种优越感，它是明显是有高下之分的。我为我是一个律所合伙投资合伙人感到骄傲、感到自豪，和我为我是一个不婚不育的独立女性感到骄傲、感到自豪，这两种优越感的社会，哪一种是更好的社会？我觉得这是一个很有意思的问题，可能得出来的结论是，这两种优越感都有道理，又都没道理，它背后隐藏的是两种针锋相对的价值判断。==我们很难说拥簇一个价值的社会就要好于拥簇另一个价值的社会。我们值得辩论，应该去反思的不是如何去消灭这个优越感本身。==</p><p>我觉得我们应该去辩论的是这个优越感背后的价值判断。它究竟是一个好的价值判断，他究竟是不是一个正义的价值判断。一个同性恋该不该因为自己是一个同性恋就感到骄傲了？一个律所合伙人该不该因为自己是一个律所合伙人就感到骄傲了？一个有钱人该不该因为自己是一个有钱人就感到高人一等了，一个不婚不育的女性，该不该因为自己是一个不婚不育的女性就感到高其他区服于父权的结婚生子的妻子一等了？张震该不该因为自己是全中国最性感的男人，就感到高其他男人一等了？</p><p>我觉得我们能做的是更加开放的去讨论这些问题。这些问题背后可能是有答案的。他的这个傲慢或者说优越感背后的价值判断是否合理，而不是把手指直接指向这个优越感和傲慢本身，试图直接把它们抹平。这种抹平本身是一件反人性的事情。</p><p>当然真的去说服我一开始举的那两个例子里面那个傲慢的校友和那个傲慢男人是一件很难的事情。听到他们的故事，从我的角度来说，我感受到的更多的不是愤怒，而是有点可怜他们。我想说，如何在这个社会上减少这种不可一世的傲慢之人，义愤填膺的道德谴责，通常没有办法改变这种人。能够改变这种人的社会态度通常是相对普遍的。对于他们的轻蔑和无视，咱们不和知识上的矮子论短长。</p><p>==第二种我想要讲的是更加具体的傲慢。==我刚才说的是一个相对广义的社会上的傲慢，它更像是一个人生态度。但是具体的傲慢是一种我们在生活中经常会碰到的，就事论事的高高在上。我们通常会认为傲慢是强者对于弱者的霸凌，导致强者在这个社会中几乎变成了一个贬义词。==但是我认为，把强者和弱者之间的关系想象成霸凌，是一种现代文明平等的现代秩序全新的现象。在古典秩序中，强者和弱者之间的关系不是霸凌，强者是弱者的保护者，强者是需要为保护弱者承担责任的人。而且在我的经历中，所有具体的傲慢，他几乎全部都是弱者对于弱者的霸凌，弱者对于更弱的人表现出的高高在上，他们的傲慢展露的不是自己的强大，而是自己的弱小。==</p><p>说到这种具体的傲慢，我给大家举一点串在我这个博客中出现的例子。我想专门举一些看似微不足道的案例。比如说我在讲锻炼的那个博客下面，我印象非常清楚的。记得有一次我在那儿说，我说如果你无法做一个俯卧撑的话，你可以选择跪姿俯卧撑。如果做不了跪姿俯卧撑，可以选择靠墙60度斜着做俯卧撑。通过不断的进阶，慢慢的我们就能够达到做俯卧撑的力量。然后再从俯卧撑进阶成更加高阶的。比如说钻石俯卧撑，俯卧撑击掌，结果下面有一位能人志士评论说，如果连一个俯卧撑的力量都没有的话，那确实有点太弱了。</p><p>还有一些同学会在我的博客下留言记录说今天读了刘瑜，有一个什么心得，读了留情，要不就读了韩炳哲，评论一些自己的感悟。每一次都会有人轻蔑的回复，这些回复都被我删了。这些人都会回复说，哲学界的短视频，读这种书说明你还没有深度。还有一些同学最近刚刚读到一个评论，有一个同学参加了道长许知远和鲁豫的线下节目，兴致冲冲的在豆瓣上晒了合照，这个同学给我留言说他配文说自己的五岳文化程度爆表，结果被更傲慢的更有文化的豆瓣网友高高在上的嘲讽，说这就文化了，肤浅。</p><p>这种傲慢的例子我越想越多。我朋友二妹，她是马拉松跑者，她跟我说自己瞎跑的，很开心。一上互联网的朋友圈，充满了各种各样的鄙视链，不管你晒怎么样的配速，都会有人傲慢的跳出来讥讽你的配速在于家圈也能够看到一模一样的情况。在我眼中明明已经练得非常优秀的人，不管晒怎样的瑜伽姿势，下面一定会冒出来一些大师说一年才只能够练手肘倒立水平不行，你这个腰用力不够，推轮才推到这个程度，说明你不够努力。</p><p>我刚才举了这么一大串例子，我就不往下说了。这些小小的案例没有我一开始描绘的这种不可一世的傲慢这么令人愤怒。但是实际上我相信每一个上网的人都经历过我刚才说的，这种傲慢的一种模式。这也是作为一个不是公众人物的普通人，==当我们开始思考互联网的恶意和戾气怎么这么重的时候，最影响我们的就是我刚才举例的这些比较微小的傲慢。我刚才说的这种傲慢不是强者对于弱者的霸凌，这种傲慢是弱者对于弱者的霸凌==。我每次看到这种人，大家知道我在想什么吗？我就在想到孟德斯鸠写那个波斯姓扎那个小说里，他描绘一个在波斯拥有着后宫三千佳丽3000的波斯人来巴黎旅游的故事。</p><p>这个小说主要是孟德斯鸠借着波斯人的视角在嘲讽巴黎，但是他其中有一段很重要的剧情，就是在描绘这个被留在波斯管理后宫佳丽3000的那些个被阉过的波斯太监。孟德斯鸠描绘这些太监非常犀利，这些太监个个都渴望权力，但是他们渴望权力的目的仅仅是为了成为大太监。管事的太监能够骑在其他的小太监头上，骑在其他小太监头上就是权力对于这些人的诱惑，那些个太监拥有了权利，他们不想要真正的去执行权力管理后宫，成为一家之主，他就是想骑在别人头上。</p><p>我举了刚才这些个嘲笑别人的例子。我看到那些嘲笑别人的人，一看到那些人我就会想到波斯信扎里面的太监。为什么呢？==我觉得这种傲慢，这种高高在上，他之所以是最平常的，又是最可笑的。是因为拥有这些态度的人，他们忘记了自己为什么喜欢这个东西，自己为什么享受做这些事情，为什么喜欢跑步，为什么喜欢瑜伽，为什么喜欢读书，为什么喜欢思考。你做这些事情的原因不是因为你能够做的比别人好，而是因为这件事情它本身是一件令人愉悦的事情，它是一件好事。你的愉悦感不是来自于你能够骑在别人头上，成为一个管事太监，这是一种通过残忍才能够获得的愉悦感。愉悦感的来源应该是来自于你做这件事情可以做得更好，你可以跑得更快，你可以通过一些简单的反思，从而去进行更加深刻的反思。==</p><p>只有孟德斯鸠书里的那些太监，因为他们被淹了，没有办法再体会到真正的欲望，真正的野心，他们的自然，他们的人性已经变态了，他们的梦想才会变成成为大太监，骑在小太监头上，从一些本末倒置的事情上得到快感。而且就做好一件事情来说，咱们谁不是一个小虾米。咱们退一步来看，有多少人喜欢跑，不喜欢读书，喜欢思考非常少。</p><p>你带着傲慢的态度去嘲笑其他做的没你好的人，跑的没你快，没有你读的深度的人，没你逻辑缜密的人。这个态度本身体现的是一个最可耻的以残忍为乐的弱者心态。我鄙视这种人的原因，不但是因为他们在嘲笑比他们更弱小的人，并且从这种残忍中获得快感，而且最主要的是他们正在损伤一件在我心中本身可能很有意义的事情，他让其他人不再享受做这件事情了。我在读武侠小说的时候也发现了这个事儿，那就是最傲慢、最不可一世、最有力气，最喜欢霸凌弱者的人，从来都不是真正的大侠，最喜欢霸凌弱弱者的，都是那种比弱者稍微强了那么一点点的弱者。我们应该联合起来，鄙视那些嘲笑弱者的弱者，这种想骑在其他人头上的太监这种人，他们不是强者，他们的傲慢恰恰反映了他们的弱小，因为他们的傲慢是建立在对于他人的残忍之上的，而不是建立在对于更高、更快、更强的渴望之上。</p><p>说到这里，大家也应该听得出来，我这个播客叽里呱啦讲了这么多，并不是在维护虚伪和傲慢。我不是在试图说服大家，傲慢是一件好事儿，虚伪也是一件好事儿。我想说的是，虚伪和傲慢都是人性中平常的一部分。当我们在高声要求别人停止虚伪，停止傲慢的时候，其实我们自己很难躲避同样的指控。我也有我自己的虚伪和傲慢。</p><h1 id="如何抵抗互联网上越来越重的戾气和恶意"><a href="#如何抵抗互联网上越来越重的戾气和恶意" class="headerlink" title="如何抵抗互联网上越来越重的戾气和恶意"></a>如何抵抗互联网上越来越重的戾气和恶意</h1><p>关于我播客一开始提出的这个问题，如何抵抗互联网上越来越重的戾气和恶意？==我觉得我们自己能做的一件事儿，第一件最重要的事儿就是意识到咱们自己也不是个好鸟。虚伪不意味着你是一个两面三刀的小人，傲慢也不意味着你是一个令人鄙夷的狂徒。虚伪和傲慢意味着你是一个人，而意识到这一点，意识到这些不好的品质有多么普通，在每个人身上都可能会出现。可以让我们对他人不要这么残忍，也可以让我们在思想上更加自由。==</p><p>我想说的另外一件事情就是你可能会说，这个博客把一个这么简单的事情说的这么复杂。这个博客把一个看似很简单的事情说得很复杂。没错，这也是我的目的之一。==我想说的是有一些社会上需要达到共识的话题，随着它的复杂化，它反而会变得更加清晰。==这是一种和笛卡尔创建的现代科学相反的人文主义思维。笛卡尔创造的现代科学信奉的是随着事情变得越来越简单，它会变得越来越清晰。 笛卡尔的第一沉思录里说的是clarity和simplicity，简单和清晰是一对相辅相成的东西。但是我认为在社会上需要达到共识的问题上，他遵守的规则是和科学规则恰恰相反的。随着它变得越来越复杂，随着我们能够意识到人性的复杂性，complexity和clarity才是一对。随着我们能够意识到人性的复杂性，人性会变得越来越清晰，我们也会变得越来越温和，越来越不那么偏激。OK今天咱们就说到这儿，我们下期再见吧，拜拜。</p>]]></content>
      
      
      <categories>
          
          <category> 播客笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 播客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 互联网 </tag>
            
            <tag> 独树不成林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自习室 STUDYROMM 47 Q&amp;A 卷王的年终问答，书单推荐</title>
      <link href="/2025/02/24/podcosts/%E8%87%AA%E4%B9%A0%E5%AE%A4%20STUDY%20ROMM47%20Q&amp;A%20%E5%8D%B7%E7%8E%8B%E7%9A%84%E5%B9%B4%E7%BB%88%E9%97%AE%E7%AD%94%EF%BC%8C%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/"/>
      <url>/2025/02/24/podcosts/%E8%87%AA%E4%B9%A0%E5%AE%A4%20STUDY%20ROMM47%20Q&amp;A%20%E5%8D%B7%E7%8E%8B%E7%9A%84%E5%B9%B4%E7%BB%88%E9%97%AE%E7%AD%94%EF%BC%8C%E4%B9%A6%E5%8D%95%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h3 id="在面对海量信息时，如何筛选真正适合自己的内容，并找到自己的节奏和主路线？对于如何高效快速地获取大量信息，并有效利用零碎时间，有什么心得或策略吗？"><a href="#在面对海量信息时，如何筛选真正适合自己的内容，并找到自己的节奏和主路线？对于如何高效快速地获取大量信息，并有效利用零碎时间，有什么心得或策略吗？" class="headerlink" title="在面对海量信息时，如何筛选真正适合自己的内容，并找到自己的节奏和主路线？对于如何高效快速地获取大量信息，并有效利用零碎时间，有什么心得或策略吗？"></a>在面对海量信息时，如何筛选真正适合自己的内容，并找到自己的节奏和主路线？对于如何高效快速地获取大量信息，并有效利用零碎时间，有什么心得或策略吗？</h3><blockquote><p>[!NOTE]<br>我们首先要像节食一样给自己制定一个信息饮食计划（information diet plan），控制对信息的欲望，避免因焦虑而无法专注。建议将80%的时间聚焦于主线阅读，设定明确的目标书单，并坚决执行。对于其他20%的时间，可以被动地接收信息，但要确保这些信息来源是顶尖的。有时候，学会不做某些事情比做更重要，比如减少信息获取，去掉那些对我们无益的信息渠道，更能体现反脆弱性。此外，可以通过构建个人的信息神经元系统，找到各自领域的顶尖知识来源，当有具体疑问时直接向对应专家或渠道提问，形成全面的专家库和知识库。</p></blockquote><p>其实就是比如说咱们Q到反脆弱一下，Q到塔勒布。塔勒布在最开始解释反脆弱这个概念的时候，就假如说有一些习惯是让你脆弱的有一些习惯是让你反脆弱的。他举了一个例子，比如说你想让身体更健康，你可以做两种事情。一种是增加一些习惯，比如说我多吃点什么，我多去吃补剂，抽个血查一个什么，或者我增加一个什么健康的习惯。另外一种就是我减少一些对自己的伤害。</p><p>比如说我减少吃一些垃圾食品，减少吃糖，或者我去掉一个不好的习惯。他说比起增加一个习惯，去掉一个习惯会让你整个人更加反脆弱。这个我其实是很同意的，然后我就想跟这个花卷说，我们其实都活的有点太焦虑了。我们总是看别人的这个，就是拿别人知道的事儿和我们不知道的事比。</p><p>每天其实我也有这个感觉，我都会觉得比如古稀提到一个书我没看过，然后我就会想，那这个书我也得看看，那个书我也得看看。导致我桌上的书，我们家书架上的书和我的这个微信读书，我不知道有没有多少内存，反正就是每天我在读自己的书的时候都很难专注。因为我想的是，我还有这么多书没看，就是哪本书你都没看下去。</p><p>本来你现在应该是专注的把你手里这本书看完，但是你现在手里这本书也没看下去，其他的书你只是花了时间下载，花花了时间去找，但是你也没有读。因为你沉浸在深深的焦虑里面，所以我就觉得那天你说了一个话，我觉得特别对。就是现在在多吃之前，在想我们怎么获取海量信息源之前，我们要先像节食一样给自己制定一个信息diet的plan。</p><p>我们对信息的欲望有的时候和对食物的欲望是一样的。看见甜的东西，看见高热量的东西，就想立刻给吃到嘴里的这种基因。</p><p>其实这么想很有道理，就像你吃东西其实是一种生存焦虑，我们现在迫不及待去鲸吞各种信息，其实也是一种生存焦虑，它只是以不一样的方式呈现出来了。</p><p>对我觉得这都是我们古老身体的本能。因为我们的古老的身体那会儿是在一个食物匮乏的时期，所以你看见食物就想往嘴里放，我觉得这是没毛病的。那会儿你确实你如果看到一个新鲜的信息，你确实是要把它获取的。因为你获取的信息越多，就意味着你生存能力越强。</p><p>但是到现在的这个世界上，我觉得我们既不能任随原始的吃饭的欲望知识，我们也不能任凭着自己获取信息的这个欲望而行事，那样的话你就会消化不良。我现在的法则就是我强行聚焦。就是说我今年的年初的时候给自己设定了三个读书的主题，读书的方向。一个叫运动和营养，一个是心理学，还有一个就是社科类的。就比如说像黑天鹅，像塔勒布，像我们讲过的像一如既往这一类的。</p><p>然后我在每一类图书里都给自己制定了一个非常详细的目标书单，这些书是我今年要恶补的，就在这三个方向。然后这个是定死的，这个占了我80%的时间，系统化的阅读的时间。这个东西无论今天古稀给我推荐一本，我觉得我多该晚上看的书，我不完成我自己的书单的这个任务，我是不去看的。然后甭管今天再见爱人这个节目有多火，好东西，这个电影有多想看，这个东西都是不能动我这个主页的。</p><p>你都要紧紧地抱住你的反脆弱性。</p><p>对我就是要专注其他的20%的时间。我现在对自己要求特别低，只有两个字儿就是掐尖儿。除了这三类以外，其他的我就囫囵吞枣，不求甚解的去获取我觉得比较专业的意见。我在菲弗莱里面讲到古稀对于面包现在是有多懂，然后我又是一个我又想吃好吃的面包，但是我对好吃的面包又一无所知的人。</p><p>每次在我买面包的时候，我现在就强迫自己，要不然就直接问古西，我今天想买一面包，你给我推荐一家，然后你推荐完我就立刻下单，我自己不假思索，不做任何的研究和research。要不然我就打开大众点评买离我最近的，我觉得还OK的，就OK就好。然后现在比如说我今年想知道新闻，那我基本上就是英文博客就听了一两个，然后中文可能就那一个。</p><p>另外我每天早上上厕所的时候，会打开那个财经和财新，就是随便划一划，就他给我推什么，我就看什么。但是我看的这个媒体本身是一个比较trusted。</p><p>你把你的读书也变成一个帕雷托效应的模型。80、20 80是你非常有主线的，你非常有目的的，你就死守的。然后另外的20，就是你反正被动的让这个信息过来流经你，然后你来知道一下这个世界发生了什么。</p><p>然后这个流经的这些东西，你要确保这些渠道都是他所在的那个领域里面最顶尖的对我相信比如说像财经新闻，肯定财新和财经不是覆盖的很全面的那我肯定看的越多对我越有帮助。但是我只有这么一点点时间，所以我就选择放弃。就是我了解那些最重要的大事儿就OK了。然后面包比如说我就fully trust古稀，你可以fully trust吗？对吧？</p><p>就我成本最低的一种方式，要不然我就随便吃，我就放弃了。你总会要放弃很多东西，我到现在都没看好东西。说实话在家爱人我一集都没有看过，你说你想不想知道？然后你跟大家会损失很多话题，我承认，但是你多少你得损失一些。这个就是我觉得我结识的代价，我信息结识的代价，这个代价我就决定承受了。然后另外我还有一个原则，这个是塔勒布教我的，也是来自反脆弱这本书。</p><p>他说了一个观点，他看书不看近期的热畅销书，他只看经过时间验证的经典的书。他拿来看，他觉得这个是最节省时间的，我觉得他好聪明。所以你知道我今年的读书的清单，你看我年末的清单，我给你说过两本，一本叫沉思录，一本叫道德前的对，然后我就觉得这个也是你读书的一种掐尖儿。</p><p>就这些我们刚刚说的像社科，还有脑神经科学的书，我发现其实这些都在十几年前就有的书写的非常之好。所以我们去看经典，确实可能有花卷会问到你们怎么去评判一本书好不好？我想先说的是找的过程中一定可能会遇到不是那么对你胃口的书，那你看了你就气就好了。就像塔勒布讲过的，永远不要去讨厌读书这个行为。你可以讨厌具体某本书，你觉得看了坚持不下去，你把这本书放下，看别的就好了。</p><p>所以你要在这种不停的碰撞的过程中，去摸索出来自己的读书的趣味还有倾向。还要知道你目前你的读书的需求是什么。还有一点是我从你刚刚讲到的，只要你想获得某一个具体的信息，你就找到那个对应的人或者那个渠道。我有一年给我的年度计划里面写了一条叫构建我的信息神经元系统。我记得这事儿，对，就是神经元它就是发送电信号，就会让你产生思想，对吧？</p><p>这是神经元，那神经网络就可以组成你的整个的知识库。为什么叫神经元系统？比如说我作为面包代言人，在你的神经元系统里面就是关于比如说询问像面包、烘焙、发酵这些，我是那个神经元。那对于我来说，我的神经元系统里面也有很多不同的人，他代表着不同领域的我认为最顶尖的知识的来源。所以我就会确保当我有具体的一个疑问的时候，我会去找到那个神经元。</p><p>而所有这些神经元连接起来，第一它们会是我的神经网络。你不知道哪个神经元与另外一个神经元相连，就会产生一个非常迷人的化学反应。第二就是你有非常全面的，我们叫专家系统专家库，可以去询问，可以去请教，然后拿这些东西来反出形成你自己的知识库。所以这是我给自己一个计划。</p><p>所以如果是总结一下给这个花卷的或者花卷们的建议，就是你先找到你最感兴趣的那点，用80%的时间把这个给学透。因为这你感兴趣的，你学的也快，你学的也用心。然后其他的用20%的时间来铺面，怎么铺面的股息给出了很好的解法。掐尖儿和找比如说懂行的人，然后因为你也在某些方面懂行，所以别人跟你在一块儿他愿意跟你分享。</p><h3 id="如何避免信息过度消费带来的焦虑感？"><a href="#如何避免信息过度消费带来的焦虑感？" class="headerlink" title="如何避免信息过度消费带来的焦虑感？"></a><strong>如何避免信息过度消费带来的焦虑感？</strong></h3><p>可以尝试设定主线阅读任务，强迫自己聚焦于核心目标，而不是盲目追求广泛的知识涉猎。同时，对非主线信息采取“掐尖儿”策略，即只关注最权威、最重要的信息源，放弃部分非关键内容。</p><h3 id="应该push自己一把，还是应该放自己一马？"><a href="#应该push自己一把，还是应该放自己一马？" class="headerlink" title="应该push自己一把，还是应该放自己一马？"></a>应该push自己一把，还是应该放自己一马？</h3><blockquote><p>[!NOTE]<br> 自控力最强的人并非仅在自我较量中取得掌控，而是学会接受并融合相互冲突的自我。当面临是否push自己或放松自己的纠结时，应尝试从更高维度寻找解决方案，让冲突的自我形成合力，共同推动自己朝着目标前进。例如，采用“先行动再说”策略，先进行一定程度的活动，再根据实际情况调整强度，以此达成内在自我的和谐统一。</p></blockquote><p>因为咱们其实今年讲过很多，一个是过于push自己的很多很多的不好的地方，一个是又说你永远应该往下卖一个火盆儿。How bad do you want？IT?</p><p>然后我们又告诉大家，你应该找到最小阻力之路。</p><p>对，我们又告诉大家说，意志力是可以锻炼肌肉，越练越强。但有时候又说说这个肌肉你练的太伤了，它就撕裂了。</p><p>然后有时候又说你应该去听你心的声音，因为心是最强的肌肉。</p><p>对，所以这个我承认确实就是那你如何现在制定一个及时的战略，就是我到底是应该push自己，还是应该现在让自己放松下来。我想说的是，其实我今年在自我发现的层面，我觉得有非常大的进步，就今年可以算是我一个开悟的一年。我的自我发现开窍在哪呢？其实来源于我们自习室说过的一句话。</p><p>==这句话叫做自控力最强的人，不是在与自我的较量中获得掌控，而是学会了如何接受相互冲突的自我，并将这些自我融为一体。==</p><p>然后为什么这句话让我开悟了呢？==我原来总是觉得自我之间是矛盾的。比如说有一个自我是其实是想要向前push的，然后另外一个自我是向回拉的那我就要是在这两个自我之间做一个选择。我今天是跟A一头还是跟B一头，我只能跟一头。但是我今年突然发现你的目的其实不是非A或B而是把A和B的力量统一起来，形成一个合力。==</p><p>所以我就想跟这个花姐说，如果这种情况经常发生，比如说你每天都会有一些纠结，我现在到底应该往往前走还是应该往后退？我应该push自己一下还是放自己一马？请你现在向上走一步，从更高的地方看你的这个问题，你会发现其实这个是你冲突的两部分的自我，它就像一对争吵的姐妹。所以你现在应该做的不是说我今天听谁的这么简单的一个决定。</p><p>你需要做的这个决定是如何让她们这俩一对姐妹形成合力，让你往你想往的方向走。我觉得这个才是你应该解决的课题。也是更高阶的一个解法。我在这里也想举几个例子。然后有一个情况，就是我每天早上就在我怀孕之前，我都会要求自己晨练，然后每天早上起来都得下楼跑步。然后这个呢在冬天你也很痛苦，在夏天你其实也很痛苦。</p><p>然后每天你下床的时候都觉得，我是不是有点过牢，最近太累了，我是不是其实今天应该休息，因为你其实每天都不想跑，但是又说我如果今天不跑，我课本又不完不成，那我明天就会更累，反正就是每天都是这么纠结的。就是这一对姐妹每天早上都出现。当时我的一个解法其实受启发于你和邓亚萍的那期，也是邓亚萍那本书叫新丽。</p><p>==他就说无论我想练不想练，我要求自己先到这个体育场先打100个球，然后之后再决定我今天怎么练就如果打完这100个球我觉得好了，那我今天就正常训练。如果我觉得我今天真的越练越难受，那我今天就休息或者我减强度，我就基本上把这句话给实行下来。==</p><p>来了这一年，然后我发现有一个好处是在于，无论你今天最后的决定是跑步了，就是按照课表跑步了，还是我放弃了，我只跑了他100个球，而我其实可能就是3公里。我无论如何我每天都跑了这3公里，这3公里就变成了你的baseline，因为原来你的baseline是零公里。就比如说我我今天准备push自己一把，我跑了5公里，明天决定放自己一马跑了0公里。</p><p>那你一年下来你的平均值是2.5公里。但是执行每天下楼就跑3公里，然后之后再决定自己跑多少，你的这个平均值变成了3公里，比你2.5公里增长了0.5公里。我觉得这个就是你让冲突的自我形成了一个和解。这个多的这0.5公里其实就是那个合力。</p><p>你知道我在这里面我有一个take away，就是所谓的形成合力，也不一定是要让他们同时的向你施加力量，也可以有一个先来后到。比如说像邓亚萍，她的心理里面说了，他的那个观点是叫先无脑挥拍100下。我到了这个场合，我先不要让自己的脑子感受，就是赢家其实靠的直觉，他不思考，他靠的是直觉。</p><p>对，所以你要过去之后，先无脑先把这个练习给练起来，将你的身体给热起来，让热气瘦弱的身体好好的跟你的大脑对话。我从这里面的一个take away，就是有的时候大脑的保护机制会过强，这个时候你应该做两个事儿。第一个是先行动起来，第二个是有一个5秒的法则。因为等了5秒钟之后，大脑就反应过来，这个事儿好难，他就开始下判断了。</p><p>所以在这5秒钟大脑反应过来之前，你就先迅速的开始你的热身，迅速你该做手上的一切的事情，先把他给骗过去。然后你就发现那5秒之后，大脑会重新的进入另外一套计算规则。他会对于对事情的难度的评估，进入一个新的一个原则系统里面去。所以我从这本书和这一期里面，我当时的一个take away，就是所谓冲突的自我，它是可以有先来后到的。</p><p>我先来之前我先来一个蠢蠢的我，聪明的我先后面等一等，他可以等5秒，最后两个人依然是可以很好的共存的。</p><p>你这个让我想到了之前我们做如何对抗暴食，就对食欲的一个最管用的tips。就是你先在你的盘里放你觉得你应该吃的那个portion，吃完了之后无论你饿不饿，你都等十分钟，十分钟之后再判断。因为这个也是你两个自我饱腹感其实是有滞后的。你那十分钟你就觉得我靠我就跟没吃一样，我就是肯定得再吃点甜的。但其实十分钟之后你就不一定再这么想了。</p><p>但是后话就是如果你打完100个球，你的大脑反应过来之后还是觉得很累，或者你在十分钟之后还是觉得很饿，那你该吃就吃，就是你的合力。像我说的三公里总是比2.5公里要长的。</p><h3 id="“不在自己的日子里”怎么做"><a href="#“不在自己的日子里”怎么做" class="headerlink" title="“不在自己的日子里”怎么做"></a><strong>“不在自己的日子里”怎么做</strong></h3><p>对，然后我在这里想多插一句，就是没有人问这个问题。但是我想说的就是如何面对不像自己的时候，我最近因为可能也是真的是孕期你的整个的体能量值，你的疲劳感其实跟原来都是不太一样的。</p><p>而且我每天我现在已经重了四点多公斤，就是你每天都拖着一个比原来沉很多的身体，然后又有点肿什么，就是他不舒服的感觉会越来越多。你就像在你最低谷的那个低谷期，我相信大家都长胖过都状态不好，我都很累过。所以我现在逐渐的就是这方面的感触会很深。原来我很少有那种今天起就想摆烂的那种日子，然后现在这种日子越来越多了。有的时候你真的就是望洋兴叹。</p><p>你看这外边天儿挺好的，你也有计划用，你就累的就是不行，我必须得睡午觉。我上一次跟古稀录那个爱的对谈下棋，我还跟他说，我说姐们我好累，我好困，好难得从你的嘴里听到关于摆烂的话。然后我想跟大家分享一个一句话，叫意志力的死敌是压力。原来我其实老觉得压力是意志力的朋友就觉得在你逼自己的时候，你的意志力应该是最强的。</p><p>然后我今年就是在我觉得不像自己的时候，我现在知道了往往意志力在最强的时候是你自我和解的时刻。前几天我有三天连续每天醒来都觉得特别累，不想动，然后没有行动力。第一天觉得还OK，我第二天就觉得我你怎么还累？你昨天干啥啥都没干，就正常工作什么啥也没干，还特别累。第三天还特别累，然后我既不想运动，工作还特别拖。</p><p>就是我知道我这几天其实应该把这些活干完，但是我就是干不完，就是一直拖。那天就无所事事，就刷出来什么买买东西，收拾家，就随便干点什么，然后这个一天就过去了完晚上看看点电视，然后第四天我们的商务给我打电话说薇娅客户快催死我了，你这东西必须得给我。</p><p>结果我只能当时因为实在没办法了，人家都给你打电话，我就硬着头皮起来就开始弄，结果把那个东西弄完，我咵咵咵咵咵把之前三天欠的活都干完了之后，我还去健了个身。</p><p>你现在是怎么理解了？塔勒布说的应该把活给那个公司里面最忙的人是吧？</p><p>对，然后你就发现就这么无心插柳。就是因为这一个电话，你当时烦的不行，突然一下把这三天的活儿都补上了，你好像也没落下啥。所以我觉得那几天让我感觉说人真是流动的，就是包括你的经历，你的效率和你的人格，在天和天之间可能也真是像我爸原来说的一句老话，叫猫一天狗一天。所以有的时候在你不是你觉得今天怎么那么不张威亚，你越给自己压力你越动不了。</p><p>他只会让你彻底的放弃，会让你摆烂的时间越来越长。但是如果你想到说人真的是流动的，就我的人格，我的能量都是流动的。我可能就像我的月经周期之后的荷尔蒙一样，我就是今天刷一下，高一下，明天低一下。但是我的均值其实是我自己其实当你想到这件事儿的时候，可能往往是你意志力最强的时候。所以我现在给自己的一个tips就是我要在我发现自己今天只能摆烂的时候，先允许自己摆烂。</p><p>就是我往往是滞后的。就比如说我今天应该健身，我给自己制定一个特好的计划。然后到下午的时候发现我今天太累了，我完全动不了。这个等于相当于你被通知分手，就别人告诉你你得分手了，这个时候你就很被动。但是如果在我发现自己今天估计是要摆烂的时候，我先给自己一个允许。就好像你在发现男朋友想跟你分手的时候，主动先跟他分手一样，就是把这个主动权先读回来。</p><p>就是我往往是滞后的。就比如说我今天应该健身，我给自己制定一个特好的计划。然后到下午的时候发现我今天太累了，我完全动不了。这个等于相当于你被通知分手，就别人告诉你你得分手了，这个时候你就很被动。但是如果在我发现自己今天估计是要摆烂的时候，我先给自己一个允许。就好像你在发现男朋友想跟你分手的时候，主动先跟他分手一样，就是把这个主动权先读回来。</p><p>我原来就把自己摁的死死的，不能允许自己原谅自己。因为我觉得我今天一旦开了这个口子以后，我就会每天都原谅自己。然后我是在今年才发现不是这样的。当你原谅自己的时候，也是其他的一切产生张力开始松动的时候，你就会发现它是意志力的土壤，它是绝对可以长回来的。</p><p>你的这个画面让我想起了拔河，就是在拔河的过程中，您的一个很巧妙的技巧是你先送递给他，然后你再使劲往后一拽。</p><p>对你得给他送一点力，让他稍微松懈一下，然后让整个对方的军队发生涣散，因为他不知道该怎么合力了。这个时候送完了之后，使劲再往回一扯，这就是你跟你的意志力和你跟你的目标之间的拔河比赛。</p><p>==所以你松的那一下，在拔河的时候松的那一下，其实就是原谅自己。你不要以为你只要一松那边就取胜了，其实不是这样。你松一下，你往回夸这么一拽你就赢了。是的，所以我再次call back一下这句话叫意志力的死敌是压力。在你已经不像自己的那些日子里，不能死咬，不能拼命就不原谅自己。==</p><p>==一定要把自己往回拽，想象的像拔河一样，先原谅自己，先接受我也有摆烂的这一天，再往回一拽你就成功了。==</p>]]></content>
      
      
      <categories>
          
          <category> 播客笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 播客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 自习室 STUDYROMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纵横四海EP42《如何阅读一本书》：阅读的四个层次，你在哪一层？</title>
      <link href="/2025/02/24/podcosts/%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7EP42%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%EF%BC%9A%E9%98%85%E8%AF%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1%EF%BC%8C%E4%BD%A0%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/"/>
      <url>/2025/02/24/podcosts/%E7%BA%B5%E6%A8%AA%E5%9B%9B%E6%B5%B7EP42%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%EF%BC%9A%E9%98%85%E8%AF%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1%EF%BC%8C%E4%BD%A0%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读的四个目的"><a href="#阅读的四个目的" class="headerlink" title="阅读的四个目的"></a>阅读的四个目的</h1><ol><li><p><strong>资讯</strong></p><p> 资讯主要是用来了解当前发生了什么事的，它是不太涉及到深入的理解或者是长期的影响的。</p></li><li><p><strong>知识</strong></p><p> 知识是在资讯积累的基础上进行分析、筛选、理解，总结出规律经验等等。他最后是变成了规律经验、技能。这个是知识，知识才是用来理解世界和解决问题的。</p></li><li><p><strong>理解力</strong></p><p> 知识和理解力之间的区别：</p><p> 第一个区别就是内化了，变成了我自己的知识。</p><p> 第二个用于实践，就跟举例子有关。你是不是能够举出很多的例子在把这个知识用于实践。</p><p> 这个知识满足了这两个条件，我们就从知识跃升到了理解力。</p></li><li><p><strong>娱乐</strong></p><p> 娱乐我觉得也分成两种，一种如果同时有知识，有尤其是有理解，这个时候我们自然而然会产生一种悟道的快乐。第二种娱乐是我们不涉及到知识，也不涉及到尤其不涉及到理解。我们纯粹就是为了娱乐，纯娱乐去读书。</p></li></ol><h1 id="新媒体能取得阅读的作用吗"><a href="#新媒体能取得阅读的作用吗" class="headerlink" title="新媒体能取得阅读的作用吗"></a>新媒体能取得阅读的作用吗</h1><p>社交媒体正在以压倒性的范泛滥的资讯阻碍我们的理解力。他而且他不但就太多选择，等于没有选择。他拿这些信息的洪流来阻碍我们真正的去理解这些信息背后所蕴藏的社会的规律，世界的规律。</p><p>记忆是思想的残渣，你没有思考你就没有记忆。社交媒体很擅长的一件事情就是不让你思考。它可以把所有的东西都包装在一个非常短的时间之内。告诉你说这个事情就是这样子的，这个道理就是这样子的。我给你分析好了，你只要听我的就可以了，那如果在每每在这种时候我们就被剥夺了思考的机会。如果你不思考的话，其实你是没有真正的记忆，你脑子里面是不会装进去任何东西的。</p><p>所以在这样的大环境中，其实阅读才是我们这个时代捍卫心智的强大的武器。因为它不但提供资讯，它提供理解，它能让我们有能力筛选，它能让我们有能力做出应对。如果我们只是获得资讯不理解，那我们就是书呆子，就是无知的阅读者。</p><p>反过来，如果我们进行好的阅读，我们其实也能够获得资讯。更重要的是我们能够获得知识，而且在这个过程中我们获得了理解力，那我们的心智就会随着阅读而成长。反过来我们在筛选高质量的知识和资讯上，效率都会更高。</p><h1 id="读者的自我修养"><a href="#读者的自我修养" class="headerlink" title="读者的自我修养"></a>读者的自我修养</h1><p>主动阅读就是我们作为读者应该具备的基本素养。这里给大家一个比较可衡量的、可操作的主动阅读的标准。就是什么是主动阅读的核心是你必须要能够回答问题。</p><ol><li>这本书到底在谈些什么？就是这本书的主题。</li><li>作者具体是怎么展开说的？就是他的想法、声明、论点。整个论述的过程就是我有这个主题，然后我是怎么给你讲这个主题的</li><li>你说的有道理吗？你说的是全部有道理还是部分有道理呢？你说的这些事实的前提是真的吗？</li><li>这本书跟我有什么关系？为什么我要获得这些资讯和知识？为什么这本书的观点对作者很重要？那为什么对我也很重要呢？我真的有必要去了解吗？</li></ol><blockquote><p>[!NOTE]<br>基于主动阅读的核心就是提出问题，回答问题。所以我们最好养成一边读书一边记笔记的习惯。<br>一边读书一边记笔记有这么三个好处：<br>第一是笔记会让你保持清醒<br> 第二个好处是主动阅读，它就是一种思考<br> 第三个好处就是把我们的感想写下来，其实能够帮助我们记住作者的思想</p><p>[!NOTE]<br>在做这种主动阅读的笔记中，我们有三种笔记：<br>第一种叫做结构笔记。就是全书架构。这是什么类型的书？这本书的谈的是什么？作者是怎么谈的？<br>第二个是概念笔记，概念指的就是观点，一开始是你可以做作者的观点的总结。渐渐的在这个过程中你会产生自己的观点，所以有时候你要把自己的观点也写上去。<br>第三种叫做辩证笔记，就是针对一个主题，让不同的作者跟你开始展开一场讨论。</p></blockquote><h1 id="阅读的四个层次"><a href="#阅读的四个层次" class="headerlink" title="阅读的四个层次"></a>阅读的四个层次</h1><ol><li><p>基础阅读</p><p> 就是认字儿，学会读懂句子，摆脱文盲的状态</p></li><li><p>检视阅读</p><p> 重点就是在时间，就是一个快读，需要在很短的一段时间之内抓出一本书的重点，它是一种系统化的阅读。</p><p> 检视阅读就是非常快的把它把一本书读一下的过程中，我们要回答这些问题。比如说这本书是讲啥的这本书的架构是什么？这是一本什么样类型的书？</p></li><li><p>分析阅读</p></li><li><p>主题阅读</p><p> 主题阅读中我们会阅读很多本书，而不是一本书，然后并且列举出这些书之间的相关之处</p></li></ol><h1 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h1><h2 id="两种检视阅读"><a href="#两种检视阅读" class="headerlink" title="两种检视阅读"></a>两种检视阅读</h2><ol><li><p>有系统的阅读或者是粗读，最重要的就是掌握主题和架构。</p><ol><li>先读书名，如果有序的话就读序</li><li>读目录，目录是能够快速get一本书的基本内容和架构的</li><li>如果有索引的话，看索引</li><li>如果有的话，就读一下出版方对这本书的介绍</li><li>挑几个跟主题最相关的章节来看</li><li>把剩下的章节大概的翻一下</li></ol></li><li><p>粗浅的阅读</p><p> 从头到尾非常快的读一遍。你碰到不懂的地方你不要停下来，你也不要查，你也不要思考。总之我们就是尽量快速读完，这就是第二种解释阅读。你这快速的读完这一遍，哪怕你只有50%的理解，甚至你只有30%的理解他，你再重新读这本书的时候，都会帮助你增进理解的。可以听书。</p></li></ol><blockquote><p>[!NOTE]<br><strong>多轮复习</strong><br>大脑是联网的，大脑学习是一个滚雪球的过程。如果你第一遍的时候你的雪球非常的小，你指望你再认真。比如说你花2个小时去琢磨一个概念，你其实雪球滚的就是这么点大。然后你要是快速的滚一遍，雪球就起来了。</p></blockquote><h2 id="检视阅读的好处"><a href="#检视阅读的好处" class="headerlink" title="检视阅读的好处"></a>检视阅读的好处</h2><p>检视阅读是为了让我们做好准备，让大脑了解这些信息之后，不但更理解后面的内容，而且大脑会预先找到跟这些内容适配的那个频道。</p><blockquote><p>[!NOTE]<br><strong>读书速度慢</strong><br>他说读书速度慢很多时候并不是一种能力，而是一种习惯。也就是说并不是说这个人读一个字都读一个词需要比别人更多的时间，而是他在读过程中习惯逗留和退行性倒流。<br>改掉这个习惯的一个训练方式就是手指移动法，你要用手指来做光标，当然你在电脑上你就用光真正的光标，你眼睛要跟着你的手指头走你手指移动的速度要比你原先阅读的速度要稍微快一点点。</p></blockquote><h1 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h1><p>分析阅读分成三个阶段，每个阶段它都有不同的规则。</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h2><p>第一我们先分类。第二我们来做一个简短的总结。第三我们要了解全书的架构。第四我们要在这些基础上找出作者问我们的到底是一个什么样的问题。</p><ol><li><p><strong>规则一：读一本书前，先分类</strong></p><p> 不同类别的书适用于不同的阅读技巧，不同的阅读速度。</p></li></ol><div class="table-container"><table><thead><tr><th>小说</th><th>文字小说、绘本漫画类</th><th></th><th></th></tr></thead><tbody><tr><td>非小说</td><td>论述型</td><td>专注在一个主题上给你进行深入的挖掘和探讨</td><td>需要思考，停下来做笔记</td></tr><tr><td></td><td>叙事型</td><td>专注的是一段历史，一个故事、一个体验</td><td>一口气看完</td></tr><tr><td></td><td>浏览型</td><td>摄影集、绘画作品、历史漫画</td><td>合在碎片时间看</td></tr></tbody></table></div><ol><li><p><strong>规则二：用一句或几句话，给一本书做总结</strong></p><p> 想要知道自己是不是真的理解一本书在说什么，最好的测试当然就是说说看了他到底在说什么。这里我们要加一个条件，就是要简洁的说出来。</p></li><li><p><strong>规则三：找到作者用什么架构来阐述主题</strong></p></li><li><p><strong>规则四：作者想问一个什么问题，或者作者要解决的问题</strong></p><p> 比如说超越百岁问的是长寿到底意味着什么呢？我们又要如何达到这种长寿呢？毫无意义的工作可能问的是为什么现代社会激增的狗屁工作会让我们痛苦呢？我们到底应该怎么办呢？</p></li></ol><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h2><p>就是第一阶段的分析阅读是初步了解作者的观点，在这个过程中会形成一些自己的观点，这是一个主动阅读去理解的过程。第二个阶段是在第一个阶段的基础上，一切都在往上拔升一层，就深入理解作者的观念，然后把第一阶段自己产生的那些想法、雏形，真正的去把它形成一个自己的理解。</p><ol><li><p><strong>规则一：和作者同步词义</strong></p><p> 作者的责任是我尽量去避免模糊地带。读者责任是帮助作者跟随他的词语，努力达成成共识。在这个过程中你要超越语言去处理语言背后的思想含义，超越文法去处理文法背后的逻辑。也就是说在沟通中你千万大家千万不要停留在自的表面上，哪怕对方用错了。但凡你能够理解这个意思，你就不要去再纠结这个用词了。</p><p> 你要结合上下文去理解作者不能自己是怎么理解的就怎么理解，你要想到作者是什么意思。</p><p> 永远都要结合上下文来理解，绝对不能够断章取义。</p><p> <strong>不要做以下的事情</strong><br> 第一，不要是听到一个词儿产生了自己的理解，然后就不愿意去努力的试图理解对方想说啥就开始批评对方了。<br> 第二是不做确认，就觉得自己理解的对，然后就开始根据自己的理解去发挥后面的谈话了。</p></li><li><p><strong>规则二：找到作者的主旨（结论）</strong></p><p> 们可以通过常见的推理的逻辑的架构来找到这个结论。通常结论要不然就是现在一个推理的最前面，要不然就出现在一个推理的最后面。</p></li></ol><pre><code>**结论是否找对的测试方法**第一种测试方法是用自己的话说一遍。最重要的是要用自己的话，非常朴素的把这个道理讲出来。但凡你不能用自己的话把这个道理讲出来，你就没有找对作者的结论，或者你没有理解作者的结论。第二个测试就是举一个例子。你能不能基于它的结论举出一个你生活中观察到的例子。你举不出例子来，那你就是在玩弄文字，你只是把作者的文字玩弄而已，你没有自己的理解。</code></pre><ol><li><p><strong>规则三：这个结论背后的完整论述是什么</strong></p><p> 到我们的结论概括了我们的整个argument，但是我们不能够只看结论，我们必须要把它结合在一起，看这个argument我是怎么逻辑推理一度到达这个结论的。当你这样做的时候，你就真正理解了作者在说什么。</p><p> 我们看一下整个逻辑中哪些是提供背景信息的，哪些是前提，哪一句是结论。找到结论，你找到前提，接下来用你自己的思想，用你自己的头脑，用你自己的琢磨去把中间的这个逻辑给构架起来。这个就是你找到argument，找到论述的过程。</p></li><li><p><strong>规则四：作者的提出的问题都解答了吗？他是怎么解答的呢？还有哪些问题没有解答呢？</strong></p></li></ol><h2 id="第三阶段（如何写评论，才是有礼节）"><a href="#第三阶段（如何写评论，才是有礼节）" class="headerlink" title="第三阶段（如何写评论，才是有礼节）"></a><strong>第三阶段（如何写评论，才是有礼节）</strong></h2><p>公正的去评断一本书。</p><p>主动阅读不会因为已经了解了一本书在做什么，在说什么而停下来。你必须要能够对这本书提出评论或者是提出批评，才能够算完成。</p><p><strong>受教是一种美德</strong><br>受训：如果你没有自己的判断力，你就没有办法学到任何东西。那么你其实是在受训，而不是在受教。<br>受教和学习一样，都是一种极为主动的美德，而不是卑躬屈膝，而不是照单全收。所以受教的意思是我主动的要去跟作者进行交流。在这个对话中，当然就是既然你要评论，你要批评，那么我们还是要有一种批评的礼节在的。</p><ol><li><p><strong>规则一：我了解了</strong></p><p> 具体来说就是在你能说在你说出我同意我不同意或者是我暂缓评论之前，你一定要非常肯定的说我了解了。如果我们不了解，就没有办法说我们同意还是不同意。</p><p> ==本书的作者说这种时候你要是不是遇到瞎评论，你可以请他用他自己的话复述一遍你的观点。如果第一他复述不出来，就说明他根本就不了解你在说什么，此时你就不要理会这种批评了。==</p><p> ==以微博为例，如果我在微博上搜一个博主够久的话，我总会看到那么一两个帖子是我不认同的这有什么关系呢？就是人跟人之间的多元性反而是精彩的一部分。你对这个人的评判是经过很多很多帖子下来，以我对他的价值观、道德观、世界观有一个基本的评判。所以当他偶尔说出一些好像似乎不符合你对他价值观的认知的话的时候，我们要迟至少要迟疑一下，而不是马上反应。我们至少要问自己说，这是因为我过去识人不清，还是因为他就人人人无完美，人总是有时候可能会说错话？==</p></li><li><p><strong>规则二：不要进行无理的争论</strong></p><p> 就是不要争强好胜，非辩到底不可。我们只要达成了一定的沟通，那么我们就可以保留各自的观点，对吧？我了解了你，你了解了我，咱们在有些事情上无法达成共识，咱们就不要再争下去了。</p><p> 越讨论我们越能够解决其中的一些问题，这个过程我觉得就是持续讨论下去都是没有问题的。但是如果说我们每一轮的讨论都在兜圈子，都在同一个问题上，就是互相各执己见，那就没有必要再继续下去了。</p></li><li><p><strong>规则三：区分主客观，也就是尊重知识和个人观点之间的不同。</strong></p><p> 在你做出任何论断之前都要找到理论依据。我觉得这条的意思其实就是说区分自己到底是在表达喜好，还是在进行观点的交流。</p><p> 爹和不爹之间的区别在于，你到底是想要教别人做事儿，还是纯粹的在讲你的东西。</p></li></ol><h1 id="如何写批评，才是有礼节"><a href="#如何写批评，才是有礼节" class="headerlink" title="如何写批评，才是有礼节"></a>如何写批评，才是有礼节</h1><p>当你批评的时候，你必须要至少做到以下四点钟的一点：</p><ol><li><p>你必须拿出你的观点之后，你要证明作者的知识不足</p><p> 你不能单纯的说你没有考虑到叉叉叉，这是很不礼貌的话。要说全了，你必须要说你没有考虑到叉叉叉，这个叉叉叉为什么对你的这个东西是有结论受影响的。</p></li><li><p>或者你要证明作者的知识错误</p></li><li><p>或者你要证明作者不合逻辑</p><p> 这本书的作者说一般有两种荒谬，一种是缺乏连贯，另外一种作者说是前后矛盾。</p></li><li><p>或者最后你要证明作者的分析和理由他不完整</p><p> 对我们的要求太高了，通常你需要高于作者，然后你才能够说你其实你只回答了一部分，你没有回答另外一部分。</p></li></ol><p>在批评的过程中也要注意，不是只讲出这些东西就可以了。你必须要证明自己的结论，就是人人都负有证明自己结论的义务。</p><blockquote><p>[!NOTE]<br>我说在无声大雅的情况下，口音是一种文化的体现，多文化的体现，是一种个人特色。这种情况下你没有必要揪住口音不放，因为它不影响你的理解。只有当它影响你的理解的时候，我们提出口音问题来是完全OK的。</p><p>[!NOTE]<br>总之大家一定要知道，在平时的沟通中也是一样，你们不能揪住一个小错误不放，遮住小错误不放的人就是扫兴者，就非常的扫兴。因为这个错误对整体事件、对结论、对论述没有什么大的影响。那人无完人，为什么一定要揪住这些小错误不放呢？揪住小错误不放的行为是一种社会地位竞争的行为。我通过对你错误的指出和打压，造成一种我的社会地位的上升。不管你怎么，只是明意识里面是怎么样的，潜意识就是这样的行为，这是一种非常粗鲁和不礼貌的行为。</p></blockquote><h1 id="辅助阅读的方法"><a href="#辅助阅读的方法" class="headerlink" title="辅助阅读的方法"></a>辅助阅读的方法</h1><ol><li><p><strong>相关经验</strong></p><ol><li><p>一般经验</p><p> 一般经验就是我们日常例行正常生活的经验，就是人生阅历</p></li><li><p>特殊经验</p><p> 超越了一般人生活经验的那一些。比如需要通过科学实验来证明，或者说医生写的一些临床的经验。</p></li></ol></li><li><p><strong>其他书</strong></p><p> 那个作者可能会有写其他主题的书，加在一起同一个作或者一起看，其实你会对他有很大的理解。</p></li><li><p><strong>导读与摘要</strong></p><p> 作者的建议是尽量不要使用。</p></li><li><p><strong>工具书</strong></p><p> 字典、百科全书什么的，也可以使用AI工具。</p></li></ol><h1 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h1><p>加起来意思就是说我有一个主题，我要找到相关的书，然后我要找到这书里面相关的章节，然后我要把作者的所有的作者搞出来，先同一个语言，然后我要我要我要决定他们应该讨论哪些问题，然后我要让他们讨论，讨论完了之后我还要加一瓶。就相当于你组织了一个论坛，然后把这整个论坛所有的事情作为一个组织者全都干了。</p><p>五个步骤：</p><ol><li><p><strong>找到相关的章节</strong></p></li><li><p><strong>引领作者跟你达成共识</strong></p><p> 也就是说现在我们不能用作者的语言了，因为我们现在是横跨不同的书。因此你要像一个协调者一样，在不同的书中把所有的语言协调成你的语言。</p></li><li><p><strong>厘清问题</strong></p><p> 比如说我们以爱为主题，那么我们会有一系列的小问题，就是厘清这个问题是你的第三个步骤。比如说什么是爱呢？好，我们爱的艺术可以回答这个问题，为什么爱这么重要呢？这种能力一般是怎么来的呢？自卑与超越可以回答这个问题，如果缺失了爱这个能力会发生什么呢？</p><p> 你要提出一系列你关心的问题，然后你要找出不同的书去回答这些问题。</p></li><li><p><strong>界定</strong></p><p> 就是要找出作者持有不同观点或者不同论述方法来阐述的主题</p></li><li><p><strong>分析讨论</strong></p><p> 好，这个议题界定了之后，我们要去分析评判不同作者的论述观点。</p></li></ol><blockquote><p>[!NOTE]<br>改良的版本</p><ol><li>在你已经读过的书里挑选一个或者几个吸引你的主题</li><li>看到跟这个主题相关的书，你就优先阅读</li><li>当你读了一些这里面的书的时候，你就要尝试开始把作者带到一起。这个步骤简单的来说就是知识卡片，我们讲过知识卡片就是选择一个主题，在里边把你读到的那些内容都写进去就好了。 </li></ol></blockquote><h1 id="五个收获"><a href="#五个收获" class="headerlink" title="五个收获"></a>五个收获</h1><ol><li><p>今天我们了解了怎么阅读一本书之后，我们才会减轻阅读的负担</p><p> 要质量好，读几遍都OK，质量远远高于数量。</p><p> 不要觉得读书是一件原来这么有负担，这么累的事情，反而应该非常兴奋的发现说，原来我用了这些方法之后，我能够快速的得到心智的提升。</p></li><li><p>主动阅读是关键的关键，越主动阅读效果越好。</p></li><li><p>阅读是一项技能</p><p> 我阅读能力不行，我不聪明。我觉得这些其实都是不是就是都没有站不住脚，都不合理。阅读就是一项技能，你只能说我现在这个技能比较低。那么通过我们今天给了这么具体的方法的锻炼，你就可以把这的技能给连起来。</p></li><li><p>对于做读书笔记这件事情就更清晰了</p><p> 第一我们可以用一句话来总结所有的书。第二我们可以给想要做进一步笔记的书回答四个问题。这书说啥的，他是咋说的，说的有道理吗？那我的感想是什么？也就是跟我有啥关系。同时我们也知道了怎么做知识卡片，它就是一种改良型的主题阅读，对吧？如果这些笔记都能够变成输出，那就更好了。</p></li><li><p>可以在今天的基础上做出一张终身书单</p></li></ol><h1 id="三个作业"><a href="#三个作业" class="headerlink" title="三个作业"></a>三个作业</h1><ol><li>第一，开始你的主题阅读。</li><li>第二，给三本书做评论。</li><li>第三，建立你的终身书单。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 播客笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 播客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 纵横四海 </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<style>.profile-card {  width: 300px;  border-radius: 10px;  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);  text-align: center;  padding: 20px;  background: #fff;}.profile-card img {  width: 50%;  border-radius: 10px;}.profile-card h3 {  margin: 10px 0;  font-size: 20px;}/* 进度条美化 */.progress {  height: 8px;  border-radius: 5px;  background: #ddd;  overflow: hidden;  margin: 5px 0;}.progress-bar {  height: 100%;  border-radius: 5px;  background: linear-gradient(to right, #4CAF50, #81C784);}</style><h1 id="💡-About-Me"><a href="#💡-About-Me" class="headerlink" title="💡 About Me"></a>💡 About Me</h1><div class="profile-card">  <img src="/about/img/avatar.jpg" alt="Ouyiz">  <h3>Ouyiz</h3>  <p>🎓 <strong>本科在读</strong></p>   <p>📌 <strong>软件工程 → 数字媒体技术</strong></p>  <p>🌱 <strong>MBTI：INFJ</strong></p></div><hr><h2 id="🎨-兴趣爱好"><a href="#🎨-兴趣爱好" class="headerlink" title="🎨 兴趣爱好"></a>🎨 兴趣爱好</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">现在喜欢</button><button type="button" class="tab">曾经喜欢</button></div><div class="tab-contents"><div class="tab-item-content active"><ul><li>📚 <strong>科普文</strong>：希望可以更了解世界，更了解人。  </li><li>🖼 <strong>图片拼贴</strong>：看到好看的图就想二次创造。  </li><li>📖 <strong>看小说</strong>：喜欢种田、末世、星际文，在小说中体验多样世界。  </li><li>🚶‍♀️ <strong>散步</strong>：观察世界，听歌或播客。  </li><li>🌫 <strong>发呆</strong>：喜欢思绪乱飞。  </li></ul></div><div class="tab-item-content"><ul><li>✂ <strong>折纸</strong>：可按教程折纸，但不具备创造力。后因没地收纳放弃。  </li><li>🧶 <strong>钩织</strong>：除复杂细小外都钩，可按教程完成，但不具备创造力。后因太费时而不常钩织。  </li><li>✍ <strong>写字</strong>：曾喜欢练字，后因懒得练放弃。  </li><li>📖 <strong>散文</strong>：曾热爱，后来更喜欢科普文。  </li><li>🎨 <strong>画画</strong>：曾学过，但懒得深造最终放弃。  </li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><hr><h2 id="💻-专业技能"><a href="#💻-专业技能" class="headerlink" title="💻 专业技能"></a>💻 专业技能</h2><h3 id="📌-编程语言"><a href="#📌-编程语言" class="headerlink" title="📌 编程语言"></a>📌 编程语言</h3><p><strong>C++</strong>：🟢🟢🟢🟢⚪（熟练）<br><strong>Java / C#</strong>：🟢🟢🟢⚪⚪（有经验）<br><strong>Python</strong>：🟢🟢⚪⚪⚪（偶尔使用）  </p><h3 id="🎯-开发技能"><a href="#🎯-开发技能" class="headerlink" title="🎯 开发技能"></a>🎯 开发技能</h3><ul><li><strong>OpenCV</strong>：较熟练，能独立实现基本图像处理任务。  </li><li><strong>OpenGL</strong>：学过但不喜欢用。  </li><li><strong>Unity</strong>：较为熟悉，可进行基本开发和项目搭建。  </li><li><strong>前端开发</strong>：有一定经验，但不算精通。  </li><li><strong>后端开发</strong>：较为熟悉，能够完成常规开发任务。  </li><li><strong>数据库</strong>：学过但忘了一些。  </li><li><strong>数据结构与算法</strong>：掌握链表、树、图等数据结构，熟悉排序、动态规划等常见算法。  </li><li><strong>深度学习</strong>：了解神经网络相关知识，能搭建基本模型。  </li><li><strong>PPT</strong>：经常制作，具备较强的排版与展示能力。  </li><li><strong>AI工具</strong>：熟练使用AI工具</li></ul><hr><h2 id="📂-项目经历"><a href="#📂-项目经历" class="headerlink" title="📂 项目经历"></a>📂 项目经历</h2><p>🚧 <strong>懒得写了，等待补充</strong> 🚧  </p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>书籍</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="2025阅读书籍"><a href="#2025阅读书籍" class="headerlink" title="2025阅读书籍"></a>2025阅读书籍</h1><div class="gallery-group-main"><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/24/cpplatform_gres5pbjpfjjyokardywds/t6_cpplatform_gres5pbjpfjjyokardywds1731407053.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">一生之敌</div>      <p>史蒂文·普莱斯菲尔德</p>      <a href="/books/%E4%B8%80%E7%94%9F%E4%B9%8B%E6%95%8C"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/52/cpPlatform_4Mb2DKkCB8DL4NhctbsKb6/t6_cpPlatform_4Mb2DKkCB8DL4NhctbsKb6.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">手机大脑</div>      <p>安德斯·汉森</p>      <a href="/books/%E6%89%8B%E6%9C%BA%E5%A4%A7%E8%84%91"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/64/cpplatform_qpqefbrrjjgqq7t62wt1ca/t6_cpplatform_qpqefbrrjjgqq7t62wt1ca1706772686.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">控糖革命</div>      <p>杰西·安佐斯佩</p>      <a href="/books/%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/86/YueWen_920661/t6_YueWen_920661.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">你是你吃出来的</div>      <p>夏萌</p>      <a href="/books/%E4%BD%A0%E6%98%AF%E4%BD%A0%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/98/YueWen_43697528/t6_YueWen_43697528.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">我们为什么要睡觉</div>      <p>马修·沃克</p>      <a href="/books/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%9D%A1%E8%A7%89"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://wfqqreader-1252317822.image.myqcloud.com/cover/9/41626009/t6_41626009.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">贪婪的多巴胺</div>      <p>[美]丹尼尔·利伯曼[美]迈克尔·E.朗</p>      <a href="/books/%E8%B4%AA%E5%A9%AA%E7%9A%84%E5%A4%9A%E5%B7%B4%E8%83%BA"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/outpic/509/3000085509.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">见树又见林</div>      <p>Allan Johnso</p>      <a href="/books/%E8%A7%81%E6%A0%91%E5%8F%88%E8%A7%81%E6%9E%97"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://wfqqreader-1252317822.image.myqcloud.com/cover/55/35425055/t6_35425055.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">阅读浪漫小说</div>      <p>珍妮斯·A.拉德威</p>      <a href="/books/%E9%98%85%E8%AF%BB%E6%B5%AA%E6%BC%AB%E5%B0%8F%E8%AF%B4"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/37/cpplatform_tobcl6czhsgmbz2fs5yfab/t6_cpplatform_tobcl6czhsgmbz2fs5yfab1676874509.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">大脑喜欢听你这样说</div>      <p>杰瑞德·库尼·霍瓦斯</p>      <a href="/books/%E5%A4%A7%E8%84%91%E5%96%9C%E6%AC%A2%E5%90%AC%E4%BD%A0%E8%BF%99%E6%A0%B7%E8%AF%B4"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://cdn.weread.qq.com/weread/cover/61/cpPlatform_41LTnhXnaf2pYWQrSdFUwN/t6_cpPlatform_41LTnhXnaf2pYWQrSdFUwN.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">毫无意义的工作</div>      <p>大卫·格雷伯</p>      <a href="/books/%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%B7%A5%E4%BD%9C"></a>    </figcaption>  </figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main"><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">壁紙</div>      <p>收藏的一些壁紙</p>      <a href="/Gallery/wallpaper"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">漫威</div>      <p>關於漫威的圖片</p>      <a href="/Gallery/marvel"></a>    </figcaption>  </figure><figure class="gallery-group">    <img class="gallery-group-img no-lightbox" src="https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg" alt="Group Image Gallery">    <figcaption>      <div class="gallery-group-name">OH MY GIRL</div>      <p>關於OH MY GIRL的圖片</p>      <a href="/Gallery/ohmygirl"></a>    </figcaption>  </figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>播客推荐</title>
      <link href="/podcasts/index.html"/>
      <url>/podcasts/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为本人听过的觉得好的的推荐</p></blockquote><h1 id="纵横四海"><a href="#纵横四海" class="headerlink" title="纵横四海"></a>纵横四海</h1><p>非常推荐，人类使用说明书</p><div class="podcast-group-main"><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP10《毫无意义的工作》：ChatGPT们能让我们脱离996吗？</div>      <p>无笔记</p>      <a href="https://music.163.com/program?id=2526678948"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP27《大脑喜欢听你这么说》：教你操控自己的大脑</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=2526670910"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP28《大脑喜欢听你这样说》：操控大脑第二弹</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=2526705955"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP37《大脑想要这样学》：从今天起，不再学得像个NPC</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=2533244351"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP38《时间贫困》：一个人的时间花在哪里，是看得见的</div>      <p>有笔记</p>      <a href="/podcasts/%E6%97%B6%E9%97%B4%E8%B4%AB%E5%9B%B0"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP41《超越百岁》：如何在100岁的时候，还能去滑雪？</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=2540180543"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP42《如何阅读一本书》：阅读的四个层次，你在哪一层？</div>      <p>有笔记</p>      <a href="/podcasts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">EP51《从零开始的女性主义》：什么是女性主义？+ 聊聊《再见爱人4》</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3064890234"></a>    </figcaption>  </figure></div><h1 id="自习室-STUDYROMM"><a href="#自习室-STUDYROMM" class="headerlink" title="自习室 STUDYROMM"></a>自习室 STUDYROMM</h1><p>非常推荐，可以学到很多知识</p><div class="podcast-group-main"><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">02 卷王的年终复盘| 没有比进步，让我觉得更性感的事了</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=2536594018"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">34 贪婪的多巴胺｜你并不是真正地喜欢，你只是想征服</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3061294821"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">47 Q&A｜卷王的年终问答+书单推荐</div>      <p>有笔记</p>      <a href="/podcasts/%E8%87%AA%E4%B9%A0%E5%AE%A447"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">52 我们为什么吃太多？｜无痛减重：关于食欲的科学与技巧</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3071184676"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">54 高效能人士的七个习惯｜忘掉"被迫"和"目标"，搭建属于自己的原则系统</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3072234093"></a>    </figcaption>  </figure></div><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><div class="podcast-group-main"><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">西西弗高速 10.《哪吒2》重塑影史纪录，是否也重塑了反叛者形象?|Newsletter</div>      <p>无笔记</p>      <a href="https://www.xiaoyuzhoufm.com/episode/67bb335f05a90dfd0d55443a"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">西西弗高速 09.2024年度舆论事件盘点:“分裂才刚刚开始</div>      <p>无笔记</p>      <a href="https://www.xiaoyuzhoufm.com/episode/67963a6dd74435e4a3e77d77"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">独树不成林 98-如何抵抗互联网上越来越重的戾气和恶意？</div>      <p>有笔记</p>      <a href="/podcasts/%E7%8B%AC%E6%A0%91%E4%B8%8D%E6%88%90%E6%9E%9798"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">独树不成林 167-黑格尔会如何嘲笑洋抖难民？</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3070511385"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">别任性 161期|从吴柳芳到邵艺辉，谈怎么才是一个“够格”的女权主义者</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3069943167"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">特刊 何为女主：她，决定了这个故事如何书写</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3068770690"></a>    </figcaption>  </figure><figure class="podcast-group">    <img class="podcast-group-img no-lightbox" src="/../../img/white.png" alt="Group Podcast Image">    <figcaption>      <div class="podcast-group-name">除你武器 049｜围剿“坏女人”：为什么爱女，却恨具体的女人？</div>      <p>无笔记</p>      <a href="https://music.163.com/#/program?id=3068197088"></a>    </figcaption>  </figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>你是你吃出来的</title>
      <link href="/books/%E4%BD%A0%E6%98%AF%E4%BD%A0%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84/index.html"/>
      <url>/books/%E4%BD%A0%E6%98%AF%E4%BD%A0%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：很推荐<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>大脑喜欢听你这样说</title>
      <link href="/books/%E5%A4%A7%E8%84%91%E5%96%9C%E6%AC%A2%E5%90%AC%E4%BD%A0%E8%BF%99%E6%A0%B7%E8%AF%B4/index.html"/>
      <url>/books/%E5%A4%A7%E8%84%91%E5%96%9C%E6%AC%A2%E5%90%AC%E4%BD%A0%E8%BF%99%E6%A0%B7%E8%AF%B4/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：很推荐<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我们为什么要睡觉</title>
      <link href="/books/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%9D%A1%E8%A7%89/index.html"/>
      <url>/books/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%9D%A1%E8%A7%89/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：推荐<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>一生之敌</title>
      <link href="/books/%E4%B8%80%E7%94%9F%E4%B9%8B%E6%95%8C/index.html"/>
      <url>/books/%E4%B8%80%E7%94%9F%E4%B9%8B%E6%95%8C/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><aside>📗### 概括这本书</aside><p>本书定义了内阻力，说明了它的特点与症状。并指出，与内阻力作战的方式就是成为职业选手。</p><aside>📘### 我的感想</aside><ul><li>对于我们灵魂进化，越是重要的召唤或行动，追求它时遭遇的内阻力就越大。因此请向与内阻力相反的方向行动。</li><li>就在这一刻，我们可以改变我们的生活。从来没有哪个时刻，也永远不会有那么一刻，让我们不具备改写命运的力量。这一秒，我们可以在内阻力面前反败为胜。所以请不要拖延。</li><li>当你发现自己在批评别人，那很可能就是内阻力作祟。当我们看到别人开始活出真实的自我，而自己却做不到时，那是足以让我们发疯的。请少批评别人。</li><li>他知道，任何一份工作，无论是小说创作还是厨房改造，所需要的时间都会是他预想的两倍，代价也是两倍。他接受这一点。承认这就是现实。在计划中，请压缩时间，因为所需要的时间都会是他预想的两倍。</li><li>通过在技术的前门苦练，就能为天才留出从后门进入的空间。</li><li>我可以是“我自己”股份有限公司。我可以每周一开一次会，检查工作与花销。肯不把打击归结为个人。</li></ul><aside>📙### 希望的改变</aside><p>与内阻力作战，成为职业玩家，留在牌桌上。</p><aside>📒### 卡片笔记</aside><ul><li><p><strong>前言</strong></p><p>  有一个秘密，真正的作家知道，想成为作家的人不知道。这个秘密就是：难的并不是写作。而是坐下来开始写。<br>  阻止我们坐下来的，是内阻力。</p><p>  我们中的大多数人都有两个人生。我们正在活的，和从来没有活过的。在两个人生之间的，就是内阻力。</p><p>  内阻力是这个星球上最有毒的一股力量。比起贫穷、疾病和勃起功能障碍，它才是我们不幸福的根源。</p><p>  每个太阳都投下阴影，天才的阴影就是内阻力。与我们的灵魂对自我实现的感召一样强大，阻碍自我实现的内阻力也如此强大。</p></li><li><p><strong>第一章 内阻力 定义敌人</strong></p><p>  任何为了长远发展、健康或坚持正直而拒绝即时满足的行为。或者换一种说法，任何源于我们的更高本性而不是低级本性的行为。其中的任何一个都会引发内阻力。</p><ul><li><p>内阻力的特点</p><ol><li><p>内阻力是看不见的</p><p> 它是一种排斥力，是负面的。它的目的是把我们推开，分散我们的注意力，阻止我们投入工作。</p></li><li><p>内阻力是内在的</p><p> 内阻力不是外围对手。内阻力来自内部，它是自我生发和自我延续的。内阻力是内在的敌人。</p></li><li><p>内阻力是阴险的</p><p> 只要能阻止你工作，内阻力什么话都会说。它会作伪证、捏造、篡改；勾引、恐吓、哄骗。内阻力总是在撒谎，总是在胡说八道。</p></li><li><p>内阻力不依不饶</p></li><li><p>内阻力冷漠无情</p><p> 内阻力并不只针对你一个人。它不知道你是谁，也不在乎。内阻力是一种自然的力量。它客观地行事。</p><p> 虽然让人感觉满怀恶意，但实际上，内阻力的运作就像雨一样冷漠，遵循着与星星一样的规则，穿过天空。</p></li><li><p>内阻力无懈可击</p><p> 就像漂浮在油面上的磁针，内阻力总会不偏不倚地指向正北方——那里有它最想阻止我们回应的召唤或采取的行动。<br> 经验法则：对于我们灵魂进化，越是重要的召唤或行动，追求它时遭遇的内阻力就越大。</p></li><li><p>内阻力是普世存在的</p></li><li>内阻力永不眠</li><li><p>内阻力是动真格的</p><p> 内阻力的目标不是伤害或致残。它瞄准的是杀戮。它的目标是我们存在的核心：我们的天才，我们的灵魂，我们被投放在这地球上时被赋予的独特而无价的天赋——除了我们之外，没有其他人拥有。</p></li><li><p>恐惧是内阻力的食粮</p><p>内阻力本身并没有力量。它拥有的每一盎司营养都来自我们自身。我们用对它的恐惧来喂养它，让它获得力量。控制恐惧，我们就能战胜内阻力。</p></li><li><p>内阻力只单向设障</p><p>内阻力只阻碍我们从低领域向高领域的运动。</p></li><li><p>内阻力在终点线前最强大</p><p>当终点线在望时危险最大。到了那一刻，内阻力知道我们即将击败它。它按下了紧急按钮。组织了最后一次攻击，用它所拥有的一切猛击我们。</p></li><li><p>内阻力会招募盟友</p><p>通常，夫妻或亲密的朋友，甚至整个家庭，都会进入一种心照不宣的协议模式，每个人都会（不知不觉地）尽力确保自己和所有亲朋好友困在同一个坑里，他和他所有的亲友就那样躺在坑里，无比舒适。一只螃蟹所能犯下的最严重的叛国罪，就是跳上桶口的边缘。</p></li></ol></li><li><p>内阻力的症状</p><ol><li><p>内阻力与拖延</p><p> 拖延是内阻力最常见的表现，因为它最容易被合理化。</p><p> 拖延最大的害处是，它可能成为一种习惯。我们不只是今天拖延生命——我们可以一直拖延到死。<br> 永远不要忘记：就在这一刻，我们可以改变我们的生活。从来没有哪个时刻，也永远不会有那么一刻，让我们不具备改写命运的力量。这一秒，我们可以在内阻力面前反败为胜。</p></li><li><p>内阻力与性</p><p> 当然，并非所有的性都是内阻力的表现。根据我的经验，可以通过事后空虚的程度来判断。你越感到空虚，就越能确定你真正的动机不是爱，甚至不是欲望，而是内阻力。<br> 毫无疑问，这一原则也适用于判断嗜药、购物、自慰、电视、八卦、酒精，以及所有含有脂肪、糖、盐或巧克力的食品的消耗。</p></li><li><p>内阻力与故障</p><p> 我们让自己陷入麻烦，因为它是一种能够吸引注意力的廉价方式。</p><p> 任何通过无痛苦或人为手段吸引注意力的行为都是内阻力的表现。</p><p> 对他人残忍也是内阻力的一种表现形式，同样，甘愿忍受他人的残忍也是。</p></li><li><p>内阻力与戏剧化人格</p><p> 有时我会把内阻力看作是圣诞老人的邪恶双胞胎。他挨家挨户巡视，确保一切尽在掌握。当来到一户沉迷于自我戏剧化的人家门外，他红润的脸颊容光焕发，放心地驾着八只小驯鹿拉的雪橇车转身离开。他知道，在这座房子里，不会有任何工作能完成。</p></li><li><p>内阻力与自我治疗</p><p> 注意力缺陷障碍，季节性情感障碍，社交焦虑障碍。这些不是疾病，而是营销策略。医生没有发现它们，文案却发现了。营销部门发现了。制药公司也发现了。<br> 抑郁和焦虑可能是真的。但也可能只是内阻力作祟。<br> 当我们用药物来掩盖我们灵魂的呼唤时，我们就是优良的美国人，模范的消费者。我们所做的，正是电视广告和物质主义流行文化从我们出生起就不断给我们洗脑并灌输的事情。不是运用自知、自律、延迟满足和努力工作来治愈自己，而是简单地买样东西就好。</p></li><li><p>内阻力与受害者情节</p><p> 生病，对一个人的存在而言具有重要意义。一种疾病，一个需要背负的十字架。有人不断生病，一种病好了，另一种又来了。这种疾病本身就成了一件艺术品，一个创造性行为的影子版本，受害者花费大量心血培育他的病症，从而规避从事真正有创造性的工作。</p><p> 受害者迫使他人来拯救他；以避免病情恶化/崩溃/精神分裂为理由，挟持他人按照自己的意愿行事；又或者，只是简单地以会让他人生活陷入悲惨境地为威胁，逼迫他人去做他想要做的事。<br> 将自己塑造成受害者跟投入工作是对立的。不要这样做。如果你正在这样做，停下来。</p></li><li><p>内阻力与配偶的选择</p><p> 有时，当意识不到自己的内阻力时，我们会选择一个已经或正在成功克服内阻力的人作为伴侣。</p><p> 也许我们相信（或者希望我们能相信），如果我们能在周围徘徊足够长的时间，我们配偶的力量就会对我们产生影响。</p><p> 如果我们是提供支持的伴侣，难道不应该面对自己的失败，去追求自己未曾活过的人生，而不是指望搭配偶的顺风车吗？如果我们是被支持的伴侣，难道不应该走出爱人崇拜的光环，鼓励他/她自己发光发亮吗？</p></li></ol></li><li><p>内阻力与不快乐</p><p>  内阻力带给人的感觉是什么？<br>  首先，不快乐。我们感觉像在地狱里一样。低级的痛苦充斥着一切。我们无聊，我们不安。我们不能得到任何满足。我们心有负疚，却找不到原因。我们想回到床上，我们想起床玩乐。我们觉得不被爱也不值得被爱。我们满心憎恶。我们讨厌我们的生活。我们恨我们自己。<br>  如果纾解不了，内阻力就会上升到让人难以忍受的地步。在那一刻，恶习开始滋生。嗑药、通奸、沉溺网络。<br>  除此之外，内阻力还会转变成临床疾病。抑郁、攻击性、功能障碍。然后是实实在在的犯罪和肉体上的自我毁灭。</p><p>  棘手的是，我们生活在一种消费主义文化中。消费主义文化能够敏锐地察觉到这种不快乐，并且迅速聚集起它所有逐利的炮火来利用这种不快乐。它售卖产品，售卖药物，售卖消遣。</p><p>  我们拔掉电网插头，因为我们已经认识到，把可支配收入贡献给“狗屎股份有限公司”来完成它的底线目标，这永远无法疗愈我们的不安，唯一的办法，只有工作。</p></li><li><p>内阻力与原教旨主义</p><p>  每个人都会问同样的问题：我是谁？我为什么在这里？我的生命的意义是什么？<br>  在更早期的原始进化阶段，人类不必面对这样的问题。在原始状态、野蛮状态、游牧文明、中世纪社会、部落和氏族中，一个人的位置是由所在群体的诫命决定的。随着现代性的出现（从古希腊人开始），随着自由和个人概念的诞生，这类问题才日益凸显。</p><p>  艺术家和原教旨主义者出现在社会的不同发展阶段。艺术家是高级模式。他们的文化丰裕而稳定，拥有充足的富余资源，让他们能够奢侈地进行自我审视。艺术家立足于自由，他不害怕自由。他是幸运的，出生在正确的地方。有自信的内核，对未来充满希望。他相信进步和进化。他的信念是：无论经历多少波折，有过多少不完美，人类始一个更美好的世界前进。</p><p>  原教旨主义是无力者、被征服者、流离失所者和被剥夺者的哲学。它的发源地是政治和军事失败的残骸——古巴比伦人被囚禁期间，希伯来原教旨主义兴起；美国重建期间，白人基督教原教旨主义出现在美国南部；第一次世界大战后，优等种族的概念在德国衍生发展。在那样绝望的时代，如果没有恢复希望和自豪感的学说，被征服的民族就会灭亡。</p><p>  但原教旨主义者将他最大的创造力都用在了塑造撒旦的形象上，那是他的敌人，而不是定义自己的生命并赋予其意义。和艺术家一样，原教旨主义者也会面对内阻力。他体验到的是犯罪的诱惑。原教旨主义者的内阻力是邪恶的召唤，试图引诱他放弃他坚守的美德。</p>  <aside>  **原教旨主义**（Fundamentalism）最初是用来描述基督教的一种运动，后来逐渐扩展到其他宗教和思想体系中。它指的是一种回归**原始教义**、坚守**传统信仰**的思想倾向，通常具有强烈的**排他性**和**抗拒现代化**的特征。  </aside><p>  正如苏格拉底在很久以前已经证明了的，这其中似乎存在一个悖论：真正自由的个体，只有在他能够自我约束的范围内才是自由的。而不愿自我管理的人，则注定要找到主人来管理自己。</p></li><li><p>内阻力与批评</p><p>  当你发现自己在批评别人，那很可能就是内阻力作祟。当我们看到别人开始活出真实的自我，而自己却做不到时，那是足以让我们发疯的。<br>  活出了自我的个体几乎从不批评他人。如果他们开口说话，一定是为了鼓励。小心。在内阻力的诸多表现中，大多数只会伤害我们自己，但批评和冷酷却会伤害他人。</p></li><li><p>内阻力与自我怀疑</p><p>  自我怀疑可以成为我们的盟友。因为它是抱负的指标。它反映了爱与渴望，对我们梦想的事情的爱，对实践这件事的渴望。如果你突然发现自己开始自省（或询问你的朋友）：“我真的算是一个作家吗？我真的是一个艺术家吗？”很大概率上，你就是。冒牌的创新者总是极度自信，而真正的那位却心虚得要命。</p></li><li><p>内阻力与恐惧</p><p>  恐惧是好事。跟自我怀疑一样，恐惧也是一个指标。恐惧告诉我们，什么是必须做的。</p><p>  记住我们的经验法则：越是害怕一份工作或召唤，我们就越能确定，它是我们必须做的。<br>  内阻力被体验为恐惧；恐惧的程度相当于内阻力的强度。因此，我们对某一特定事业的恐惧越大，就越能确信该事业对我们和我们的灵魂成长很重要。这就是为什么我们会感到如此强烈的内阻力。如果它对我们毫无意义，就不会有内阻力出现。</p></li><li><p>内阻力与爱</p><p>  内阻力与爱成正比。如果你感到巨大的内阻力，恭喜你，这意味着那里也有巨大的爱。如果不喜欢这个让你害怕的项目，你不会有任何感觉。爱的反面不是恨，是冷漠。你经受的内阻力越大，那尚未呈现的艺术/项目/事业对你来说就越重要，当你最终做到时，就越能感到满足。</p></li><li><p>内阻力与成为明星</p><p>  夸张的幻想是内阻力的表现之一。他们是业余爱好者的标志。职业选手早已懂得，成功和幸福一样，都是工作的副产品。职业选手专注于工作本身，至于奖励来还是不来，听其自然就好。</p></li><li><p>内阻力与孤立</p><p>  有时我们因为害怕孤单而不敢着手于某项事业。身在部落之中时，我们感觉很安心。而孤身一人走进森林，则会让我们紧张。<br>  然而，问题在于：我们从不孤单。一旦走出营地篝火笼罩的范围，缪斯女神就会像蝴蝶一样停在我们的肩头发光。充满勇气的行为必将唤起我们内心深处的那个部分，它会支持我们，支撑我们。</p></li><li><p>内阻力与孤独</p><p>  朋友们有时会问：“你一整天自己坐着不觉得孤独吗？”起初，听到自己回答“不”似乎很奇怪。但很快我就意识到，我并不孤独。我在书中，和角色们在一起。我在与我自己共处。</p></li><li><p>内阻力与治愈</p><p>  我们到底在试图治愈什么？运动员知道，永远不会有那么一天，他醒来时没有疼痛。他必须一直带着伤病比赛。<br>  记住，我们以为需要治愈的那部分，并不是我们创造力的来源，后者要深刻、强大得多。<br>  需要治愈的只是我们的个人生活。个人生活与工作无关。<br>  内阻力热爱“治愈”。它知道，我们越是耗费精神能量来一而再、再而三地试图疏导个人生活中遭遇的那些烦人又乏味的不公，就越是没法积攒起足够的能量去做我们本该做的工作。</p></li><li><p>内阻力与支持</p><p>  我们从有血有肉的人那里得到的一切支持，都不过是大富翁游戏里的钱——在我们必须工作的那个领域里，它并非法定货币。事实上，越是花费精力汲取同事和爱人的支持，我们就会变得越虚弱，越没有能力处理我们自己的事情。</p><p>  唯一的例外是，如果你有一位也在拼尽全力的战友，如果能够帮助或鼓励他或者她，那倒是不妨与之分享。</p></li><li><p>内阻力与合理化</p><p>  合理化是内阻力的左膀右臂。它的任务是让我们免于羞耻。毕竟，如果我们真能意识到自己是怎样一个逃避天赋使命的懦夫，是会感到羞耻的。</p></li><li><p>内阻力与合理化防御</p><p>  内阻力不希望我们这样做。所以它招来了合理化。合理化是内阻力的代言人，会帮助它掩饰藏在身后的大棒。它不展示我们的恐惧（这可能会让我们感到羞耻，进而促使我们去做我们的工作），而是为我们提供了一系列看似中肯、合理的正当理由来解释，为什么我们不应该去做我们的工作。</p></li></ul></li><li><p><strong>第二章 与内阻力作战 成为职业选手</strong></p><ul><li><p>职业选手和业余爱好者</p><p>  有志于从事艺术创作却被内阻力击败的人都有一个共同点。他们都像业余爱好者一样思考。他们还没有成为职业选手。</p><p>  需要明确的是：我这里说的“职业”，并不是从事医生和律师等“职业”的人。我所说的“职业选手”是一种理想。“职业选手”的对比项是“业余爱好者”。想想其间的区别吧。</p><p>  在我看来，业余爱好者意味着对这项活动还不够热爱。如果足够热爱，就不会只把它作为一种副业来追求，与他的“正职”区分开来。<br>  职业选手则不然，他们如此爱它，以至于不惜为它奉献一生。他无时无刻不投入其中。</p><p>  内阻力讨厌我们成为职业选手。</p></li><li><p>职业选手</p><p>  毛姆还推测出了另一个更深刻的真相：通过坐下来开始工作这样一个平凡的身体动作，他启动了一系列神秘却精准无误的事件，从而引来了灵感，就像女神校准手表，与他的实现了同频共振一样。<br>  他知道，只要动手去做，她就会到来。</p></li><li><p>我们都是职业选手</p><p>  就本职工作而言，我们都是某个领域的职业选手。</p><p>  究竟是什么特质使我们被定义为职业选手？<br>  ① 我们每天都会出现。这或许只是因为我们不得不如此，不然就会遭到解雇。无论如何，我们做到了。每天都出现。<br>  ② 无论发生什么，我们都会出现。无论生病还是健康，哪怕天崩地裂，我们还是会跌跌撞撞地走进工厂。这或许只是为了不让同事失望，或是出于其他不那么高尚的原因。但是我们做到了。无论发生什么，我们都会出现。<br>  ③ 我们整天都在岗位上。我们的脑子可能会走神，但身体仍在工作。当电话响起时，我们接电话。当客户寻求帮助时，我们帮助他。直到下班铃响起才回家。<br>  ④ 我们致力于长远发展。明年我们可能会换另一份工作，另一家公司，另一个国家。但我们仍将继续工作。直到中彩票之前，我们都是劳动力的一部分。<br>  ⑤ 对我们来说，利益是巨大且真实的。这关乎生存、养家糊口、教育孩子。关系到吃饭。<br>  ⑥ 我们接受劳动报酬。我们来这不是玩儿的。我们为钱工作。<br>  ⑦ 我们不会过分共情自己的工作。我们可能会为自己的工作感到自豪，可能会熬夜，周末也用来加班，但我们会意识到，我们自身不等同于我们工作的内容。反之，业余爱好者过度认同他的业余爱好、他的艺术抱负。他以此来定义自己。他是音乐家、画家、剧作家。内阻力最喜欢这样。内阻力知道，业余作曲家永远写不出他的交响乐，因为他对成功期望太高，对失败太过恐惧。业余爱好者把它看得太重了，以至于无法行动。<br>  ⑧ 我们精通工作的技艺。<br>  ⑨ 我们对自己的工作葆有一份幽默感。<br>  ⑩ 我们在现实世界中受到赞扬或指责。</p></li><li><p>因热爱而战</p><p>  澄清一点有关职业精神的问题：职业选手接受金钱报酬，但他也的确是因热爱而工作。他必须热爱它。否则就不会出于自由意志而甘愿将一生奉献给它。</p><p>  然而，职业选手已经懂得，太多的爱可能反倒是坏事。太多的爱会让他窒息。因此，职业选手看似态度冷漠，举止冷血，其实都只是补偿的手段，防止他太过于热爱这场游戏，以至于止步不前。为了钱上场，或者说，采取为钱上场的态度，可以降低狂热。</p><p>  你越热爱你的艺术/使命/企业，完成它对你的灵魂进化就越重要，因此，你就越害怕它，面对它时感受到的内阻力也就越大。为了钱上场，回报并不是钱（即使成为了职业选手，也可能永远都赚不到钱）。其中的好处在于，为钱上场能够培养出正确的职业态度。它灌输了一种像午餐饭盒一样的心态，一种风雨无阻、无论白天黑夜都会出现在工作岗位上的死原则、死脑筋、硬着头皮上的心态，让你能够日复一日地与内阻力死磕到底。</p><p>  记住，缪斯喜欢勤奋工作的人。她讨厌恃才傲物的家伙。对众神来说，最大的罪不是强奸或谋杀，而是骄傲。把自己想象成一名雇佣兵，一把被雇佣的枪，这会让你保有适当的谦卑。它能够洗去骄傲和自以为是。</p><p>  原则上说，职业选手是收钱的。更确切地讲，职业选手为报酬工作。但归根结底，他所做的一切都是出于热爱。</p></li><li><p>职业选手是耐心的</p><p>  内阻力鼓动我们一头扎进某个项目，制定出一份雄心勃勃却不切实际的时间表。它知道我们无法维持这样的强度。我们会碰壁。会崩溃。</p><p>  职业选手用耐心武装自己，不仅是为自己的职业生涯留出从容的时间，还能够控制自己，在任何一项工作中都不至于因为过载而功亏一篑。他知道，任何一份工作，无论是小说创作还是厨房改造，所需要的时间都会是他预想的两倍，代价也是两倍。他接受这一点。承认这就是现实。</p><p>  职业选手会在一个项目启动之初就做好准备，提醒自己，这是阿拉斯加的狗拉雪橇比赛，而不是六十码短跑。他懂得保存能量。做好了打持久战的思想准备。他始终知道，只要能让哈士奇们一直向前，雪橇迟早能够抵达终点诺姆。</p></li><li><p>职业选手寻求秩序</p><p>  职业选手不能这样生活。他有任务在身。他不会容忍混乱。只有消除现实世界里的混乱，他才能消除脑海中的混乱。他希望地毯是用吸尘器吸过的，门槛是打扫干净的，这样，缪斯才有可能进来，而不必担心弄脏她的长裙。</p></li><li><p>职业选手去神秘化</p><p>  职业选手将自己的作品视为手艺，而非艺术。这并不是因为他们觉得艺术缺乏神秘的维度。恰恰相反。他们明白所有创造性的努力都是神圣的，只是并不纠结于此。他们知道，想得太多只会让自己束手束脚。所以他们专注于技艺。职业选手精通“如何做”，将“做什么”和“为什么做”留给众神。就像萨默塞特·毛姆一样，职业选手不坐等灵感到来，他们只管行动，同时心怀期待，希望它出现。</p><p>  业余爱好者的标志是对神秘的过分赞美和痴迷。<br>  职业选手则会闭嘴。她不谈论它。她只管做她的工作。</p></li><li><p>职业选手与恐惧同行</p><p>  业余爱好者相信他必须首先克服恐惧，然后才能开始工作。职业选手知道恐惧永远无法被克服。他知道世上没有无所畏惧的战士和不战战兢兢的艺术家。<br>  亨利·方达的做法是，在更衣室的马桶间里吐完，然后整理干净，走上舞台。他仍然害怕，但他逼迫自己强忍恐惧，继续前进。他知道，一旦投入行动，恐惧就会消退，他会没事的。</p><blockquote><p>让我想到播客自习室中提到的先开始做10分钟，而不是等到恐惧消散</p></blockquote></li><li><p>职业选手不找借口</p><p>  职业选手学到的更多。他尊重内阻力。他知道，无论借口多么合理，只要今天屈服了，明天屈服的可能性就会是今天的两倍。<br>  职业选手知道，内阻力就像电话销售，只要你回应一句“哈喽”，就完了。职业选手压根儿不接电话。他只是埋头工作。</p></li><li><p>职业选手不抱怨环境</p><p>  职业选手在现实世界中处理他的业务。逆境、不公、糟糕的跳槽、令人不适的电话，乃至于好的突破和幸运的反弹，共同组合成了这片战场，战役必将在这里打响。职业选手知道，一马平川的赛场只会出现在天堂。</p></li><li><p>职业选手准备充分</p><p>  职业选手会在心理上做好准备，消化打击，并将它们输出。他的目标是接受每一天带给他的一切。他做好了谨慎和鲁莽的两手准备，在必要时挨打，在有机会时直击要害。他明白，战场每天都在变化。他的目标不是胜利（成功会在它愿意的时候自己到来），而是尽可能坚定、稳定地控制住自己，驾驭自己的内心。</p></li><li><p>职业选手不炫技</p><p>  职业选手的作品自有它的风格，这是他自己的，与众不同。但他不会用风格来哗众取宠。他的风格是为素材服务的。他不会把风格当作吸引关注的手段。</p></li><li><p>职业选手致力于掌握技艺</p><p>  职业选手致力于掌握技艺，并不是因为他相信技艺可以替代灵感，而是希望在灵感到来时自己已经做好准备，掌握了全部技能。职业选手是狡黠的。他知道，通过在技术的前门苦练，就能为天才留出从后门进入的空间。</p></li><li><p>职业选手与“乐器”保持距离</p><p>  职业选手总是与他们的“乐器”保持距离——这里的“乐器”，指的是他们的人，他们的身体、声音、天赋；是他们在工作中需要调动的肢体、心理、情感和心理状态。他们不认为自己等同于这件“乐器”。这只是上帝赐予他们的工具，他们必须与之合作。他们会冷静、客观、不带个人偏好地去评估它。<br>  职业选手认同的，是自己的意识和意愿，而不是意识和意愿所操纵的、为他们的艺术而服务的东西。麦当娜难道会穿着锥形胸罩和充满性邀请意味的紧身胸衣在家里走来走去吗？她忙着计划她的登陆日呢。麦当娜不会认为自己等同于“麦当娜”。麦当娜雇用“麦当娜”。</p></li><li><p>职业选手不将失败（或成功）归于个人</p><p>  进化在我们的胆魄里织进了对拒绝的敏感。部落就是这样，通过驱逐的威胁来强制成员服从。害怕被拒绝不仅仅是心理问题，它是生物学的。它深植于我们的细胞里。</p><p>  内阻力了解这个，并利用它来对抗我们。它利用对被拒绝的恐惧来麻痹我们，阻止我们行动：只要不完成我们的工作，就不用接受公众的评价。</p><p>  职业选手不会把被拒绝看作是针对个人的行为，因为这势必会增强内阻力。编辑不是敌人，评论者也不是敌人。内阻力才是敌人。战争发生在我们自己的大脑中。我们不能让外界的批评——哪怕它说得都对——来强化我们内部的敌人。那个敌人已经足够强大了。</p><p>  职业选手告诫自己，要与作品保持距离，哪怕那是他们心血的结晶。《薄伽梵歌》告诉我们，我们只有劳动的权利，没有要求劳动果实的权利。</p><p>  职业选手热爱工作，会全身心地投入其中。但他们时刻记得，工作不等于他们自身。他们的艺术自我里包含着许多作品和许多表演。下一个作品已经开始在他们心中酝酿。下一个会更好，再下一个会比下一个更好。职业选手选择自我认证。他们意志坚强。无论面对冷漠还是吹捧，他们都能冷静、客观地评估自己的作品。不够好的地方，下次改进。好的地方，再接再厉，下次要做得更好。他们会更加努力。明天，他们还会回来。</p><blockquote><p>我就是一个害怕批评的人，这段我要好好思考。</p></blockquote><p>  职业选手倾听批评，从中学习、成长。但他们从未忘记，内阻力也会利用批评，从更加恶劣的层面上打击他们。</p></li><li><p>职业选手扛得住逆境</p><p>  职业选手能够忍耐逆境。他听任鸟粪溅落在他的油布雨衣上，心里知道，只要拎起水管，开大了水，就能冲洗干净。他自身才是他创作的核心，哪怕鸟粪堆成了山，他也不能被埋葬。他的内核是防弹的。除非他自己允许，否则任何东西都触碰不到它。</p><p>  职业选手会一直盯着甜甜圈，而不是中间的洞。他们会提醒自己，就算是在斗牛场上被公牛踩伤，也胜过站在看台上，或躲在停车场里。</p><blockquote><p>这让我想到自习室说的：留在牌桌上</p></blockquote></li><li><p>职业选手自我认证</p><p>  业余爱好者会因为他人的负面意见而变得怯懦。他把外界的批评放在心上，让它压倒了对自己和工作的信念。内阻力喜欢这个。</p><p>  伍兹所做的是，保持对这一时刻的掌控权。他明白，无论外部对他送来了怎样的阻碍，他始终有自己的工作要做，此时此刻，他要做的就是好好击出这一球。他知道，他仍然有能力打出这一击。除非他自己选择纠缠于情绪化的不安，否则就没有什么能阻挡他。</p><p>  职业选手不能允许用他人的行为来定义自己的现实。明天早上，评论者就会离开，写作者却依然要面对新的空白页。除了坚持工作之外，什么都不重要。只要没有出现家庭危机，没有爆发第三次世界大战，职业选手就会继续出现，随时准备为众神服务。</p><p>  记住，内阻力巴不得我们把掌控权让渡出去。它希望我们将我们的自我价值、身份、我们存在的理由都建筑在他人对我们工作的反应之上。内阻力知道，我们承受不了这个。没人承受得了。</p><p>  评论者是内阻力的不自知的喉舌，因此可能是真正狡猾和有害的。他们可能在评论中灌注毒液，就是那种内阻力早已在我们自己的头脑中调制出的毒液。这是他们真正的罪恶。我们相信的并不是他们，而是我们自己心中的内阻力，就此而言，评论者也不过是内阻力的不知情的代言人。<br>  职业选手学会了识别因嫉妒而生的批评，并将其视为最高的赞美。评论者最痛恨的无非一点，如果有足够的勇气，他本可以自己上场做那些事情。</p></li><li><p>职业选手看得到个人局限</p><p>  职业选手有经纪人，有律师，有会计师。她知道，自己只能在一件事上成为职业选手。于是引入其他的职业选手，尊重他们的专业。</p></li><li><p>职业选手重新发明自己</p><p>  作为艺术家，我们为缪斯服务，而缪斯需要我们在一生中完成的工作可能并不止一种。<br>  职业选手不会允许自己墨守一个状态，无论多么舒适或成功。就像转世的灵魂，抛开旧的身体，换上新的。然后继续他的旅程。</p></li><li><p>职业选手能认出彼此</p><p>  职业选手能感觉到谁付出了时间，谁没有。</p></li><li><p>你与公司</p><p>  我可以是“我自己”股份有限公司。这样我就有了两顶帽子。我可以雇佣自己，也可以解雇自己。我甚至可以大肆吹嘘自己，就像罗宾·威廉姆斯曾经谈到的那些剧作家兼制片人一样。</p><p>  让自己成为一家公司（或者只是这样看待自己）可以强化职业精神，因为它将创作具体作品的艺术家和凭借着意愿、意志操持事业的艺术家分开了。无论前者的头上落下多少辱骂，后者都可以泰然处之，继续工作。反之，面对成功时，身为写作者的你可能会头脑发热，但作为老板的你总会记得，如何让自己收敛一点。</p><p>  我每周一都会和自己开一次这样的会议。我坐下来，检查我的工作任务。然后把它打出来，发给自己。我有公司文具、公司名片和公司支票簿。我核销公司开支，缴纳公司营业税。我为自己和公司准备了不同的信用卡。<br>  如果我们把自己视为一家公司，就能在我们和我们自己之间留出一段健康的缓冲距离。我们会不那么主观。不把打击归结于个人。我们可以更冷血；也可以更现实地为我们产出的商品定价。有时候，作为某某某本人，我太好说话，以至于不好意思走出去推销。但作为某某某股份有限公司，我甚至能为自己拉皮条。我不再是我了。我是“我”股份有限公司。</p></li><li><p>穷追不舍</p><p>  为什么当我们成为职业选手时，内阻力会屈服？因为内阻力是个仗势欺人的家伙。内阻力本身没有力量，它的力量完全来源于我们对它的恐惧。哪怕是最弱小的笨蛋，只要能够坚持立场，仗势欺人者也会退缩。<br>  职业精神的本质在于：当我们工作时，只专注于工作和工作的相关需求，不计其余。</p></li><li><p>没有神秘可言</p><p>  成为职业选手并不神秘。这是一个由意愿主导而做出的决定。我们下定决心把自己视为职业选手，并付诸行动。就这么简单。</p></li></ul></li><li><p><strong>第三章 超越内阻力 更高的领域</strong></p><ul><li><p>接近神秘</p><p>  因为，只要我们能够每天都坐下来，不断地“磨”，一些神秘的事情就会开始发生。齿轮开始转动。在这个过程中，上天必定、必然会对我们伸出援手。会有看不见的力量加入我们的事业进程，会有意想不到的好运加持我们最终的目标。<br>  这也是一个只有真正的艺术家才知道的秘密，止步于“想成为创作者”的人不会知道。每一天，当我们坐下来，开始工作，便会有力量聚集在我们周围。缪斯会注意到我们的奉献。她赞赏这样的奉献。于是，我们赢得了她的青睐。坐下来工作时，我们仿佛变成了吸引铁屑的磁铁，想法纷至沓来，洞见不断累积。<br>  正如内阻力在地狱占有一席之地，创造力栖身于天堂。它不仅仅是一位见证者，更是热心又积极的盟友。</p></li><li><p>继续召唤</p><p>  古希腊人解读“神秘”的方式是将其拟人化。古人感知到世上存在着强大的原始力量。为了便于理解，他们赋予了这些力量以人的面貌，称它们为宙斯、阿波罗、阿佛洛狄忒。美洲印第安人也感知到了同样的“神秘”，却选择以泛灵论的形式表达——熊老师、鹰使者、狼骗子。</p></li><li><p>“开始”的魔力</p><p>  当我们认真构想一项事业，直面恐惧许下诺言，奇妙的事情就会发生。胎膜上出现了裂隙，就像小鸡在蛋壳内啄出的第一道裂缝。天使助产士们聚拢过来，帮助我们的自我诞生——那个我们生来就该是的人，那个写在我们灵魂中的命定的人，我们的魔王，我们的天才。<br>  当我们“开始”，我们便踏上了自己命定的道路，天使得以进来，履行他们的职责。现在，他们现在可以对我们说话了，这让他们欢喜。神也欢喜。正如布莱克或许早就告诉我们的，“永恒”打开了通往时间的大门。<br>  我们就是那道门。</p></li><li><p>“继续”的魔力</p><p>  组织的原则植根于自然。混沌本身自有组织。恒星在原始的无序中找到了轨道；河流天然知道要如何奔向大海。</p></li><li><p>拉戈</p><p>  我知道了，鸟是不可能从天空中掉下来的——它要做的只是展开双翼，坚实的空气自然会托住它。</p><blockquote><p>这句话太美了</p></blockquote><p>  那些你以为什么都不是的东西，就像这没有重量的空气，实际上都是强大而坚实的力量，和土地一样真实，一样扎实可靠。<br>  我明白了。那只鹰是在告诉我，梦、幻象、冥想，所有这些我一直以来轻视为虚妄幻想的东西，和我清醒人生中的万事万物一样，真实、坚实。</p><p>  显然，是某种看不见的智慧创造了它，赋予它鹰的模样，方便我理解它想要传达的究竟是什么。这种智慧一直在呵护着我。一直那么简单明了。如此清晰、浅显地讲述它的意思，即便是我这样迟钝、浑噩的人也能理解。</p></li><li><p>生与死</p><p>  当一个人得知自己罹患晚期癌症，那一刻，他的心理会发生深刻的变化。他坐在医生办公室里，会突然意识到什么才是真正重要的。六十秒前看来还无比要紧的事情突然变得毫无意义，与此同时，一些人和那些他之前一度忽视的关切则瞬间超越了一切。</p><p>  荣格告诉我们，“自我”是心理的一部分，是我们以为的“我”。是我们有意识的智能部分。是我们每天思考、筹谋、演绎日常生活的那个大脑。<br>  而“自性”，按照荣格的定义，是一个更大的存在，它包括自我，也包括个人无意识和集体无意识。梦想和直觉来源于自性。无意识的原型安居其中。荣格认为，那是灵魂的领域。<br>  汤姆·劳克林认为，在我们得知自己可能很快就会死亡的那一刻，我们的意识便发生了位移。<br>  它从自我走向自性。<br>  站在自性的视角，世界是全新的。我们立刻就能看出什么才是真正重要的部分。浮于表面的烦扰消失了，取而代之的，是更深刻、更深入本质的视界。</p></li><li><p>自我与自性</p><p>  这一节说说我的想法。我认为天使在自性中安家，而内阻力在自我中立足。<br>  这是它们之间的战斗。<br>  自性希望导向创造与进化。自我安于现状。</p><p>  “自我”是心灵中相信物质存在的部分。<br>  它的职责在于处理现实世界的事务。这是一项重要的工作。我们没有一天能离得开它。但现实世界之外还有其他世界，这就是自我陷入困境的缘故。</p></li><li><p>体验自性</p><p>  自性的边界与神域相接。那是神秘，是虚空，是无尽智慧与意识的源头。<br>  梦来源于自性。奇思妙想由自性而来。冥想时，我们能够进入自性。斋戒、祈祷、追寻愿景时，我们所追逐的也是自性。当苏菲派教士旋转起舞时，当瑜伽修行者吟唱时，当印度教苦行僧伤残身体时，当天主教苦修士跪行百里时，当美洲原住民在太阳舞中刺穿皮肉时，当城外的孩子们吞下药丸狂欢起舞彻夜不休时，他们在寻找自性。无论哪种方式，只要是我们故意改变知觉意识，就是在试图寻找自性。当酒鬼倒在阴沟里，那个对他说“我会救你”的声音便来自自性。</p><p>  自我厌恶自性，因为当我们将意识置于自性中时，自我就被排除在外了。<br>  自我不希望我们进化。自我操控当下。它喜欢一切都安于现状。<br>  引领我们走向艺术的本能，是进化、学习、提高和提升知觉意识的冲动。自我厌恶这一点。因为我们越清醒，就越不需要自我。</p><p>  自我产出内阻力，攻击觉醒的艺术家。</p></li><li><p>恐惧</p><p>  是的，事实的确如此。但吊诡的是，当我们飞上太空，并不孤单。相反，我们会被带入一个永不熄灭、永不枯竭、永无止尽的智慧之源、意识之渊、友谊之泉。是的，我们会失去朋友，但也会在我们从未想过的地方找到朋友。那会是更好、更真诚的朋友。我们对他们也会更好、更诚挚。</p></li><li><p>真实的自己</p><p>  没有一个孩子生来真是一张白纸。每个人来到这个世界，都带着他独一无二的鲜明个性，都有一个设定好的身份，随你如何用星尘和火球去砸向它，也无法让它发生丝毫变形。每个孩子都是他自己。</p><p>  换言之，没有人生来是不带标签的泥丸，任由世界搓扁揉圆，留下印记。相反，我们一出生就拥有一个千锤百炼的个性化灵魂。<br>  对此，还有另一种思路：我们并非生来就有无限的选择。<br>  我们做不到随心所欲，成为任何一种人。我们来到这个世界，是带着特定的个人命运。我们有工作要做，有使命要践行，有一个“真正的自己”要长成。我们就是我们，从在摇篮里就注定了的，无法改变。<br>  在这一生里，我们的任务不是把自己塑造成自己想象中应该成为的理想，而是找出我们天生是谁，并成为他。</p></li><li><p>领域与等级</p><p>  在动物王国中，个体以两种方式来定义自己：一种是在等级体系（如母鸡的啄食顺序，集群生活的狼）中的地位，另一种是与领域的联系（巢穴、捕猎地、势力范围等）。</p></li><li><p>等级取向</p><p>  我们人类似乎被我们的进化历史所束缚了，二十到八百人的部落是我们感觉最舒适的生活圈。我们可以把它拓展到几千，甚至上万。但总会有某个点是它的极限。我们的大脑无法应付那么多面孔。我们四处转悠，炫耀我们身份的徽章——嘿，你觉得我这辆林肯领航员怎么样？——心里疑惑，为什么没人在乎。<br>  我们进入了大众社会。它的等级体系太庞大，不再起效了。</p></li><li><p>艺术家与等级体系</p><p>  个体如果根据自己在啄食顺序中的位置来进行自我定义，就会：<br>  ① 与秩序体系中的其他所有人对抗。与上位者竞争，以谋求地位提升；压制下位者，以保全现有地位。<br>  ② 根据在等级体系中的排名来评估自己的幸福/成功/成就，处于最高位时满足感最强，处于低位时最痛苦。<br>  ③ 根据他人在等级体系中的排名来决定自己的态度和行动，不考虑其他任何因素。<br>  ④ 将对他人的影响作为评判自身行为的唯一标准。行为动作是为了他人，穿衣打扮是为了他人，说话、思考，都是为了他人。</p><p>  艺术家必须以领域为导向。他必须为了自己工作。</p><p>  在等级体系中，艺术家只会向上看和向下看。偏偏看不见最应当看向的地方：内在。</p></li><li><p>二流作家的定义</p><p>  这是我从罗伯特·麦基那里学到的。他说，一个二流作家，是一个对观众进行二次猜想的作家。当二流作家坐下来工作时，他不会问自己内心深处是什么。他问市场在寻找什么。</p><p>  做二流作家是有望换取可观回报的。考虑到美国文化的堕落程度，一个徒有其表的家伙去当二流作家，也可能成为百万富翁。但即使成功，同时也意味着失败，因为你出卖了你的缪斯。而缪斯就是你，你自己最好的一部分，本可以产出你最优秀的、完全真实的作品的地方。</p></li><li><p>领域导向</p><p>  我们人类也有领域。是心理的领域。</p><p>  领域的特质是什么？<br>  ① 领域提供养分。跑步者知道什么是领域。攀岩者、皮划艇运动员和瑜伽修行者也知道。艺术家和企业家都知道什么是领域。游完泳的人上岸后用毛巾擦干身体，感觉会比30分钟前跳进泳池时那个疲惫、暴躁的人好得多。<br>  ② 领域无需外来给养便能支持我们。领域是一个闭环反馈回路。我们的任务是投入努力和爱；领域吸收了它们，回馈我们以幸福。<br>  当专家告诉我们运动（或其他任何需要付出努力的活动）可以消除抑郁时，他们说的就是这个。<br>  ③ 领域只能独享。你可以有搭档组队，可以和朋友一起锻炼，但要汲取领域的给养，你只能一个人。<br>  ④ 领域只能通过工作来获得。当阿诺德·施瓦辛格去健身房时，他在自己的主场上。但使它最终能为他所有的，是施瓦辛格为获得它而挥洒汗水的每一个小时、每一年。领域不给予，只回馈。<br>  ⑤ 你投入多少，领域就回报多少。领域是公平的。你投入的每一尔格能量都会准确无误地纳入你的账户。领域从不贬值。领域永不崩溃。你存多少，就能得到多少，毫厘不差。</p></li><li><p>艺术家与领域</p><p>  根据定义，创造性行为是领域性质的。正如准妈妈在自己体内孕育孩子，艺术家或创新者的体内也在孕育属于自己的新生命。没人能帮别人生孩子，他们也不需要帮助。</p><p>  记住，作为艺术家，我们一无所知。我们每天都在尝试，扑扇翅膀。但我们不能像二流作家揣测受众那样，对我们的缪斯妄加揣测，那是对上天的贬低，是亵神渎圣。</p></li><li><p>领域和等级之间的差异</p><p>  如何判断我们的导向是领域性的还是等级性的？一种方法是问自己：如果我感到很焦虑，我会怎么做？如果我们拿起电话，一口气接连打给六个朋友，只为了听到他们的声音，让自己相信他们仍然爱着我们，那我们就是走在等级导向中。</p><p>  还有另外一个测试方法。对于你采取的任何行动都扪心自问：如果我是地球上的最后一个人，我还会这么做吗？<br>  如果这颗星球上只剩下你一个人，等级取向便没有任何意义。没有人需要你去留下印象。因此，如果在这种情况下你还想继续从事这项活动，恭喜你，你是在领域导向下工作的。</p></li><li><p>至高无上的美德</p><p>  以领域为导向，把注意力局限在我们自己的思想和行动上，换句话说，也就是工作和工作的需要上，我们就能无视涂抹着蓝色油彩、敲响盾牌、挥舞着长矛的敌人，专心将他们脚下的大地切开。</p></li><li><p>我们的劳动成果</p><p>  当黑天告诉阿阇那，我们有权劳动，但无权要求我们的劳动果实时，他是在告诫战士，要按领域行事，而不是依照等级。我们必须为工作本身而工作，不为财富、关注或掌声。</p></li><li><p>艺术家的肖像</p><p>  最后，我们得出了一种艺术家世界的模型，这个模型里，有其他更高的现实层面存在。我们无法证明它，但我们的生活、我们的作品和艺术都来自于它。这些领域一直试图和我们交流。当布莱克说“永恒爱恋时间的造物”时，他指的是那些具有纯粹潜力的层面，那里没有时间，没有地点，没有空间。但它们渴望将它们看到的带到这里，带到这个有时间限制、空间定义的世界里。<br>  艺术家是这意愿的仆人，也是天使与缪斯的仆人。艺术家的敌人是那个无足轻重的自我，内阻力因它而生，那是守着黄金的恶龙。这就是为什么，艺术家必须也是战士，和所有战士一样，随着时间的推移，艺术家会懂得节制与谦逊。他们中的一些人可能在公共场合表现得很张扬。可一旦独自沉浸在工作中，他们便是纯洁、谦逊的。他们知道，他们并不是自己作品的源泉，只是将它们带来这个世界。他们只是居中助力。他们只是搬运。他们是心甘情愿、技艺娴熟的乐器，为众神与众女神服务。</p></li><li><p>艺术家的生命</p><p>  你是天生的作家吗？你被放到这地球上，是为了成为画家、科学家或和平使者吗？归根结底，这个问题只能用行动回答。<br>  只有做与不做。</p><p>  创造性工作不是一种自私的行为，也不是为了给表演者博取关注。它是给全世界和世界上每一个人的礼物。不要在你的贡献上作弊。给我们你的所有。</p></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>见树又见林</title>
      <link href="/books/%E8%A7%81%E6%A0%91%E5%8F%88%E8%A7%81%E6%9E%97/index.html"/>
      <url>/books/%E8%A7%81%E6%A0%91%E5%8F%88%E8%A7%81%E6%9E%97/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：推荐<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>毫无意义的工作</title>
      <link href="/books/%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%B7%A5%E4%BD%9C/index.html"/>
      <url>/books/%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%B7%A5%E4%BD%9C/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：一般<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>贪婪的多巴胺</title>
      <link href="/books/%E8%B4%AA%E5%A9%AA%E7%9A%84%E5%A4%9A%E5%B7%B4%E8%83%BA/index.html"/>
      <url>/books/%E8%B4%AA%E5%A9%AA%E7%9A%84%E5%A4%9A%E5%B7%B4%E8%83%BA/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：一般<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>手机大脑</title>
      <link href="/books/%E6%89%8B%E6%9C%BA%E5%A4%A7%E8%84%91/index.html"/>
      <url>/books/%E6%89%8B%E6%9C%BA%E5%A4%A7%E8%84%91/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><aside>📗### 概括这本书</aside><p>人类的大脑无法适应数码时代，再手机上花费太多时间是有害的。</p><aside>📘### 我的感想</aside><p>现实生活中很多问题都是由于身体的进化没有跟上社会的发展。</p><p>我们尽管相信自己可以同时处理多项任务，但实际上很多时候都只是在各个事情之间来回穿梭而已。大脑试图从一件事切换到另一件事情时，注意力无法随叫随到，会出现注意力残缺。</p><p>信息量爆炸也会导致大脑超过负荷，大脑能够集中注意力的时间过于短暂，这当然不利于记忆的形成。</p><p>对于以Facebook为首的其他社交媒体而言，其最为重要的财产就是人们的关注。它们制造的产品正是我们的注意力。</p><p>运动能给注意力缺乏的现代人带来正面的影响。</p><aside>📙### 希望的改变</aside><p>运动一周五次，一次30分钟。</p><p>减少玩手机的时间。</p><p>减少碎片时间，避免注意力残留。</p><p>避免多任务处理。</p><p>尽量大脑记忆，不要依靠拍照和电脑。</p><aside>📒### 卡片笔记</aside><ul><li><strong>前言</strong></li></ul><ul><li><p><strong>序言</strong></p>  <aside>  该节写了人们的大脑没有随着当前社会的发展而发展，但科技在发展。受到以前的影响，我们会收集信息，所有错误的信息快速传播。我们的大脑被企业家入侵，吸引我们沉溺其中。  </aside><ul><li><p><strong>一万年间不曾发展的人类大脑</strong></p><p>  狩猎采集的生活占据了人类历史99.9%的时间，我们的大脑也是随着这一生活方式不断进化而来的。然而近1万年以来，人类的大脑基本没有发生变化。这就是说，尽管身处现代社会，但我们的大脑却认为我们仍然“生活”在非洲的热带草原时期，这完全是由生物学因素导致的！</p></li><li><p><strong>此刻应对新冠肺炎的人类大脑，是哪个时代的产物</strong></p><p>  饥饿一度是人类最大的敌人，因此我们的大脑进化出了“渴望热量”的机制。这份“渴望”使得曾经的我们一旦发现食物就会将其吃得一口不剩。然而在只要有钱就可以胡吃海喝的现代社会，对于食物的渴望似乎难以正确发挥作用了。这也是为什么2型糖尿病和肥胖成了全球性问题。</p></li><li><p><strong>我们为什么会被错误的信息绑架</strong></p><p>  在新冠肺炎肆虐期间，数码产品就是一座座连接世界的桥梁，但它也引发了不少问题。谣言和阴谋论在SNS②上大量流传，扩散速度比病毒还快。尽管灾难发生时难免会有谣言兴起，但与从前小范围的扩散不同，如今只需要几个小时，虚假情报就可能传到上百万人的耳朵里。</p></li><li><p><strong>我们的大脑每天都在遭遇黑客入侵</strong></p><p>  在不断研究的过程中，我发现人的大脑也会遭到黑客侵袭，就像那些“脆弱”的电脑编程一样。聪明的企业家已经成功占领了我们的大脑，他们开发出许多产品来掠夺我们的注意力。也许你认为自己使用手机完全是出于个人的需求和意愿，但这个想法其实是错误的。Facebook（脸书）、Snapchat（色拉布）、Instagram（照片墙）等产品早已“黑掉”了我们大脑中的奖赏机制。</p></li><li><p><strong>科学技术的“两副面孔”</strong></p><p>  人们都说我们应该尽快适应、积极掌握新的技术，但我并不这样认为。我想，不应该是人类去适应科学技术，而是新的技术开发要符合人的需求。</p><p>  人们使用Facebook、Instagram、Twitter（推特）等社交平台的时间越长，对于资本家来说自然越有利。因为这可以时刻引导使用者观看广告、购买商品。因此，企业家的目标便是最大限度地夺走我们的时间。他们已经越来越懂得要如何设计产品才能让人们无限沉溺于其中。</p></li></ul></li><li><p><strong>仍处于原始时代的大脑</strong></p>  <aside>  讲了大脑的进化是为了生存，但进化的速度未能跟上社会发展的速度。情感的产生是为了生存，他会率先操纵我们的大脑。我们更能被负面情感抓住。  </aside><ul><li><p><strong>不好不坏的进化</strong></p>  <aside>  进化只是赋予我们生存的基本条件，让我们能够适应周边环境而已。  </aside><p>  我们是进化的结果，进化的过程是没有意义也不存在目的的。进化不存在“好与坏”的问题，它既不企图伤害我们，也不打算带来帮助。它只是赋予我们生存的基本条件，让我们能够适应周边环境而已。</p><p>  能够提高存活率、繁殖率的遗传特征，通常会在经历漫长的岁月之后，成为普遍的特征。包括人类在内的所有动植物，都是通过这样的方式不断适应着各自所处的环境的。</p><p>  在上百万年的时间长河里，我们的身体通过进化获得了对热量的渴望，并因此得以繁衍生息。而在现代社会，只要有钱，食物就是唾手可得的东西。然而，由于这样的环境变化是在近两个世纪才出现的，人类尚未拥有足够的时间去适应它。单从生物学角度来看，我们的大脑仍处于一个一看到食物就默默呐喊“吃掉它，不然明天一早可能就没有了！”的时代。</p><p>  假设玛利亚是一个警觉的人，她时常因为四周的威胁而感到焦虑，总是想方设法地进行躲避。在从前的时代，许多人因为意外丧生，或被他人殴打致死，抑或被动物吃掉，因此这样的警觉对于生存是有利的。但到了现代社会，周边环境已经变得大致安全。持续的焦虑、时刻的提防只会让心情变差，令人整日惶惶不安，生活在恐惧之中。</p></li><li><p><strong>我们未能进化成适应现代社会的模样</strong></p>  <aside>  我们的大脑未能适应现代的社会  </aside></li><li><p><strong>情感是我们的战略目标</strong></p>  <aside>  情感的产生是为了帮助帮助我们更加灵活、迅速、有力地处理某些问题。  </aside><ul><li><p>从出生起到闭眼的一瞬，我们的大脑一刻不停地在琢磨着一个问题：“现在干点儿啥好呢？”大脑不在乎昨天已经发生的事情，它只关注当下和未来。为了对眼前的状况做出判断，它会调动记忆，并接受情感的帮助，努力做出正确的决定。</p><p>  受到欲望多巴胺和当下因子的影响，我们更关系当下与未来</p></li></ul></li></ul></li></ul><pre><code>    情感并不是我们对周边环境做出的反应。它是大脑将发生在我们周围的事情和身体反应结合起来制造出的一样东西，并因此促使我们做出各种行动。而情感，就像长颈鹿的脖子、北极熊的白色毛发一样，是一种生存战略。但比起一些身体属性，情感更多的是帮助我们更加灵活、迅速、有力地处理某些问题。    与其他物种一样，人类身体和大脑的进化，也基于“活下去，向后代传递基因”这一最为基本的原则。- **情感对大脑的操控**    &lt;aside&gt;    情感会告诉我们答案，但情感的答案是在以前生成的。    &lt;/aside&gt;    当信息情报不足以支撑我们做出理性判断，或是需要花费的时间太长时，大脑就会疯狂计算，最终以情感的形式告诉我们答案。    如今站在超市贩卖果冻的地方，我们往往会强烈地感到，“好想吃果冻”。这就是朝着“避免饥饿”的方向不断进化发展的运算法则给予我们的暗示。这是个食物过剩的世界，而我们大脑适应的时间尚且太短。因此站在果冻面前，我们时常难以做出理性的判断。相比承受着饿死风险的卡林，我们有更大的可能是那位对热量充满渴望的玛利亚的子孙后代。- **为什么我们更容易被负面情感抓住**    &lt;aside&gt;    相比正面情感，负面情感更具优势，这是由历史决定的，面对危险时却需要立即做出应对。    &lt;/aside&gt;    情感会从正负两个侧面操控我们，让我们做出不同的决定。    在感到危险的瞬间，大脑就会立即下令分泌皮质醇和肾上腺素，让我们的心脏更加剧烈地跳动起来。心脏便因此向身体肌肉输送大量的血液，使我们最大限度发挥自身机能，例如逃跑或做出反抗等。当感到饥肠辘辘时，一看到食物，大脑就会分泌出多巴胺，让我们对食物产生渴望。多巴胺就像能够让人类对彼此产生亲近感的催产素一样，在性兴奋时也会分泌。它能够让我们保持专注，不被其他事情夺走注意力。    相比正面情感，负面情感更具优势。这就是因为，从历史的角度来看，负面情感通常与危险等因素联系得更为密切。吃饭、喝水、睡觉、交友这些事情也许可以往后推一推，但面对危险时却需要立即做出应对。这就解释了为什么当处在巨大的压力和不安之下时，人们无法顾及别的事情。    负面情感主要来源于压力。</code></pre><ul><li><p><strong>压力、焦虑和抑郁——进化的赢家？</strong></p>  <aside>  杏仁核在面对危险时发出警告，HPA因此运转，到杏仁核宁可错杀，也不放过，且与现实生活有很大的差别。  压力应对机制是为了生存，过度的压力会让人发疯，长期记忆受到影响。  焦虑，则是我们对“可能成为危险的某个东西”产生的反应。焦虑也会帮助我们建立起一些重要的机制，促使我们更加专注。但现在焦虑机制总在毫无必要的时候发挥作用。  长期的压力是人们患上抑郁症最常见的原因。抑郁则会帮助我们避开感染和斗争。  抑郁和焦虑反而是帮助我们生存下去的工具。  </aside><ul><li><p>我们先来具体了解一下医学上所谓的HPA（下丘脑——垂体——肾上腺）轴吧。HPA轴经历了上百万年的发展，不仅人类，鸟类、蜥蜴、狗、猫、猴子等脊椎动物基本都拥有这一机制。H代表下丘脑，下丘脑会向位于大脑下方掌握内分泌的脑垂体（P）发送信号，接着脑垂体便命令肾脏正上方的肾上腺（A）分泌一种名为皮质醇的激素。而皮质醇正是身体最为重要的压力激素。</p><p>  <strong>例：</strong>假设我们的一位祖先遇到了狮子。此时HPA轴就会拉响警报，促使我们做出适当的反应。即“下丘脑向脑垂体释放信号，脑垂体又向肾上腺下达命令”这一连串过程。皮质醇会将能量拉至最高点，使得心脏更加剧烈地跳动起来，就像我们每个人在受到压力时都曾经历过的那样。然而，心跳究竟为什么会加快呢？在遇到狮子时，祖先们需要迅速做出反应，是与其殊死搏斗还是撒腿就跑？这便是所谓的“战斗或逃跑反应”（fight or flight response）。为了全力战斗或全速奔跑，身体肌肉需要得到大量供血，为此心脏必须要更加强有力地搏动起来，如此一来，这一机制就留存了下来。</p></li></ul></li></ul><pre><code>- **压力应对机制是这样形成的**    &lt;aside&gt;    压力应对机制是为了生存，过度的压力会让人发疯，长期记忆受到影响。    &lt;/aside&gt;    压力应对机制存在的理由跟我们拥有情感的理由一样——为了生存。    - 持续的高压状态还会对我们的思考能力产生影响。也许适当承受一些压力会使我们的思维更加敏捷，但稍微一过度，我们就可能丧失理性思考、理性判断的能力。        例：如果人类持续处于战斗或逃跑反应状态下，大脑就会开始认为斗争或逃避是解决问题的最佳方案，逐渐产生类似这样的逻辑：        睡觉：待会儿再睡呗，多大个事儿        饮食：待会儿再吃呗，没事儿        繁殖：之后再做呗，小事儿    在面临极端的压力时，我们会选择战斗或逃跑，因此也就遗憾地失去了深入思考的机会。此时排在第一位的是“解决问题”，因此相比一些“社会性更优方案”，大脑会更加倾向于进入“故障排除模式”（trouble shoot）。由于需要快速强烈地做出反应，人便会因为一些琐事产生极强烈的烦躁情绪，比如大喊大叫“到底为什么要把袜子扔地板上啊！”等。    过度的压力还会让人无法注意到身边发生的事情，失去享乐的悠闲，甚至“发起疯来”。受到威胁的大脑是最不可能放松警惕的，这就是为什么我们在压力很大时往往会觉得难受。    此外，大脑的长时记忆功能也会遭到“排挤”。大脑各部位的连接形成了记忆，串联它们的“纽带”便是海马（hippocampus），即大脑的记忆中心。想要加强“纽带”和记忆，海马就需要向新形成的记忆回路发送信号。然而压力过大时，大脑就没有这样的“空闲”了，因此许多人在重压之下会感到记忆力不佳。- **杏仁核——我们身体的火灾报警器**    &lt;aside&gt;    杏仁核对危险进行警告，HPA因此运转。    &lt;/aside&gt;    杏仁核掌管许多重要的功能，在自身的记忆和情感之外，它还能够帮助我们分析判断他人的情绪。而其中最为重要的，就是捕捉危险，并在发现后即刻向我们报警。正是因为有了杏仁核的“警告”，压力应对系统HPA轴才会开始运转。我们通常将杏仁核的运转方式称为“火灾报警原则”。即，宁可错杀，也不放过。由于这一过程十分迅速，因此难免有失准确性。- **杏仁核时刻地扫视**    &lt;aside&gt;    杏仁核宁可错杀，也不放过。它与现实世界存在不一致。    &lt;/aside&gt;    从进化的角度来说，杏仁核遭受香烟威胁的时间还太短。这也就解释了为什么明明生活在城市，却有那么多人并不恐惧汽车，反而会因为恐惧蛇或蜘蛛等而寻求心理帮助。    提到“压力”，大家往往觉得它是个负面的词。然而如果想要充分发挥自身的能力，压力其实是不可或缺的。短期的压力可以帮助我们提高注意力，使我们的思维更加敏捷。也就是说，如果在工作上承受一天或一周左右的压力，也不一定是一件坏事。- **焦虑——身体的保护器**    &lt;aside&gt;    焦虑，则是我们对“可能成为危险的某个东西”产生的反应。焦虑也会帮助我们建立起一些重要的机制，促使我们更加专注。    &lt;/aside&gt;    焦虑是一种极度的不舒适感，往往出现在危险到来之时，此时身体的压力应对机制也会随之开始运转。    “万一考试失败怎么办？”这个想法一直缠绕着你。这就是所谓的“焦虑”。此时我们身体里的哪个系统会开始运转？正是HPA轴！与受到压力时一样，感到焦虑时，战斗或逃跑反应也会变得活跃。然而这其中的原因却并不相同。压力，是我们“面对危险”时做出的反应。而焦虑，则是我们对“可能成为危险的某个东西”产生的反应。    为了摆脱危险，压力可能会带来一些帮助。但是，焦虑又有什么用处呢？临近考试，难道不是应该保持最佳状态吗？但问题并非如此简单。焦虑也会帮助我们建立起一些重要的机制，促使我们更加专注。- **那些看起来不合理的焦虑，其实也是合理的**    &lt;aside&gt;    有些焦虑其实是合理的，但现在焦虑机制总在毫无必要的时候发挥作用。    &lt;/aside&gt;    还有个别人，甚至看起来像在主动寻找可能引发焦虑的契机。这是由于从人类历史的角度来看，至少要疑心“可能存在危险”，及时做出反应，生存概率才会变大。然而，今天我们的压力应对机制常因为一些莫名其妙的原因，在毫无必要的时候发挥作用。例如给喜欢的女生发信息，如果没有及时收到回复，就会感到焦虑——“看来她不喜欢啊。我真是个没用的人。我可能到死也交不到女朋友了”。由于担心遭到排斥，HPA轴便自然而然地活跃了起来。    许多人因为害怕在他人面前讲话，甚至患上了所谓的公开演讲恐惧症（glossophobia）。之所以在意他人的目光，很大程度上可能就是因为人类一直以来都是群居动物。不想被评价，害怕遭受社会大众的侮辱，担心被群体排挤，在这样的状况下，大脑的压力应对机制就会启动，心脏也开始剧烈跳动起来。对周边的评价十分敏感，似乎也恰恰证明了，我们的大脑尚未适应目前所处的现代社会。实际上，就算某次报告没有顺利完成，我们也不太可能真的因此丢掉饭碗乃至饿死。然而在进化的历程中，一旦被群体排挤，祖先们就可能陷入致命的危机。归属感不仅仅意味着稳定，更是生死攸关的大问题。因为在从前的世界，落单的人很难独自存活下来。- **抑郁症——一种天然的保护？**    &lt;aside&gt;    即使从历史的角度来分析，这位患者所表现出的抑郁症状也是有些不合逻辑的。    &lt;/aside&gt;    即使从历史的角度来分析，这位患者所表现出的抑郁症状也是有些不合逻辑的。焦虑有利于生存，这尚且说得过去。但抑郁的人只想逃离这个世界，他们无法入睡，将自己跟社会隔绝开来，甚至还会失去性欲。这一切显然都只会大大降低我们延续自身基因、成功繁衍后代的概率。而且，为什么在压力因素全部消失之后，抑郁症状才爆发出来呢？- **长期压力的代价**    长期的压力是人们患上抑郁症最常见的原因。    当大脑受到巨大压力时，就会做出“周边环境危机四伏”的判断，认为只有蜷缩起身体，躲在被子里才是安全的。那么，究竟是什么让大脑做出了这样的分析和判断？当然是情感了！大脑通过情绪操控着我们——“四周很危险，必须赶紧逃跑”，同时让我们感到抑郁，并将自己与世界隔绝开来。    正是因为大脑尚未完全适应现代社会，于是只能选择逃避。它至今仍认为，压力就等于危险，这符合绝大部分人类的历史经验。    不过，抑郁症可能是我们身处危险世界时大脑提供的一种保护策略，这种说法并不是毫无依据的。    预测未来，这也许是人类特有的一种能力，我们不可避免地会去设想到一些悲观的事情——“说不定会被解雇”“搞不好会被抛弃”“很有可能还不完房子贷款”。在这些想法之下，HPA轴就会开始运转。这就是说，我们为自己的“智能”付出了代价。    预测未来，这也许是人类特有的一种能力，我们不可避免地会去设想到一些悲观的事情——“说不定会被解雇”“搞不好会被抛弃”“很有可能还不完房子贷款”。在这些想法之下，HPA轴就会开始运转。这就是说，我们为自己的“智能”付出了代价。- **抑郁症——一种预防感染的方法？**    尽管基因会影响患抑郁症的风险，但实际上并不存在单一的“抑郁症基因”。这一切都是上百个基因共同作用的结果，并且它们在其中并不会起到决定性作用，而只是让我们变得脆弱，更加容易陷入抑郁症的深渊。    可能引发抑郁风险的那些基因，同时也参与着激活免疫系统的工作。- **感到抑郁不是我的错**    焦虑会将我们从危机中拯救出来，抑郁则会帮助我们避开感染和斗争。如果能够理解这一点，抑郁症患者可能就会转变想法，明白“抑郁症不是我的错，只是我的大脑选择的行动不太适合我现在生活的世界而已”。- **身体发出的警告**    此外，长期承受重压的人，大多都面临着睡眠障碍、腹痛、容易感染、磨牙、短时记忆受损、焦躁等问题，这些都是身体发出的警告。然而，我们为什么会无视这些信号呢？    在我看来，许多人甚至从来没有意识到这些，不知道这些身体症状其实都是压力带来的。这实在令人感到遗憾。如果能够悬崖勒马，就有很大机会避免抑郁。因为对于抑郁症来说，相比治疗，预防才是更为容易的。- **“只有强者才会生存下来”，这句话并不总是正确的**    在可能导致我们患上抑郁症的那些基因中，有一个基因在大脑分泌5–羟色胺（serotonin）时起着关键性作用，它会让我们在面对压力时更加脆弱。我们将这一基因从实验鼠身上移除后，发现它们的确变得更抗压了。    这就实在令人感到不解，最初究竟为什么会存在这样的基因？它在进化过程中又为何没有被去除？    说不定这恰恰意味着，最初那些最坚强、最聪慧、最抗压的人并没能存活下来。对祖先们来说，躲避危险和斗争，战胜感染，保证自己不被饿死，这些是最为重要的。而正如前文所说，抑郁和焦虑反而是帮助我们生存下去的工具。</code></pre><ul><li><p><strong>手机——一种新型兴奋剂</strong></p>  <aside>  本节讲了多巴胺，他让我们喜欢新鲜事物与难以预料的事情，所有我们渴望手机。同时SNS会迎合我们的大脑，让我们把更多时间用在上面。  </aside><ul><li><p><strong>身体的能量——多巴胺</strong></p><p>  有时人们会说，多巴胺是一种奖赏性物质，但这其实不完全准确。因为多巴胺最重要的功能并不是让心情感到愉快，而是让我们选择究竟将精力放置在何处。多巴胺就是我们的能量。<br>  饥肠辘辘时，如果有人将美食摆满餐桌，此时光是用眼睛看着，多巴胺的数值就会飙升，并不需要等到吃下食物之后才开始分泌。是多巴胺让我们产生了食欲，告诉我们“把注意力集中在这里”。除了带给我们满足感以外，多巴胺还会赋予我们做事的动力，那么后者又从何而来？这与人体分泌的“吗啡”内啡肽（endorphin）有关。多巴胺会让我们对眼前的美食产生欲望，而内啡肽，则是那个让我们感到“这个食物很好吃”的物质。</p></li><li><p><strong>我们热爱新鲜事物</strong></p><p>  “了解得越多，生存概率越大”，大自然赋予了我们不断探取新情报的本能。是什么刺激着我们的本能？相信大家也都猜到了，正是多巴胺。面对新鲜事物时，大脑就会分泌多巴胺，帮助我们更好更专注地学习。</p><p>  大脑不仅需要接收新的信息，也总是渴望崭新的环境和事物。大脑里有很多生成多巴胺的细胞，这些细胞只会对新鲜事物做出反应。</p><p>  这些渴求新环境、新信息的多巴胺细胞的存在，意味着大脑对新鲜事物充满了很高的评价。</p><p>  每当点开新的页面，大脑就会分泌多巴胺，于是我们会不断点开新的页面，根本停不下来。似乎相比刚才已经看过的页面，“下一页”永远是最好的。我们在每个网页停留的时间可能不足4秒，而能够占用我们10分钟以上时间的网页仅占4%。</p></li><li><p><strong>大脑喜欢那些难以预测的事物</strong></p><p>  结果，相比每次都能拿到钱的情况，人们在不确定到底能不能拿到钱时，多巴胺的分泌更为旺盛。并且，在每抽取两次卡片能够拿到一次钱的频率下，其分泌量最大，与老鼠和猴子的情况一致。这就意味着，其实对于大脑来说，在“不确定性中不断向前迈进”这条“道路”本身可能就是一种目标。</p></li><li><p><strong>因为难以预料，所以渴望手机！</strong></p><p>  大自然总是变幻莫测。就像那些“可能挂着果子”的树木一样，我们很难事先知道最终能否得到奖赏。状况捉摸不定时，大脑就会疯狂分泌多巴胺，面对新鲜事物时也同样如此。这会刺激人类不断进行探索，也让我们的祖先在那个食物匮乏、资源有限的时代，得到了基本的生存保障。</p><p>  “说不定有什么重要的事情”，我们总是这样想着，而在听到提示音时分泌的多巴胺，也远远高于真正阅读短信或邮件的时刻。“说不定有什么重要的事情”，这个想法推动着我们不断拿起手机进行确认，于是便出现了每10分钟就得看一次手机，只要醒着就离不开手机的问题。</p></li><li><p><strong>不断刺激着奖赏系统的SNS</strong></p><p>  除了赌场运营者、手机制造商之外，还有一些地方也巧妙地利用了人类对于不确定事物的执着心理。其中最典型的就是SNS。Facebook、Instagram、Snapchat等社交平台一直诱惑着我们——“有没有谁更新了动态”“我看看有多少人给我点赞留言了”。并且，SNS会蓄意将我们的奖赏系统激活到顶峰。别人给你的度假美照按下的“赞”不会立即显示出来，Instagram和Facebook会先保留他人的点赞，直到我们的奖赏系统运转达到顶峰时才放出来。通过将刺激切割成小份，它们将人们的期待值拉到最高点。</p></li><li><p><strong>我究竟开发了个什么东西</strong></p></li></ul></li></ul><pre><code>- **乔布斯为什么要限制自己的孩子使用手机**- **泛滥成灾的广告**    正埋头工作，突然听到短信提示音，这个时候你就会产生强烈的冲动，想要拿起手机，因为“说不定有重要的事情”。接下来你会想，既然已经拿起手机了，不如顺便看看有多少个新增的“赞”吧，于是打开了Facebook浏览起来。突然你看到新闻说，最近你家附近发生了抢劫事件，点进去正读了两句，休闲鞋广告就弹了出来，于是你瞄了一眼。这时又收到新的通知，说一位好友给你留了言，于是你赶紧前去查看。等到抬起头来，你才想起工作已经被自己抛到九霄云外了。</code></pre><ul><li><p><strong>注意力——时间的稀缺性</strong></p>  <aside>  我们尽管相信自己可以同时处理多项任务，但实际上很多时候都只是在各个事情之间来回穿梭而已。大脑试图从一件事切换到另一件事情时，注意力无法随叫随到，会出现注意力残缺。  信息量爆炸也会导致大脑超过负荷，大脑能够集中注意力的时间过于短暂，这当然不利于记忆的形成。  一想到信息会被储存在别的地方，大脑就更“懒”了。我们将这种现象称为Google效应，或是数字健忘症。相比信息本身，大脑更加倾向于记下信息被储存的地方。  </aside><p>  数码生活方式，似乎就意味着“同时做几件事”，也就是所谓的多任务处理（multitasking）。</p><p>  在对他们分别进行观察后研究人员发现，同时处理多个任务的一组实验对象注意力明显更为低下，尤其是在过滤非重要信息的任务中表现不佳，精力十分涣散。</p><ul><li><p><strong>多任务处理的代价</strong></p><p>  事实上，大脑具备同时“运行多个程序”的惊人能力。但有一个部分却受到了我们心智带宽（mental bandwidth）的严格限制，那就是注意力。我们只能在一件事情上集中精力。我们尽管相信自己可以同时处理多项任务，但实际上很多时候都只是在各个事情之间来回穿梭而已。</p><p>  大脑在面临任务转换时需要时间。试图从一件事情切换到另一件事情时，注意力无法随叫随到，还会在前一件事情上徘徊，这就是所谓的“注意力残留现象”（attention residue）。就算只看了几秒钟的邮件，最终要付出的时间代价也远远不止如此。这样的转换期到底有多长，我们很难给出确切的答案。不过有研究称，在更换了任务对象之后，注意力重新聚集起来可能要花上好几分钟时间。</p></li><li><p><strong>多任务处理时，为什么会分泌多巴胺</strong></p><p>  在处理多项任务时，大脑反而会分泌出让心情变好的多巴胺作为奖赏。大脑究竟为什么要降低自身的效率呢？<br>  人在东张西望、注意力分散的时候，时常感到心情愉悦。这是因为，我们的祖先为了快速应对那些可能隐藏在身边的危险，需要时刻留心观察周围环境。稍微走神都有可能令人丧命，因此需要保持高度的警觉。大脑的进化也与此相匹配，因而会在我们处理多项任务、注意力涣散时分泌出多巴胺给予奖赏。这听起来可能是一件好事，实际上却是需要付出一些代价的。</p></li><li><p><strong>工作记忆是有限的</strong></p><p>  多任务处理不仅会导致注意力下降，还会弱化大脑中用来储存工作相关记忆的“精神工作台”，即工作记忆（working memory）。</p><p>  主导研究的学者们因此表示，在进行多任务处理时，人们会在整理、过滤那些不重要的信息上受阻。“如果注意力持续处于涣散的状态，大脑就无法良好地发挥作用”。</p></li><li><p><strong>即使处于静音状态，手机也在干扰我们</strong></p><p>  当试图同时做几件事情时，注意力和工作记忆都会受到负面影响。此时不少人可能会觉得，关上电脑，把手机调成静音模式放在衣服口袋里自己就会少受一些干扰。但事实并非如此简单。正如此前提到的那样，手机在剥夺我们的注意力方面有着强大的能力，我们很难摆脱它。</p><p>  很显然，尽管人们可能意识不到，但只要将手机放在身边，只要想到自己身上带着手机，我们的注意力就会被分散。在许多不同的实验中都观察到了类似的现象。</p></li><li><p><strong>大脑绝对不会站在我们这边</strong></p><p>  即使将手机放进衣服口袋里，大脑还是会不自觉地受到手机等电子产品的吸引，要想忽略其存在，就需要使用心智带宽，最终结果便是注意力无法得到正常发挥。仔细想想，这并非一件难以理解的事。多巴胺会提示大脑什么是重要的，告诉我们应该将注意力集中在哪里。而手机，每天可以以数百次的频率刺激多巴胺分泌，因此我们自然很难将注意力从手机上挪开。面对每天刺激多巴胺分泌数百次的事物，大脑想要将其无视，的确需要费点力气和能量。这是理所当然的，因为大脑就是这样一路进化而来的，它就是会“寻找那些刺激多巴胺分泌的东西”。</p><p>  大脑在奋力抵挡手机的诱惑时，履行其他职责的能力就会变差。如果是一些不太依靠注意力的事情则无关紧要，但在需要高度集中的状况下，问题就会暴露出来。</p></li><li><p><strong>注意力逐渐消失的时代</strong></p><p>  也许你会认为，信息情报的泛滥反而可以锻炼注意力，在数码产品的影响下，尽管精力被分散了，但最终我们都会适应、克服这一切，我们的大脑和肌肉一样，会在规律的奔跑或运动中得到发展，变得更为结实。然而大脑却恰恰与此相反，受到的阻碍越多，注意力越是会变得散漫。</p><p>  一旦注意力下降，那么即使面对的是并不那么容易让人分神的状况，我们也很难保持集中，总是东张西望的。在现今这个社会，注意力已然成了稀缺的能力。</p></li><li><p><strong>好记性不如烂笔头</strong></p><p>  尽管尚且难以说出准确的理由，但研究者们推测，用键盘打字的人可能只停留在了“听写”的层面，而用笔记录的人速度较慢，因此需要考虑记录的优先顺序。这就是说，手写时我们必须对信息进行处理，所以能够更好地理解这些信息的内容。</p></li><li><p><strong>注意力和长时记忆形成的关系</strong></p><p>  我们在学习新事物，即形成新的记忆时，脑细胞之间的连接需要改变。为了形成短时记忆，大脑只需要强化不同细胞间既存的连接即可。而那些能够储存数月、数年，甚至一生的长时记忆的形成，则需要依靠更为复杂的过程，它要求脑细胞之间形成全新的连接。为了让记忆可以持久地储存下来，必须利用新的蛋白质来打造新的连接。但仅仅依靠新的蛋白质是远远不够的。大脑还需要通过新的连接多次发送信号，来强化记忆的储存。为此大脑需要倾注大量的努力，这是一个消耗能量的过程。所谓的“巩固”（consolidation），即长时记忆形成的过程，可以说是大脑能量消耗最大的活动之一。它主要在睡眠过程中实现，因此我们总说睡眠是十分重要的。</p><p>  再来看看长时记忆是如何得到巩固的。首先，当我们将注意力集中在某处时，就会向大脑发送信号——“这个很重要，得多倾注能量”。这样便形成了长时记忆。如果此时我们不能集中精力，那么长时记忆的转化就难以实现。大家都有过下班回到家发现想不起把钥匙放在哪儿了的经历吧。这就是因为放钥匙时注意力不集中。大脑没有收到相关信号，无法记住究竟把钥匙放在了哪里，因此不得不到处寻找。</p><p>  在吵闹的地方学习备考也是同样的道理。由于注意力难以集中，大脑无法接收到“这个很重要”的信号，自然也就记不住读过看过的内容。简单说来，此时我们更可能想起那些已经储存在大脑中的记忆，要想令新的记忆占据一席之地，就必须集中注意力才行。</p><p>  下一步则是将获取的信息储存到工作记忆中。只有这样做，大脑才可以通过“巩固”将长时记忆储存下来。当新的信息不断涌入时，大脑能够集中注意力的时间过于短暂，这当然不利于记忆的形成。同时，信息量爆炸也会导致大脑超过负荷。因为我们的工作记忆是有边界的。例如，在开着电视的状态下边玩手机边学习，大脑就会手忙脚乱地投入能量处理这些事务，它没有时间创造新的长时记忆，你也就没有学到你所读的东西。</p></li><li><p><strong>大脑热衷于走捷径</strong></p><p>  大脑是消耗能量最多的身体器官。成人大脑所使用的能量为20%，十几岁孩子的大脑则需要消耗大约30%的能量。而新生儿大脑所需的能量约占50%！生活在现代社会的我们当然可以尽情补充能量，但这对石器时代的祖先们来说并不容易。因此，大脑被“设定”成了与其他身体部位一样的模式，那就是尽量减少能量耗损，最大限度地高效处理事情。这就意味着大脑是喜欢“走捷径”的，尤其是在处理记忆时，因此储存记忆需要消耗能量。</p><p>  如果电脑可以代替大脑承担一些工作，大脑会觉得“求之不得”。相比储存下来的信息本身，回想它们储存的位置似乎更加轻松一些。如果研究人员要求受试者将每个句子放进一个word文档，分别保存在不同的地方，到了第二天，尽管他们能够记起的句子已经很少，但却能够准确回想起自己将文件保存在了哪里。</p></li><li><p><strong>反正要拍照的，还有必要去记住吗</strong></p><p>  一想到信息会被储存在别的地方，大脑就更“懒”了。我们将这种现象称为Google效应，或是数字健忘症。相比信息本身，大脑更加倾向于记下信息被储存的地方。</p><p>  既然如此，我们只需要依靠手机，利用Google或维基百科等工具就可以了，为什么还一定要去背诵记忆一些东西呢？这是因为，如果只是处理电话号码之类的东西，那么问题自然不大。但并不是所有的知识都可以通过在Google上查找的方式获取。如果想要适应这个世界，好好生存下去，或是试图提出一些批判性的问题，抑或是需要对某个信息进行评判时，我们就需要积累起很多知识。当信息从短时记忆转化为长时记忆时，所谓的“巩固”，并不是单纯将原始数据从大脑的内存（RAM）转移到硬盘里的一个过程。为了构建起知识体系，在“巩固”的过程中，需要将获取到的信息与个人的经验统合起来。</p></li><li><p><strong>手机比朋友更有魅力</strong></p><p>  我认为，如果旁边放了一部手机，人们可能就会觉得对话内容乏善可陈，心里变得十分浮躁。手机就是这样魅力四射，可以让我们周围的一切都变得黯然失色。</p><p>  多巴胺会告诉我们什么是重要的，应该将注意力集中在哪里。这里所谓“重要的”，并不是指考到一个好成绩、升职加薪，或是让心情变得愉快的那些事情，而是指那些对我们的祖先来说，能够让他们存活下来，将基因遗传给子孙后代的一些行动。假设手机一天可以给我们“注射”300次少量的多巴胺，这就意味着每次它都在要求我们“把注意集中在我身上”。</p><p>  记忆分别被储存在大脑的各个部位。例如，与事实和经验相关的内容通常被储存在被称为“记忆储存所”的海马中。相反，与骑自行车、游泳、打高尔夫等技能相关的记忆则主要由名为纹状体（striatum）的部分负责管理。然而，当我们在同时处理例如看电视、读书等多个任务时，这个过程中获取的信息也大多去了纹状体。这就说明大脑将与“事实经验”相关的记忆输送到了错误的地方。如果此时重新恢复到“只做一件事”的状态，信息又会被传送到海马去。</p></li></ul></li><li><p><strong>偷走时间的最大嫌疑人</strong></p>  <aside>  睡眠很重要，但人类的睡眠时间在减少，睡眠会受到压力核手机屏幕蓝光的影响。  </aside><p>  从前的一项实验结果表明，当受试者得知需要上交自己的手机时，仅仅10分钟内，他们的压力激素（皮质醇）的分泌便有所增加。这正是大脑表现出的战斗或逃跑反应。对于一直以来常常使用手机的人来说，这一变化尤为显著；而偶尔使用手机的人的皮质醇分泌变化则未如此明显。考察一下大脑发育的方式，你就会发现上述现象并不奇怪。人类为了生存下去，需要将精力集中在能让自己分泌多巴胺的事物上。如果每10分钟便夺走一些能增加多巴胺的东西，人自然而然会感受到压力，大脑也难免会认为某个生存必需品消失了。HPA轴得到激活，大脑大声呼喊道“快做点什么！我需要能给我多巴胺的东西！很着急！”，因此我们会感到强烈的不安，并不断努力满足自身需要。</p><p>  我们发现，压力与过度使用手机之间的确存在关联。尽管其带来的影响仅为轻微或中等程度，但如果当事人本身抗压能力较弱，手机对他造成的影响可能是难以忽视的。</p><ul><li><strong>人类的睡眠时间正在减少</strong></li></ul></li></ul><pre><code>- **睡觉时我们的大脑仍在运作**    积蓄能量并非睡眠的目的。实际上从大脑的角度来看，睡眠期间它所消耗的能量与人在清醒状态下相差不了多少。睡眠的作用之一，是让大脑以分解蛋白质的形式清理白天积累的废物。    睡眠不足还会使我们表现不佳。如果连续10天睡眠时间在6个小时以下，注意力就会下降，人会表现出仿佛24小时一直没能入睡的状态。同时睡眠不足还会让情绪变得不稳定。当给受试者展示各种表情的人脸照片并观察他们的大脑反应时，我们发现对于其中睡眠不足的人而言，压力应对系统的引擎杏仁核的反应更为强烈。    我们需要睡眠。最重要的原因或许是为了在晚上把短时记忆转换为长时记忆。    如果要说手机给我们带来的最大冲击，那便是大量剥夺了我们的时间，从而让我们变得难以保护自己免受抑郁症侵袭。例如用于运动、和他人交流，以及睡眠的时间，这些可以帮助人预防抑郁的时间，都被手机“偷走”了。- **压力为什么会干扰睡眠**    人体会根据周边环境来进行判断，分阶段入睡。也正因如此，在承受着诸多压力的状态下，入睡就会变得困难。因为大脑的HPA轴在感到压力时，就会像遇到非常危急的状况一样被激活，大脑会因此做出“床并非安全之地”的判断，于是变得更加活跃，导致我们无法入睡。就像远古时期一样，此时的大脑会让我们保持清醒状态。- **手机屏幕蓝光和睡眠时间的关系**    人体所受的光照会影响昼夜节律，褪黑素（melatonin）这一激素会告知我们的身体何时应该睡觉，昼夜节律因此应运而生。褪黑素产生自松果体（pineal gland）这一大脑的内分泌器官，它的分泌水平在白天较低，傍晚时分开始上升，夜间达最高值。而当暴露在过度的光照中时，褪黑素分泌就会受其影响，令身体出现错觉，以为现在仍是白天。因此，如果卧室光照过强，我们便难以睡个好觉。相反，褪黑素在相对黑暗的环境中会分泌更多，提示身体现在已是傍晚或夜间。    褪黑素分泌不仅受光照量影响，还与光照类型相关，特别是蓝光，有着抑制褪黑素分泌的功能。在祖先们生活的时代，蓝光只会出现在万里无云的天空里。    因此，如果在睡前使用手机或平板电脑，蓝光就会“督促”大脑一直保持清醒，抑制褪黑素分泌。而这样的影响会持续两三个小时，也就相当于将生物钟往回调了两三个小时。    哪怕已经放下手机，但只要它“待在”卧室里，睡眠也可能受到妨碍。一份以2000至3000名中学生为对象的调查显示，与其他学生相比，睡觉时将手机放在身边的学生，睡眠时间要短21分钟。- **电子书 vs. 纸质书**    首先，电子书也会影响褪黑素的分泌。不仅其分泌量可能因此显著下降，分泌时间也会被推迟至少1小时。我个人认为，电子书和手机是一样的，即二者都和新鲜的信息有着密切的关系，能够激活大脑的奖赏系统。光是把它们拿在手里，我们就能感觉“精神”。“就是个电子屏幕而已啊”，大脑遭到了欺骗，最终导致我们无法好好休息。- **每个人的敏感程度并不相同**    其实，对于压力和屏幕蓝光的敏感程度，每个人都不尽相同。如果睡眠存在问题，我们就需要尽量避免受到压力，同时尽可能减少在夜晚面对电子屏幕的时间。</code></pre><ul><li><p><strong>那些戒掉SNS后情绪变好的人</strong></p><ul><li><p><strong>我们都喜欢散布小道消息</strong></p><p>  掌握别人的动态、他们在各自的集体内部和成员的关系如何，对我们而言显然是有利的，所以人们都强烈渴望获得这些信息。进化使我们的大脑构建起了这样一种机制，能让我们通过含有丰富热量的食物或觉得自己过得很好的感受来给大脑提供奖赏。这种机制会促使我们充分摄取食物，避免饿死的悲剧。取得他人的信息并把它散播出去，也就是传小道消息的行为，其实也出于同样的原理。食物和小道消息就是这样帮助我们生存下去的。</p><p>  有趣的是，我们似乎尤为喜欢关注“负面新闻”。会议中途休息的间隙，听一个同事说上司因为喝得烂醉而出丑的事，大概远比听说上司做了一次相当精彩的报告要令人感兴趣。事实上，负面新闻能强化人与人之间的纽带。当两个人分享第三者的事情时，其中的负面新闻能使他们之间的关系得到巩固。</p><p>  那么，大脑为何会喜欢负面新闻呢？或许是因为负面信息尤为重要，它会带来一些值得相信的内容，同时警告人们哪些对象是需要保持距离的。基于同样的理由，我们对于人际矛盾也显得特别感兴趣。如果你有一个“敌人”，或许可以尝试找找是否还有其他人不喜欢那个敌人，这也许能帮助你找到潜在的盟友。</p><p>  那么，正面新闻又如何呢？站在大脑的立场来看，正面新闻是毫无价值的吗？恰恰相反。正面新闻能够让我们更加深思熟虑，并激励我们探索自我提升的方式。</p></li><li><p><strong>从摇篮到坟墓，人一直是社会性的人</strong></p><p>  通过小道消息来互相观察了解之所以重要，并不只是因为我们可以借此保护自己。与其他大部分动物不同，人类基本上是社会性的存在。因此才能互相合作，并以此生存下去。许多研究结果都已经表明，当生活在社会集体中时，我们就可能更长寿更健康；而被极端孤立时，则容易患病或在预期寿命之前早早死去。这样的结果并不奇怪。</p><p>  如今，我们通过散布小道消息、分享故事来尝试获取信息的强大社会性本能，渐渐被转移到了手机和电脑上。这一本能似乎已经在有史以来最成功的企业“Facebook”上扎根了。</p></li><li><p><strong>Facebook成功的根本原因</strong></p><p>  马克·扎克伯格确实成功勾起了我们内心深处的某种欲望，那就是“试图不断窥视身边人和事的欲望”。除此以外，引领Facebook走向成功的还有另一种人性的原动力——“人们想要谈论自身的欲望”。</p><p>  牛津大学进化心理学家罗宾·邓巴（Robin Dunbar）的研究表明，人具有和大约150个人建立关系的能力。</p><p>  邓巴曾论述道，是大脑皮质，这一大脑的外部“皮肤”、大脑中最为发达的部分，决定了人类和动物能够建立起的社会关系数量。物种的大脑皮质面积越大，就越能形成更大的集体来繁衍生息。</p></li><li><p><strong>我们都喜欢谈论自己</strong></p><p>  这就是说，我们在谈论自身的时候，大脑也能够获得“奖赏”。为什么会这样呢？这是因为，谈论自己能够让我们强化社会性关系、培养与他人合作的能力，同时知晓他人对我们言行的看法，通过观察他人做出的反应进一步调整自己的行为。因为这种内在奖赏机制的存在，我们每个人嘴里说出的内容中，有接近一半都在讲述自己的主观经验。</p><p>  一项针对大脑的研究让受试者分别讲述自己和他人的经历，当然此时所有人的奖赏系统都得到了激活，但是其程度却有所不同。有趣的是，奖赏系统激活程度最高的人正是最频繁使用Facebook的人！越是经常通过谈论自己来获得人气并以此激活奖赏系统的人，使用SNS的频率也就越高。</p></li><li><p><strong>为何使用社交媒体越多就越容易感到抑郁</strong></p><p>  孤独是一种体验，而现实里频繁使用社交网络的人们，从结果来看就更容易感到孤独。</p><p>  通过线上和线下方式与人接触会给我们带来不同的影响。一项针对5000余人进行的问卷调查研究了人们的身体健康、生活质量、整体心情，以及如何利用自己的时间、Facebook的使用时长等问题，最后得出的结果是，对现实关系，即线下实际与人接触，投入时间越多，越可能觉得自己生活得不错。而在Facebook上消磨的时间越多，生活质量就越可能变差。</p><p>  然而，为什么频繁使用SNS的人反而会感到更孤独、抑郁呢？是因为面对屏幕久了，和朋友线下见面的时间自然就减少了吗？答案也许是，这些人通过社交媒体上别人的动态，看到了许多总是“显得”很幸福的人，因而感到抑郁和孤独。人在社会阶层中所处的地位，会在很大程度上决定其精神健康受社交媒体影响的程度。</p><p>  5–羟色胺和平静、平衡以及内在力量有着密切联系。它不但能影响我们的情绪，而且与我们在集体中的地位相关。通过观察长尾黑颚猴族群，研究人员发现猴群中雄性首领的5–羟色胺水平比其他地位低下的猴子要高出近2倍。</p><p>  为何我们会在社交媒体上谈论更私密的事情？</p><p>  多项研究表明，有些内容人们在和他人面对面交流时觉得非常私密，到了网上却能事无巨细、若无其事地分享给他人。可以推测，这是因为在直面他人进行交流时，我们会刻意划分某种界限，而且能够看到对方的表情、手势。比如产生这种感觉时——“啊，他表情看起来好像有几分怀疑，还是不要多聊这个话题了”。如果没有机会当场得到反馈，这种自我审视也会消失不见。因此，我们在哪怕只有3个人的场合都无法谈论的私事，到了Facebook上却能坦然地向300人诉说。</p></li><li><p><strong>社会地位会给心情带来重要影响</strong></p><p>  5–羟色胺水平最高者并非只是具有成为首领的可能性，实际上他们通常就是处在首领地位的人。而当判断出自身拥有强大的社会地位时，5–羟色胺水平还会进一步上升。</p><p>  有趣的是，丧失首领地位的猴子不但5–羟色胺水平有所下降，其行动也发生了变化。它开始感到疲惫、有气无力，甚至表现出了抑郁。这都是伴随着5–羟色胺水平下降出现的。虽然无法把握具体的原因，不过有一种解释是可能的：5–羟色胺水平的降低引发了消极行为，这是退位的公猴为了不受到新首领的威胁而采取的自然方式。大自然赋予了我们这样一种机制，能让社会地位降级的雄性变得消极，开始韬光养晦。这样若是之后能重拾力量，便可能重新上位。</p><p>  这种机制在面对压力状况时也能发挥类似的作用。当长期处在高压状态下时，大脑就会让心情变得抑郁，从而让我们能在危险中自保。也就是说，当在集体中的地位下降时，大脑会给出这样的解释：现在该是保全自己的时候了，不能做出对上位的人具有威胁性的举动。大脑就是这样借助感情来操纵我们的行为，从而让我们获得平静，并主动疏远集体的。</p></li><li><p><strong>数码时代的嫉妒</strong></p><p>  大家都会发现，当从高位掉下来时，我们的内心就会产生波动。可以停下来想想发生这种情况的意义。当在和他人的竞争中处于劣势，尤其是当自己的地位比之前还要低下时，我们会感到焦虑、意志消沉。</p><p>  我们的祖先会跟同一部落的人竞争，排除掉老弱病残，实际上通常对手不超过二三十人。但如今的我们却需要和几十亿人竞争。不管是哪个方面，总有比你做得更好、比你更聪明、比你更有魅力、比你更富有、比你取得更大成就的人。个人所占据的社会地位能够影响我们的情绪。通过对这一事实进行考察，我们会发现新鲜的互联网世界会对我们的情绪造成影响似乎是理所当然的。毕竟这个世界就是一个能以各种各样的方式不断让我们将自己和他人进行比较的地方。</p><p>  我们完全可以怀疑，SNS就是那个削弱我们自信感的“凶手”，而这种情况也的确正接连不断地发生着。Facebook和Twitter的用户中，每三人中就有两人对“你是否对自己不满意？”这一问题给出了肯定的答案。因为每天都能看到许多比自己更聪明、更成功的人，于是不管做什么都会觉得对自己不满意，至于外貌方面那就更不用说了。</p></li><li><p><strong>是先有鸡还是先有蛋</strong></p><p>  表面上看来，Facebook是一种非常重要的资源，能满足人类对于社交的基本需求。但研究结果告诉我们，Facebook可能并没有增进人们内心的平和，反倒是让我们的情绪恶化了。</p></li><li><p><strong>社交媒体以多种方式影响着我们</strong></p><p>  同时，使用社交媒体的方式也会给情绪造成影响。那些只是翻看他人的照片，自己从来不发内容或从不留言评论的被动用户，相比主动用户更容易感到萎靡不振。</p><p>  在SNS上得到了好友强力支持的人，会将其当作社会生活的辅助工具以及和朋友熟人联络的手段，这样的使用方式通常都会带来正面影响。与之相反，将SNS当作社会生活替代品的人，情绪可能会陷入低落。多项研究表明，本身就有抑郁倾向、同时又缺乏自信的人群过度使用社交媒体的话，情绪和自信心变差的可能性也相对较高。</p></li><li><p><strong>被社交媒体捆绑的“00后”</strong></p><p>  众多研究结果都已经表明：“社交媒体能让一部分十多岁的孩子和成人的心情变得抑郁、容易感到孤独，甚至可能损伤他们的自信。”</p></li><li><p><strong>一见到他人就会变得活跃的镜像神经元</strong></p><p>  镜像神经元是一种通过模仿他人来帮助我们学习的脑细胞。这就是当有人向新生儿吐舌头时，新生儿也会跟着吐舌头的原因。镜像神经元能帮助我们学习身体动作，是一种存在于大脑众多区域中的重要细胞。体感皮层（somatosensory cortex）也是这些区域中的一种，它能够帮助我们理解他人的情感。当我们看到一张照片里有人被门夹到了手，就会产生和当事人类似的大脑活动——即使不会真的直接感受到疼痛，也多少会有一些难受。</p><p>  镜像神经元会通过直接模仿他人行为来帮助我们理解和体验他人的疼痛、喜悦、悲伤和恐惧。它相当于为我们搭起了一座连接外部世界和内在世界，即他人和自我的桥梁。尝试去理解他人的本能欲望被称为心理理论（theory of mind）。</p><p>  镜像神经元是我们与生俱来的，它的存在似乎意味着，人会渴望理解他人的想法和情感也是先天决定的。</p><p>  如果想让大脑的镜像神经元最大限度地发挥作用，我们就需要在现实生活中与他人接触。研究者比较了直接与他人见面时和观看戏剧、电影时镜像神经元的活跃程度，结果表明，在现实生活中与他人见面时，镜像神经元最为活跃（其次是看戏剧的时候，最后才是看电影的过程中）。虽然看电影时镜像神经元也能被激活，但其活跃程度不如前面两个。这就意味着，通过画作或者屏幕间接与人“接触”时，帮助我们深入理解他人想法和情感的生物学机制可能无法得到充分的激活。</p></li><li><p><strong>自恋已成潮流</strong></p><p>  对我们而言，能够理解他人的想法和感受十分重要，是培养共情能力的基础。共情能力意味着我们能够推测到他人正在经历的痛苦。大脑想要理解身体的疼痛并不困难，但当这种疼痛变得“抽象”时，问题也会变得相对复杂。看到一张断腿的照片，大脑中对疼痛做出反应的区域就会马上被激活，仿佛自己亲身体验了疼痛一样。但是如果有人内心受到了伤害，大脑要对这一事实做出反应则需要更久的时间。例如如果他人正在忍受抑郁症的折磨或离婚带来的悲伤，比起断腿，这些疼痛就显得更加难以让人“感同身受”。</p><p>  接下来要说的内容只是一种推测。在数字化世界里，我们可以通过SNS接触到全世界的人，生活圈子也变得更为广阔，还能对他人的生活进行深入的观察。那么，我们的共情能力也理应变得更加发达吧？这种可能性是存在的。但实际上，在综合70余项研究结果后我们发现，腾格和坎贝尔的观点是切中要害的。一项研究针对4000名大学生进行了调查，结果显示，自20世纪80年代以来，参与者们的共情能力在不断减弱。其中两种能力的减弱程度最为显著：一个是同理心（empathic concern），即感受身处困境之人的痛苦的能力；另一个则是人际敏感（interpersonal sensitivity），即站在他人立场上看待这个世界的能力。这两种能力的减退并不只出现在大学生身上，许多中学生也出现了这个问题。这就意味着，从20世纪80年代以来，人们变得更加容易沉浸在自我陶醉中了。</p></li><li><p><strong>是谁在吸引你的注意力</strong></p><p>  全世界每年有数十亿美元的资金被投入广告市场。过往只存在于报纸、电视、街头的广告已经飞速流入我们的手机里。考虑到我们大脑运作的方式，这样的现状并不令我吃惊。众所周知，想要形成长时记忆，对某个事情的“关注”就是其中的第一步，这也是我们在识别商业信息时采用的重要标准。我们需要记得自己到底想要什么。大家应该都知道，社会性信息是十分重要的，会对我们的生存带来帮助。</p><p>  家应该都看到过Facebook和Instagram信息流中间插入的广告。这些广告的摆放非常讲究，我们很难将它和朋友们发的状态区分开来。广告的推送是有针对性的，会在用户对其接受程度最高的时候进行投放。例如，向刚刚在Facebook上看了足球比赛照片的人推送体育活动广告就是合适的方案，而给旅行目的地照片点了“赞”的人也会对预订机票更为关注。</p><p>  在这个令人眼花缭乱的世界里，注意力的价值堪比黄金，而站在市场人员的立场来看，没有比手机更为实用的营销手段了；要在手机上投放广告，也没有比社交媒体更加有效的方式了。</p></li><li><p><strong>天下没有免费的社交媒体</strong></p><p>  对于以Facebook为首的其他社交媒体而言，其最为重要的财产就是人们的关注。因此从社交媒体的角度来看，它们需要生产出能够吸引人们注意力的产品，否则破产就是不可避免的。因此，“夺取注意力”的数字时代商业战争愈演愈烈。App开发者、手机制造商、博彩行业从业者和社交媒体都在使用比以往更为巧妙的机制，试图在这场战争中成为赢家。为了获得消费者的关注，它们正越来越熟练地利用着我们大脑的多巴胺系统。</p><p>  Twitter也想出了一个独特的方法。只要点开手机上的App，那只白色的小鸟就会在蓝色背景里反复变大变小。这样两三次之后，画面突然放大，所有推文填满屏幕。这并不是因为登录需要时间，也跟网络连接状态无关，Twitter就是故意借此来制造紧张氛围。这段延迟的时间，是在对大脑以最佳状态启动奖赏系统所需的时间进行精巧测定后设置的。此外，很多时候App的消息推送提示音跟短信提示音一样，这也并非偶然。同样的提示音会让我们误以为是朋友发来信息了，从而激发大脑的社交互动需求，尽管它推送的可能只是某件商品的打折信息。</p><p>  Facebook、Snapchat、Twitter并不是给我们提供了一个空白的平台，让我们在上面自由自在地发消息、发照片并通过“点赞”表达认可。它们制造的产品正是我们的注意力。为了把用户的注意力卖给各种各样的广告主，它们会通过消息、照片、点赞“收购”注意力。如果你以为自己正不花一分钱免费使用着社交媒体，那就大错特错了。</p></li><li><p><strong>是我在玩手机，还是手机在玩我</strong></p><p>  也曾有人主张，去操心技术是如何被研发设计出来的毫无意义。技术只不过是技术而已，只要人能适应就行。但我觉得这一观点是错误的。技术并不像天气，不管好坏都得接受。应该是技术来迎合人类，而不是人类去适应技术。</p></li><li><p><strong>有10%至15%的狩猎采集者是被他人杀死的</strong></p><p>  在狩猎采集时代的祖先中，有10%至15%都是被他人杀死的。原始农耕社会的情况更为糟糕，每五人中就有一人死于他人之手。我们推测这些战斗都是为了抢占更多的资源。这还只是部族内部的杀人事件统计，如果连带和其他部族之间的战争一起统计，情况应该会更为严重。那批离开自己的部族去寻找新出现的智人的人实际上是走上了一条死亡之路。这阴沉的数字能告诉我们什么呢？所谓的“站队本能”，对于人类而言，是最为重要的社会性原动力之一。看到外貌与自己不同的人时我们会感到不安，也都是因为这种本能。杏仁核这一恐惧制造机在我们遇到无法了解的对象时便会立即做出反应。</p><p>  但因为面对陌生事物时会本能地产生恐惧，我们似乎特别容易受这种外貌差异的影响。“宁可错杀，也不放过”，杏仁核当然会选择多拉响一次警报。这就是火灾报警的原则！杏仁核在遇到不认识的人时就会提醒我们以合理的方式应对，而当对方的长相看起来与我们自身特别不同时尤其如此。</p><p>  如果你问我是不是充满偏见，那我肯定会马上否定。但另一方面，和其他很多人一样，我的偏见也比自己想象的要多得多。大脑会以我们都无法意识到的速度飞速对眼睛看到的东西下结论。但这并不意味着我们应该无限顺从它，表现出“种族歧视”的反应。这种以往流传下来的进化糟粕还是会在无意识中影响我们。回顾人类充满腥风血雨的历史，这种面对陌生的“异族”时产生的恐惧其实是相当合理的，但它显然与当今世界背道而驰。</p></li><li><p><strong>虚假新闻永不消失</strong></p><p>  我们强烈渴望划分“我们和他们”的界限，这就像内心在面对灾祸和威胁时产生的恐惧一样，但这种渴望会在今天这个互联网世界给我们造成巨大的影响。</p><p>  报纸和电视的新闻编辑团队能够人为决定他们要展示的内容，并且判断这些新闻是否有趣和真实。与之相反，Facebook信息流里的新闻则是通过电脑程序，即算法机制，选定出来的。换言之，通过Facebook流传开来的新闻报道，是没有编辑团队为其真实性背书的。算法会选择用户可能感兴趣，也就是其好友都在阅读、分享的内容进行推送。至于这些新闻真实与否则显得并不那么重要。</p><p>  历史上，有大约10%至20%的人类都是被他人杀死的，于是那些涉及纷争与威胁的新闻更能吸引人们的关注——毕竟这类信息重要到了事关生死的地步。</p><p>  研究人员针对社交媒体上流传的数万条新闻展开了调查，结果显示，虚假新闻不光被更多的人分享，传播速度也更快，而真实新闻的传播速度要想赶上虚假新闻，至少需要多花费6倍的时间。虚假新闻更具煽动性，不必顾忌真相。一旦用户点进虚假新闻，算法就会提升其优先级，将它放在信息流的最顶端。人们具有接力分享虚假新闻的倾向，所以并不能将问题完全归咎于算法。虽说一开始的确是算法将虚假新闻送到我们手上，但它却没有强迫我们进一步分享。随着“人云亦云”的愈演愈烈，虚假新闻也就被误以为真了。</p></li><li><p><strong>是时候减少电子产品的使用了吗</strong></p><p>  针对150多名美国大学生展开的一项问卷调查结果表明，在“抛弃”Facebook之后，一部分学生心情良好，另一部分学生则略感不适。接受问卷调查的学生们被分成了两组，一组正常使用社交媒体，另一组则被限制使用Facebook、Instagram、Snapchat等SNS （每次最多使用10分钟，一天30分钟封顶）。<br>  3周后，每天仅可使用30分钟SNS的学生们情绪得到了改善。对在研究开始时有抑郁症状的学生们而言，抑郁感与孤独感也得到了缓解。这也许可以证明，许多人并不是因为原本就抑郁才深陷SNS不能自拔，的确是社交媒体的使用加剧了他们的抑郁倾向。但这项研究的初衷并不在于呼吁人们彻底抛弃社交媒体，只是希望证明这样一个事实：通过减少社交媒体的使用时间，就可以达到改善心情的效果。</p></li></ul></li><li><p><strong>数码产品会给孩子带来哪些影响</strong></p><ul><li><p><strong>孩子们对手机的依赖</strong></p><p>  在私人派对上，如果你站在一盘装满薯片的盘子前，大脑中的一个系统就会暗示你立刻将整盘薯片吃掉。但与此同时，另一个系统则会提醒你夏天很快就要来了，一定要控制住自己，注意管理身材。大脑各个系统的发育速度是不一样的。位于额头后面的额叶发育速度最为缓慢。额叶起着抑制冲动情绪及延迟满足的作用，要到差不多25岁至30岁才能完全发育成熟。告诉我们“不可以把薯片全部吃光”的额叶在童年期和青春期相对沉默，而这时候不断怂恿我们“快把薯片全部吃光”的脑区最为活跃。</p><p>  而负责抑制冲动行为的大脑区域，并非单纯帮助我们控制“吃薯片”这一行为，也能帮助我们抵抗想要拿起手机的冲动。然而，由于大脑的这一区域在儿童和青少年时期尚未完全发育成熟，因此数码产品对孩子们来说有着难以抵挡的巨大诱惑力。</p></li><li><p><strong>十几岁正是多巴胺分泌最旺盛的阶段</strong></p><p>  所谓多巴胺指数，实际上指的是多巴胺系统的活性，即大脑能够分泌多少多巴胺，以及所分泌的多巴胺有多少能够与大脑细胞表面的受体相结合。</p><p>  多巴胺系统的活跃度会随着时间的流逝减少，大概每10年会减少10%，但这并不一定是件坏事。随着年龄的增长，大脑多巴胺的分泌指数虽不如从前，但经历危险的概率也会变小。在青少年时期，多巴胺分泌最为旺盛。此时，一旦受到奖赏，大脑就会快速分泌大量多巴胺；相反，如果感到失落，多巴胺的分泌就会立即减少。因此，十几岁正是多巴胺分泌值起伏最大的时期，特别能够体会到“活着的滋味”，大喜大悲的感受尤为强烈。这时如果恋人向自己提出分手，产生的悲伤情绪也确实可能更加刻骨铭心。</p><p>  青少年时期，不仅控制冲动情绪的大脑系统尚未发育完善，大脑还容易分泌大量的多巴胺，在这两种因素的综合影响下，青少年们可能十分容易陷入危险的状况之中。</p></li><li><p><strong>使用数码产品学习根本无益于孩子</strong></p><p>  多亏了《五只蚂蚁比四只大象多》之类的节目，孩子们扎扎实实地掌握了不少数字和单词，甚至连阅读能力都得到了提升。然而也有不少研究表明，想让孩子通过教育类电视节目学习到有用的知识，至少应该等到快入学的年龄。两三岁的孩子年龄尚且太小，往往难以收获良好的学习效果。他们在与父母或他人的交流过程中，反而可能学到更多的东西。</p></li><li><p><strong>逐渐退化的自制力</strong></p><p>  这个棉花糖实验的结果告诉我们，如果从小就拥有自制力，长大了之后也可能在生活中获得更多的机会。不过延迟满足的能力，即自制力，这个东西并非与生俱来的，它受个人成长环境的影响，是可以通过后天训练培养起来的。</p><p>  研究团队找来几个从未使用过手机的人，交给他们一部手机并让他们使用。其实在当今社会，想要找到完全没有碰过手机的人，几乎是不可能的。这个实验的目的就是要观察在被手机“污染”了之后，这些受试者的延迟满足能力是否会受到影响。最终在使用了手机3个月之后，一连串测试的结果显示，受试者们已经难以做到延迟满足了。<br>  延迟满足能力下降，就可能导致我们很难花时间去学习和熟悉一样东西。</p></li><li><p><strong>手机使学习能力下降</strong></p><p>  首先，根据美国研究者的调查，如果不将手机带进教室，孩子们就能在课堂上记录下更多的知识内容，对课程内容的印象也会更加深刻。在之后被问到课堂上所学过的知识时，这些孩子能够回想起的内容也更多。</p><p>  其实在阅读时，纸质书带来的阅读效果可能也更好。在挪威，有学者针对中学生进行了实验，他们让一半学生阅读纸质书，另一半学生阅读电子书。结果显示，尽管是相同的内容，但阅读纸质书的学生对书本内容印象更深，他们尤其记得故事的叙述顺序。对此较为合理的解释是，我们的大脑习惯了通过数码产品来阅读邮件、短信、了解实时的资讯，从而获得即时满足，根本无法集中精力阅读文字。使用电子产品阅读时，大脑需要花费更多的精力去抵挡手机本身的诱惑，因此学习能力必然会下降。</p></li><li><p><strong>让手机从教室里消失会如何呢</strong></p><p>  从这一调查结果可以看出，对于某些特定的学生，尤其是成绩优异的学生来说，携带手机进入教室也许能够成为一件好事，至少他们不会受到负面影响。然而对于其他学生而言，手机的确分散了他们的注意力。综合来看，手机带来的影响应该是因人而异的。</p></li><li><p><strong>睡眠越来越差的青少年们</strong></p></li></ul></li></ul><pre><code>- **越沉迷于手机，越不幸福的人们**- **患上抑郁症的青少年人数大幅增长**    手机真的是导致青少年出现焦虑和抑郁情绪的原因之一吗？这当然不是百分之百的，但使用数码产品时间更长的青少年们的确更容易感到悲伤和焦虑。- **人类史上的巨变，移动互联网**- **我们是否可以离开手机生活**- **玩一玩有利于提高注意力的电脑游戏如何**    我想要再次强调的是，我们无须将一切与数码产品相关的东西都贴上警告标签。此外，认为人类在数码产品面前能够做到自制的想法也是天真的。如果认为将手机交给一个7岁孩子后，告诉他要悠着玩，他就会照办，这显然是一种幻想。</code></pre><ul><li><p><strong>想要有所改变，就先运动起来</strong></p>  <aside>  运动十分有用，可以一周三次，每次运动45分钟。  </aside><p>  许多人持续承受着压力，无法很好地集中注意力，在爆炸的信息海洋里苦苦挣扎。对于生活在这个时代的人们来说，运动就是明智之举，甚至可能是最棒的选择。</p><ul><li><p><strong>信息海啸</strong></p><p>  在进行测试前做20分钟运动的成年受试者的测试成绩更好，这表示他更能控制冲动情绪。即使不运动，只是散步或慢跑，也能感受到效果。最好的方法是坚持几个月的规律运动。</p></li><li><p><strong>稍微活动身体就能见效</strong></p><p>  在这个时代，想要提高孩子们的注意力并不容易，可实际上只需运动5分钟，状况就会有所改善。这对于注意缺陷与多动障碍患儿来说，效果尤为显著。</p><p>  运动能给注意力缺乏的现代人带来正面的影响。此外，身体活动在提高我们制订计划以及转换注意力等能力上也有着十分积极的作用。十几岁孩子偶尔散散步或跑一跑，就能收获一些效果。不过，如果想要切实提高执行力，则需要坚持规律运动几周或几个月。</p></li><li><p><strong>为什么运动能使人集中注意力</strong></p><p>  也许是因为，我们的祖先在捕猎或逃命时，最需要高度集中注意力。</p><p>  在进行身体活动时，我们的注意力也会不自觉地得到强化。但是在现代社会里，我们既不需要捕猎，也不需要为了逃避野生动物的追捕而奔跑逃命，只有静静坐在书桌前学习或工作时才需要集中注意力。此时就需要利用运动刺激“来自远古”的大脑生存机制，使其最大限度发挥出作用。现在一些学校就采用了这样的方式，并收获了相当不错的效果。</p></li><li><p><strong>缓解压力与焦虑的良药——运动</strong></p><p>  我曾见过数百位利用身体活动来激活大脑潜能的人。他们对此评价说，实际上，身体活动所产生的最好影响并非专注力改善，而是缓解压力与焦虑。</p></li><li><p><strong>应对压力的安全气囊</strong></p><p>  对于压力大或患有焦虑症的人来讲，运动能够减少痛苦。</p><p>  压力应对系统形成于“面对野生动物时究竟是逃跑还是战斗”那个古老的时期，也就是说，如果有良好的身体状态支撑，会计师便不太容易焦虑，因而在看季度报告和做演讲时，并不一定需要启动压力应对系统。</p></li><li><p><strong>我们运动得越来越少</strong></p></li><li><p><strong>做多少运动最适合</strong></p><p>  毫无悬念，结果显示，运动的确能给我们的思维能力带来正面的影响。散步、瑜伽、跑步和肌肉运动等都会产生积极效果。坚持运动之后，大脑思考速度的提升最为显著。因此，如果能够多多活动身体，我们的思维就会变得更加敏捷。</p><p>  如果在6个月的时间内能至少进行52个小时的运动，效果便会达到最佳。也就是说，1周需要运动两个小时。拆开来看，1周3次，每次运动45分钟即可。尽管并不是运动时间越长就能对大脑产生越好的影响，但至少运动得越多，身体就会变得更好。站在脑科学的角度来看，只要能够坚持每周运动两个小时，效果就会在某个时刻开始显现。</p><p>  如果能够提高心率，大脑就能收到更好的效果。但就算只是慢悠悠地散步，也能够带来令人惊喜的效果。如果可以试着尽量提高心率，那更是锦上添花了。</p></li></ul></li><li><p><strong>大脑至今仍在持续变化着</strong></p><p>  因此，并不是说100年前的人们就比现在的我们更笨。他们和我们一样，在自己所处的时代完全能够正常生活。而我们智商看似提高了，则是因为我们得到了更多的和抽象思维和数学思维相关的训练，其中最重要的是接受了更高水平的教育。</p><ul><li><p><strong>我们逐渐变低的智商</strong></p><p>  每个时代都会出现人们的智商提高的现象，这被称为“弗林效应”（Flynn Effect），是以新西兰的詹姆斯·弗林教授的名字命名的。但是，之所以会产生弗林效应，并不完全是因为我们的生活逐渐变得数字化。从1920年起，每10年智商就会表现出提升的趋势，但当时可没有出现电视或网络这些东西。</p><p>  弗林教授表示，智商逐年下降可能是因为，现在学校的课程难度大大降低了，作业量也减少了很多，但我们仍然与二三十年前一样，不重视发展学生的理解能力。他还补充道，运动量的减少也会带来一些影响。再加上身处信息爆炸的环境，我们的脑子确实可能“不太够用”。</p></li><li><p><strong>我们的大脑仍在不断变化着</strong></p><p>  “学习会让海马得到发育，体积增大”，这就意味着大脑是可以改变的，可塑性极强。</p><p>  我们在很多方面都依赖手机和电脑，久而久之除了认路之外，也许还会失去其他抽象思维能力。但与此同时，在这个过程中，我们不也可以学习到一些其他的有用技能吗？有了GPS指路，我们就可以在驾驶时听听播客，或集中精神去思考工作中出现的一些问题。我想这也是事实。不过，我们不可能将生活的一切都交付给电子产品和科技。人生在世，需要掌握一些特定知识，也应该带着批判质疑的态度去处理外界的信息。身处日益复杂的时代，我们更加需要保持这样的态度。现代社会已经不同于以往，虽然它似乎使人类变得越来越聪明了（弗林效应），但由于我们将太多该动脑思考的问题交给了电脑和手机处理，这样的行为也可能使我们变笨。这说不定就是生活在斯堪的纳维亚半岛的人们智力下降的原因。</p><p>  不少学者们都预测，在未来，自动化科技和人工智能可能会导致许多职业种类消失，而留存下来的也许就是考验注意力的工作。讽刺的是，在数码时代，人类最应该具备却正在逐渐减退的能力，正是注意力。</p></li><li><p><strong>技术发展和精神障碍的问题</strong></p><p>  现代社会，新技术是无处不在的，我们一天24小时都与新技术“生活在一起”，而在此前的世界，尽管新技术已经出现，但却没有人会每天坐六七个小时的火车，也没有人能够每天打6个小时的电话，当然也没有人随时随地都在看电视。可今天的我们却手机不离身，无时无刻不在使用电脑。这是前所未有的一个现象。</p></li><li><p><strong>没时间研究了！</strong></p><p>  那就是，每一项研究都需要耗费漫长的时间。从开始计划到招募实验对象，再从分析数据到将研究结果发表到学术期刊上，通常至少需要花费四五年的时间。相比研究进行的速度，数码技术发展的速度显然更快。</p></li><li><p><strong>我们正在逐渐失去什么</strong></p><p>  正如前面所提到的那样，注意力容易涣散是人类的本能。手机简直是人类这个弱点的“天敌”</p><p>  通常只有注意力高度集中的人，才能为人类社会带来大规模的文化、技术、学术等方面的进步。</p><p>  作家尼古拉斯·卡尔（Nicholas Carr）就活字印刷术是如何在各个层面帮助我们集中注意力这一点进行过说明。他认为，阅读书籍的人，会在瞬间闯入他人的想法和思维中去，将精力集中在书本内容上，而互联网却恰好与此相反。相比深入思考，它会让我们变得更加喜欢追逐新鲜事物，快速不断地为我们注入多巴胺，最终使得我们停留在一切事物的表面。</p></li><li><p><strong>我们仍然处于进化的过程中吗</strong></p><p>  是的，如今的我们仍然在不断进化着，进化过程还在继续。实际上，进化是不会真正停下来的。不过，目前人类的进化速度可能比从前缓慢了不少。这一推测说来让人有些悲伤，但搞不好是事实。</p><p>  那么，如今的我们最终也会进化出“更有利于打字的”大拇指和与生俱来的理解编程语言的能力，从而适应自己所处的数码世界吗？我并不这样认为。虽然进化会让那些有利于生存和繁殖的特征成为一种普遍，并淘汰掉不具备这些特征的那一批人。但今天人类的生存本身就不存在太大问题。</p><p>  也许将来遗传工学会被广泛运用于改变人类的特质。从身高到个性，从运动细胞到智力方面，都可能得到“人为的”改变。进化被操控，逐渐变得“非人类化”，不少人都害怕真的出现这样的“新人类”。如果可以乘坐时光机穿越到几千年后的世界，你希望见到怎样的人类？我还是最想遇到像你我一样的，普通人类。</p></li><li><p><strong>我们真的变得越来越抑郁了吗</strong></p><p>  在我上高中的20世纪90年代，“看心理医生”这件事是难以想象的，当时的我们想起这件事，脑子里出现的都是穿着精神病服，被关在狭窄房间里的画面。所以当时尽管很多人心理健康出现了问题，也没能得到解决。如今人们都乐于寻求帮助了，这是一个很好的现象。受此影响，自20世纪90年代以来，瑞典的自杀率降低了30%。</p></li><li><p><strong>快乐不是理所当然的事</strong></p><p>  人类不会本能地感到快乐。在从前的世界，有一半的人类在10岁之前死去，平均期望寿命仅为30岁，造成人类死亡的主要原因甚至不是癌症或心血管疾病，而是感染、饥饿、被杀害、意外事故、野生动物袭击等。在这样的社会，感到焦虑不安和神经紧绷，本身就能给生存带来帮助。也就是说，相比安稳舒适，我们的祖先更多会感受到不安。</p><p>  一般来说，动物会在既定的环境中，逐渐演化出符合环境的特质，以此来提高自己生存的可能性。这就是所谓的“进化压力”（evolutionary pressure）在起作用。</p><p>  然而，“进化压力”并不会促使我们变成快乐的人类。这是因为，“快乐”并不会提高我们的生存概率。对于人类来说，真正起作用的是“强者才可以生存下来”这一原则，它会让我们采取避开危险或斗争的行动。因此相比愉快和平和的情绪，焦虑和抑郁感受可能是更有利的。</p><p>  明明一切都很好，为什么我却觉得不高兴呢？”也许不少人都存在这样的疑问。这其实是因为，对于长久地感到快乐这件事情，大自然并没有赋予它太大的价值。在吃到美食时、与朋友见面时、享受性生活时，或是升职加薪时，我们都会感到一时的快乐，大自然将我们“设置”成了这样的模式。但是这种快乐很快就会被进一步的欲望所取代，我们总是渴望更多的美食、性爱，更高的职位、薪水。这其中当然也存在一定的理由，那就是“为了让人类不断行动起来”。</p><p>  我想告诉大家的是，我们并非一定会变得不幸，这也并非人类逃避不了的命运。我们完全可以通过合理安排睡眠，做各种运动，建立良好的社会关系，适当地接收压力，减少炫耀和攀比等举动来让心情变得愉快舒适。对我们来说，真正重要的就是预防精神健康出现问题，而不是出现问题之后依靠药物解决。</p><p>  我们也不能说“反正人类从古至今都不快乐，现在这个状况你就认了吧”，而是要积极寻找方法转换心情，帮助那些感到抑郁和焦虑的人摆脱困境。“我们真的比20年前更抑郁了吗”这个问题可以慢慢琢磨，重要的是，不能认为痛苦是大自然赋予人类的，或我们与生俱来、本就应该承受的东西。</p></li><li><p><strong>网络会让我们变成傻瓜</strong></p><p>  正如热量会给我们的健康带来好处和坏处一样，数码化也同样是把双刃剑。只需动一动手指就可以获取全世界的信息，这对我们的祖先来说是做梦也想象不到的事情。身处数码时代，我们可以更加有效地发挥各种能力，尤其是人类的创造力。然而，如果我们每天都要摸上几千次手机，就无疑是给大脑投入了一颗炸弹，一定会有恶劣的后果随之而来。人们的注意力越来越涣散了，我们顺应着这种涣散，甚至在没有分散注意力的事物时，也无法集中精力。短信、Twitter、Facebook等带来了越来越多的碎片化信息，我们对于系统化知识的接受能力越来越低。人类面临着史无前例的时代性问题。</p><p>  一定要懂得“聪明地”使用数码设备，明白其中的问题所在。否则我们就会像适应膨化食品带来的毫无营养价值的热量一样，陷入渐渐适应数码时代的危险之中。手机既可能成为一种加持，也可能将我们拖进泥潭。</p></li></ul></li><li><p><strong>“自然的”并不一定就是好的</strong></p><p>  大家一定都看到过“像原始人一样吃饭，变得健康起来吧” “像原始人一样生活，变得健康起来吧”之类的书名吧？它们都主张远古的生活方式对我们来说是最自然、最有利于健康的。然而这种说法其实是陷入了自然主义谬误（naturalistic fallacy）的圈套。不能仅仅因为我们的祖先过着“自然的”生活，我们就顺理成章地将其视作更好的选择。祖先们一旦发现食物就会将它们吃得一干二净，这对今天的我们来说并不是好的“榜样”。</p><p>  不那么“自然的”东西并不少见。比如可以想想避孕工具。如果是处在“自然的”状况下，性生活之后人就可能怀孕，但今天我们可以通过避孕工具阻止这一情况的发生；如果是处在“自然的”状况下，人就可能因为心律不齐而死亡，但今天我们可以通过心脏起搏器避免这一后果。从进化论的角度来看，所谓“自然的东西”，是不好也不坏的。</p></li><li><p><strong>附录 献给旅行在数码世界的人们的安全手册</strong></p><ul><li><p><strong>应该做到的基本事项</strong></p><p>  <strong>检查使用手机的时间。</strong></p><p>  可以下载一个App，来监测自己有多频繁触碰手机以及使用的时间有多长。这样可以清清楚楚地看到手机究竟“偷”走了我们多少时间。认知是变化的第一步。</p><p>  <strong>购买闹钟和手表。</strong></p><p>  有的事情就不必托付给手机了。</p><p>  <strong>每天关机1小时至2小时。</strong></p><p>  告诉身边人你已经决定每天关机1小时至2小时了，这样他们就不会因为你没有回复信息而感到烦躁或生气。</p><p>  <strong>关掉所有的待办事项提醒。</strong><br>  <strong>将手机设置成黑白背景。</strong></p><p>  非彩色的界面会让多巴胺的分泌减少，多巴胺减少分泌之后，我们想滑动屏幕的迫切感也会降低一些。</p></li><li><p><strong>在工作中</strong></p><p>  如果是在处理需要高度集中精力的事情，就将电话放置在别处，不要放置在手边。<br>  规定一个专门用来查看短信和邮件的时间。例如每小时拿两三分钟来进行处理。</p></li><li><p><strong>在与人相处时</strong></p><p>  跟朋友在一起时，将手机调至静音，并放置在稍微远一点的地方。将注意力集中在对方身上。这样才会收获愉快的相处时间。<br>  看手机这个行为具有传染性。当你决定不看手机时，就会产生多米诺骨牌效应，其他人也才会做出跟你一样的举动。</p></li><li><p><strong>给孩子们的建议</strong></p><p>  不要将手机带进教室！手机一定会妨碍学习。<br>  减少对着电子屏幕的时间，做些其他活动。成人或儿童每天使用手机和面对显示屏的时间都不应该超过2小时。8岁以下的孩子每天将时间限制在1个小时内最佳，同时应该做一些其他的娱乐活动。可以将做作业、运动、见朋友的时间都规定好。</p><p>  给孩子做出榜样。我们是在相互模仿的过程中不断学习的。孩子会模仿大人的行动。</p></li><li><p><strong>睡觉时</strong></p><p>  准备阶段，至少提前1个小时关掉手机或笔记本等电子设备。<br>  对于神经敏感，会被一点小小的问题影响睡眠的人，则不应该将手机放在卧室。如果需要早起，使用闹钟即可。<br>  如果的确需要将手机放在卧室，则应关掉不必要的闹钟，将手机设置成静音模式。<br>  不要在躺下后查看与业务相关的邮件。</p></li><li><p><strong>压力问题</strong></p></li><li><p><strong>身体活动和大脑相关问题</strong></p><p>  一切的活动都对大脑有益。同时，增加心跳次数是最为有利的。当然这也不是说一定要跑完一场马拉松才算数。对大脑来说，只是散步也能带来很多益处，如果能让心跳加快，那就再好不过了。最重要的是实践。<br>  如果希望通过身体活动，尽可能地释放压力，提升注意力，可以每周运动3次，每次45分钟，要运动到出汗、气喘吁吁为止。</p></li><li><p><strong>SNS相关问题</strong></p><p>  只关注那些你想多多沟通交流的人。<br>  仅将SNS视为沟通交流的工具。积极回应他人的留言，培养起良好的归属感和亲密感。<br>  将手机里的SNS卸载，只在电脑端使用。</p></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>阅读浪漫小说</title>
      <link href="/books/%E9%98%85%E8%AF%BB%E6%B5%AA%E6%BC%AB%E5%B0%8F%E8%AF%B4/index.html"/>
      <url>/books/%E9%98%85%E8%AF%BB%E6%B5%AA%E6%BC%AB%E5%B0%8F%E8%AF%B4/index.html</url>
      
        <content type="html"><![CDATA[<p>&lt;/aside&gt;</p><p>推荐程度：一般<br>读书笔记未完成</p><aside></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>控糖革命</title>
      <link href="/books/%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/index.html"/>
      <url>/books/%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><aside>📗### 概括这本书</aside><p>讲的是葡萄糖峰值相关内容，包括为什么要注意葡萄糖峰值、葡萄糖峰值带来的危害以及轻松控糖的10个小窍门。</p><aside>📘### 我的感想</aside><p>原因不仅要注重吃的成分，还有注重吃的方法。很多问题不是吃的不够或者过多，而是吃的不合理，引起了葡萄糖峰值。</p><aside>📙### 希望的改变</aside><p>1.尽量按纤维，蛋白质，糖类吃</p><p>2.餐前吃点绿色蔬菜</p><p>3.尽量餐后吃甜点</p><p>4.饭前饭中饭后吃点醋</p><p>5.饭后散步20分钟</p><p>6.学会看营养表</p><aside>📒### 卡片笔记</aside><ul><li><p><strong>前言 聆听来自身体的声音</strong></p><p>  在花费数十亿美元的市场营销活动的影响下，我们对营养的选择受到了影响，而这些市场<br>  营销活动旨在让食品工业赚钱，为苏打水、快餐和糖果做广告。这些食品通常会打着“加工类食品（或糖类）本身并不坏，重要的是你吃了多少”的幌子，让你吃得心安理得。科学证明，事实正好相反：即使我们摄入得并不多，加工类食品（或糖类）在本质上也对人体有害。</p><p>  它们不仅揭开了食物在身体里实时反应的秘密，证明了我们吃的食物很重要，而且还证明了怎么吃也很重要，包括按什么顺序吃、怎样搭配着吃，以及怎样分门别类地吃。</p><p>  科学表明，在人体这个黑匣子里，有一项指标影响着所有的系统。如果理解这项指标并做出对它有益的选择，我们能够在很大程度上改善身心健康状况。这项指标就是血糖水平，即血液中葡萄糖的含量。</p><p>  血液中葡萄糖的浓度在一天中有很大的波动，而浓度的急剧增加（称为葡萄糖峰值）会影响我们的方方面面，包括心情、睡眠、体重、皮肤、免疫系统的健康，患心脏病的风险以及女性受孕的机会。</p></li><li><p><strong>引言 不要把健康视为理所当然</strong></p></li><li><p><strong>第一部分 为什么要控糖</strong></p><ul><li><p><strong>1 进入驾驶舱 葡萄糖为什么如此重要</strong></p>  <aside>  讲述了葡萄糖的重要性，它的稳定会使果糖合胰岛素也变得稳定。  </aside><p>  如将身体看作飞机，我们就是那些一无所知的乘客，所不同的是，我们自身同时也是飞行员。我们被这些复杂的“按钮”弄得手忙脚乱。我们要怎么做，又要从哪里开始呢？从控糖开始。为什么呢？因为葡萄糖是这间驾驶舱里的操纵杆，是飞机顺利航行的关键。同时，它也是最容易掌控的（这要多亏了动态血糖仪）。葡萄糖可以瞬间影响我们的感觉，包括饥饿感和心情。一旦我们控制了它，许多问题就会迎刃而解。</p><p>  随着所学知识的逐渐增多，我越来越深刻地认识到极端饮食对身体没有好处——尤其是很多理论容易被滥用（有一些是非常不健康的纯素饮食，也有一些是非常不健康的酮类饮食）。只要方法得当，任何一种合理的饮食方式都能使曲线平稳。这就是说，我们可以通过饮食来逆转某些疾病或者减轻体重。我们应该寻求一种可持续的生活方式，而不是节食。</p><p>  对于适度这件事情，有三点非常重要，在阅读本书时要铭记于心：</p><p>  第一，葡萄糖不是一切。有些食物能够使血糖曲线变得完全平稳，但是，这些食物对我们的健康并没有好处。决定我们健康的还有其他因素：睡眠、压力、锻炼、情感联系、医疗护理等。除了葡萄糖，我们还要注意脂肪、果糖和胰岛素。但是，不管是果糖水平还是胰岛素水平都很难连续地被监测。血糖水平是唯一我们躺在舒适的沙发上就可以监测的。另外，还有一个好消息，那就是当血糖曲线变得平稳之后，我们的果糖曲线和胰岛素曲线也会随之变得平稳。这是因为果糖和葡萄糖在食物中总是一起出现，而胰腺释放多少胰岛素是根据葡萄糖的。</p><p>  第二，环境非常关键。我们不能简单地说一种食物是好是坏，因为所有的事情都是相对的。我们遇到了一个难题，不能简单地根据一种食物的血糖曲线来判断这种食物是“好”的还是“坏”的。我们必须将这种食物与其替代品进行比较。</p><p>  第三，本书给出的建议都是有科学依据的。</p></li><li><p><strong>2 “食土动物” 植物如何生成葡萄糖</strong></p>  <aside>  讲植物如何生成葡萄糖以及葡萄糖变成的淀粉、果糖、纤维、蔗糖  </aside><p>  我们通常称这一过程为“光合作用”，也就是利用光能，将二氧化碳和水转化为葡萄糖的过程。葡萄糖一旦生成，植物既可以靠分解葡萄糖来产生能量，也可以原封不动地将葡萄<br>  糖作为生长所需的原料。植物也可以通过葡萄糖生产出很多不同的物质。</p><ul><li><p><strong>强力淀粉</strong></p><p>  植物可以通过葡萄糖生产的物质之一就是淀粉。</p><p>  活着的植物每时每刻都需要能量。但是，当没有阳光的时候，不管是阴天还是晚上，光合作用都不能进行，无法为植物提供其生存所需要的葡萄糖。为了解决这个问题，植物需要在白天生产更多的葡萄糖并储存起来，以备不时之需。</p><p>  葡萄糖的自然属性是易溶于周围的任何物质</p><p>  植物也有使葡萄糖再次聚集起来的方法。它们通过一种名为酶的助手（来捕获葡萄糖并将其连接在一起：左手牵右手，右手牵左手，连接成千上万个，最后就会形成一条长长的葡萄糖链，葡萄糖也就不再到处乱跑了。这种形式的葡萄糖被称为淀粉。在植株的茎和叶中淀粉的存储量很小，但是在根茎部的存储量很大。甜菜、土豆、胡萝卜、块根芹、豆薯和山药的可食用部分都是根，都含有淀粉。种子也含有淀粉。淀粉为其发芽、生长提供必要的能量。大米、燕麦、玉米、小麦、大麦、豆类（豌豆、扁豆、大豆和鹰嘴豆）都属于种子，这些种子中也都含有淀粉。</p><p>  只要找到合适的工具，淀粉也是可以被分解的。每当植物需要葡萄糖的时候，它们会使用一种被称为α-淀粉酶的酶。这种酶可以直达根部，将一些葡萄糖分子从淀粉链中释放出来。“咔嚓”一下，葡萄糖就被释放出来了，接着被转化为能量，或是成为构成其他物质的原料。</p></li><li><p><strong>凶猛纤维</strong></p><p>  另一种酶（有很多种不同的酶）能够执行另一项不同的任务——制造纤维。与葡萄糖手拉手制造淀粉的方式不同，这种酶使葡萄糖分子手脚相连，通过这种连接方式形成的链被称为纤维。纤维常见于树干、树枝、花朵和叶子中，植物根部和果实中也有少量纤维。</p></li><li><p><strong>香甜果实</strong></p><p>  植物还会将一部分葡萄糖转化为一种更甜的叫作果糖的分子。果糖的甜度大约是葡萄糖的2.3倍。</p><p>  植物将果糖集中到水果（苹果、樱桃、猕猴桃以及其他水果）之中，并将水果挂在枝头。这么做的目的是让动物无法抗拒水果的味道。那么为什么植物希望它们的果实如此诱人呢？因为植物将其种子藏在了果实之中。这是植物繁殖的关键：动物吃掉它们的果实，种子便神不知鬼不觉地被带走，直到食客将种子排泄出来。这就是种子四处传播的方式，而这种方式让植物遍布各地。</p><p>  大部分植物的果糖都是以这种方式存储的，但是有一些植物，在另一种酶的帮助下，会在一段时间内将葡萄糖以另一种方式进行连接。这种连接方式产生的分子被称为蔗糖。蔗糖的存在可以使植物存储更多的能量（一个蔗糖分子比一个葡萄糖分子和一个果糖分子加起来要稍微小一点，这样，植物就可以在更狭小的空间中存储更多的能量）。</p></li></ul></li><li><p><strong>3 家庭事务 葡萄糖是如何进入血液的</strong></p>  <aside>  讲淀粉、果糖、蔗糖、纤维进入人体的反应，和葡萄糖在人体内怎么生成。  </aside><p>  我们的细胞，就像所有的动物和植物的细胞一样，都需要能量来维持生命——葡萄糖是细胞最佳的能量来源。对我们来说，获取所需葡萄糖的最常规的方式（但不是唯一方式）就是吃。</p><p>  淀粉：</p><p>  我们进食时，也会使用和植物一样的酶——α-淀粉酶，来把淀粉分解成葡萄糖。</p><p>  完成这项重要工作的α-淀粉酶也存在于我们的唾液之中。如果咀嚼淀粉的时间足够长，我们就给了α-淀粉酶工作所需要的时间。这个分解过程发生在口腔，被我们尝了出来。这就是这项实验的神奇之处。</p><p>  水果：</p><p>  和面包不同，水果一开始尝起来就是甜的。这是因为水果已经含有一些没有被连接起来的甜甜的葡萄糖分子。另外，水果中还含有果糖，果糖比葡萄糖更甜。水果中还有蔗糖。</p><p>  水果中的葡萄糖可以被身体直接吸收利用，不需要再次分解。蔗糖确实需要被分解，有一种酶可以将蔗糖分解成葡萄糖和果糖，但是所需的时间极短，只要1纳秒。</p><p>  果糖的情况则要复杂一些。我们吃下果糖后，其中的一部分会在小肠被再次转化成葡萄糖，另一部分则继续以果糖的形式存在。果糖和葡萄糖都能够通过肠壁细胞进入我们的血液。在之后的章节中我会进行讲解，现在我希望大家记住的是，葡萄糖是我们身体所需要的燃料，但果糖不是。</p><p>  纤维：</p><p>  酶的作用是断开淀粉和蔗糖中的连接，但是，没有任何酶可以断开纤维中的连接。也就是说，纤维不能重新变回葡萄糖。</p><p>  纤维会从胃到小肠，再到大肠。这很好。尽管纤维不能转化为葡萄糖，不能为细胞提供能量，但是，纤维是我们饮食中必不可少的物质，在帮助消化、保持健康的肠道运动、维持微生物健康等方面发挥着非常重要的作用。</p><p>  碳水化合物=淀粉+纤维+糖类（葡萄糖、果糖、蔗糖）</p><p>  当人们谈论营养时，总是用“碳水化合物”或者“碳水”来描述淀粉和糖类，而不包括纤维。</p><p>  葡萄糖对我们的身体细胞特别重要，当确实无法从外界摄入葡萄糖时，身体还可以自己生成葡萄糖。体可以通过食物来生成葡萄糖，如通过脂肪或蛋白质产生葡萄糖。</p><p>  当葡萄糖很少时，身体的很多细胞能够在必要时将脂肪作为能量。这就是代谢灵活性。（只能依赖葡萄糖的细胞是红细胞。）</p><p>  事实上，一些饮食方法，如阿特金斯饮食法 和生酮饮食法 就是通过刻意限制碳水化合物的摄入量，让人体内的葡萄糖处于一个极低的水平，来刺激身体通过燃烧脂肪来提供能量。这种方法被称为营养酮症，也是代谢灵活性在实践中的应用。</p></li><li><p><strong>4 寻求快乐 为什么我们比原来吃了更多的葡萄糖</strong></p>  <aside>  讲现在人们葡萄糖摄入过多。  </aside><p>  大自然希望我们能够通过一种特定的渠道来摄入葡萄糖：植物。在植物中，哪里有淀粉或者“糖”，哪里就会有纤维。这是非常重要的，因为纤维能够帮助人体减缓吸收葡萄糖的速度。</p><p>  在食品加工制作的过程中，纤维通常会被去除，因为纤维的存在使长时间保存食物成为<br>  难题。食品在加工过程中，其中的纤维通常会被去除，这样，食物就可以被冷冻、解冻，<br>  即使在货架上存放多年也会保持原有的口感。</p><p>  将一颗新鲜的草莓放在冰箱中冷冻一个晚上，然后在第二天早晨将草莓取出并解冻。如果去吃这个草莓，我们会发现草莓变成了一团糊状物。为什么会这样呢？因为草莓中的纤维在冷冻和解冻的过程中被破坏了，变成了小碎块。纤维仍然存在（并且仍然对健康有益），但是口感却与原来大不一样了。</p><p>  为了使食品成为超市中受欢迎的品类，人们还对食品做了一些其他的处理——增加食品的甜度。食品加工的基础流程是，首先去掉纤维，然后再将淀粉和糖进行浓缩。</p><p>  在某些情况下，更多也不一定就会更好。给一株植物浇太多的水，植物会被淹死；给人提供太多的氧气，人也会因醉氧而晕倒。同样，适量的葡萄糖对我们来说刚刚好：让我们感觉很棒、蹦蹦跳跳、去工作、和他人一起玩、去生活、去感受欢笑和爱。但是，我们也可能摄入过多的葡萄糖，而太多的葡萄糖会伤害到我们。可惜的是，我们在大多时候都意识不到这一点。</p></li><li><p><strong>5 皮肤之下 发现葡萄糖峰值</strong></p><p>  淀粉和糖类在被我们吃下之后会变成葡萄糖。它们会经过胃，进入我们的小肠。在那里，葡萄糖会通过肠道上壁细胞，进入我们的血液。从毛细血管到微小血管，再到更大更粗的血管，葡萄糖就像通过匝道进入了高速公路。</p><p>  在本书中，我将葡萄糖峰值定义为餐后体内的血糖升高在30 mg/dL以上。</p><p>  不管空腹血糖的数值是多少，我们的目标是避免出现峰值，因为由峰值引起的变异才是最大的问题。正是多年来日复一日的葡萄糖峰值使我们的空腹血糖水平慢慢升高，可只有当血糖水平达到了糖尿病前期的标准，我们才会有所察觉，而到那时，身体早已受到了损伤。</p><p>  我建议大家尽量使自己的血糖曲线变得平稳，这就是说，随着时间的推移，我们会看到越来越少并且越来越小的葡萄糖峰值。换个说法，使血糖曲线平稳化的方式就是降低血糖水平的变化幅度。我们的血糖水平变化越小，健康状况就会越好。</p><p>  甜食中含有食用糖，或者叫蔗糖。蔗糖是一种双糖，由葡萄糖和果糖缩合脱水形成。蔗糖分解后会产生葡萄糖和果糖。淀粉类食物则不会产生果糖。所以，每当我们吃了甜食并出现葡萄糖峰值的时候，都会有相应的果糖峰值出现。</p><p>  如果我们吃的是甜食，那么甜食在造成葡萄糖峰值的同时，也会造成看不见的果糖峰值，因此甜食导致的葡萄糖峰值对身体造成的伤害比淀粉类食物导致的葡萄糖峰值更大。</p></li></ul></li><li><p><strong>第二部分 出现葡萄糖峰值有哪些危害</strong></p><ul><li><p><strong>火车、面包和俄罗斯方块 葡萄糖峰值出现时体内发生的三大变化</strong></p>  <aside>  葡萄糖峰值的三大变化：自由基和氧化应激、糖化反应与炎症、胰岛素和脂肪堆积  </aside><p>  葡萄糖一旦进入细胞，它的首要生物学目标就是将自己转化为能量，而负责这项任务的是一种被称为线粒体的微型细胞器。</p><p>  <strong>火车为什么停下：自由基和氧化应激</strong></p><p>  细胞需要多少能量，线粒体便消耗多少葡萄糖。多余的葡萄糖消耗不掉。当我们出现葡萄糖峰值时，向细胞输送葡萄糖的速度就会过快。一下子传送太多，问题就会堆积起来。根据最新的科学理论非稳态负荷模型，当我们的线粒体淹没在不必要的葡萄糖之中时，一种能产生严重后果的小分子就会被释放出来，那就是自由基。</p><p>  自由基是一个大问题，因为它们会破坏接触到的任何东西。它们会随机捕捉并修改我们的遗传基因，引发有害的基因突变，甚至可能引发癌症。自由基使我们的细胞膜产生漏洞，使细胞功能失常。</p><p>  在正常情况下，我们的体内会有一定数量的自由基，并且我们可以处理这些自由基。但是，随着葡萄糖峰值的反复出现，产生的自由基的数量变得很难掌控。当有太多的自由基需要中和时，我们的身体就会处于一种氧化应激状态。</p><p>  氧化应激是导致心脏病、2型糖尿病、认知功能下降和一般性衰老的主要原因。另外，果糖比葡萄糖更容易造成氧化应激。这也是吃甜食（含有果糖）比吃淀粉类食物（不含果糖）对身体造成的伤害更大的原因之一。脂肪太多同样会增加氧化应激的情况。</p><p>  <strong>为什么你像烤面包一样：糖化反应与炎症</strong></p><p>  从出生的那一刻起，我们的身体内部就开始进行褐变，尽管这一过程非常缓慢。</p><p>  美拉德发现：当一个葡萄糖分子与另一种类型的分子碰撞时，就会发生褐变。这会引起一种反应——第二个分子会被“糖化”。当一个分子被糖化后，这个分子就被破坏了。这个过程是生命中正常并且不可避免的一部分，是我们衰老的原因之一，也是我们的器官慢慢退化和我们最终走向死亡的原因之一。我们不能阻止这一过程，但是我们可以减缓或者加速它。</p><p>  我们体内的葡萄糖越多，发生的糖化反应就越多。</p><p>  细胞糖化的长期后果包括出现皱纹、白内障、心脏病和阿尔茨海默病等。</p><p>  果糖分子造成糖化反应的速度是葡萄糖分子的10倍，因此造成的损害也大得多。</p><p>  葡萄糖水平和糖化反应联系得非常紧密，所以有一个非常简单的测量糖化情况的方法就是测量体内的葡萄糖水平。糖化血红蛋白(HbA1c)测试就是测量在过去的2～3个月，有多少红细胞的蛋白被糖化。糖化血红蛋白的水平越高，体内的美拉德反应发生得越频繁，参与循环的葡萄糖越多，衰老速度也就越快。</p><p>  体内过多的自由基、氧化应激和糖化反应的结合会造成全身性炎症。炎症是一种保护措施，是身体在努力对抗入侵者。但是，慢性炎症对身体是有害的，因为它会攻击我们的身体。从表面看，我们看到的是发红和肿胀的现象，但是，在我们体内，组织和器官正在慢慢地受到损害。</p><p>  <strong>在俄罗斯方块游戏中活下去：胰岛素和脂肪堆积</strong></p><p>  胰腺的主要功能之一就是释放一种叫作胰岛素的激素。胰岛素的唯一作用就是将多余的葡萄糖存储在身体的存储单元中，使其脱离身体循环，保护我们不被伤害。如果没有胰岛素，我们就无法生存。</p><p>  胰岛素会将多余的葡萄糖存储在几个不同的存储单元中：</p><p>  第一个存储单元是肝脏。肝脏是非常重要的存储单元，因为血液流经消化系统，经过肠道，携带着新产生的葡萄糖，最终都会流经肝脏。肝脏将葡萄糖转化为一种新的形态，我们称之为糖原。肝脏可以存储大概100 g糖原形态的葡萄糖。</p><p>  第二个存储单元是我们的肌肉。肌肉是非常有效的存储单元，对于一个普通的体重为70 kg的成年人，其肌肉可以存储大约400 g糖原形态的葡萄糖。</p><p>  一旦我们的肝脏和肌肉中存满了葡萄糖，体内多余的葡萄糖就会转化为脂肪，成为我们的脂肪储备，这是让我们体重增加的原因之一。而且脂肪还有更多来源。因为我们的身体不仅要处理葡萄糖，还必须要处理果糖。但是，果糖不能够转化为糖原存储在肝脏或者肌肉中。果糖的唯一存储方式就是转化为脂肪。</p><p>  果糖产生的脂肪会导致我们的身体出现一些不好的情况：首先，脂肪在肝脏中积累，会导致非酒精性脂肪性肝病的发生。其次，在我们臀部、大腿、脸部和内脏之间的脂肪细胞被填满之后，我们就长胖了。最后，脂肪会进入血液，增加患心脏病的风险。</p><p>  这也是如果有两种相同热量的食物，我建议大家选择不含果糖的咸香美味食物，而不选择含有果糖的甜食的另一个原因。没有果糖意味着变成脂肪的分子会更少。</p><p>  很多人对脂肪有着复杂的感情，但脂肪确实非常有用：身体通过脂肪储备为漂浮在血液中多余的葡萄糖和果糖提供存储空间。我们不应该为体脂增加而生气，相反，应该感谢脂肪保护我们免受氧化应激、糖化反应和炎症反应的伤害。我们能够产生的脂肪细胞的数量越多，体积越大（这通常是遗传因素导致的），受到的保护时间就会越长，就能更好地免受葡萄糖和果糖的伤害（但同时体重也会增加）。</p><p>  胰岛素是非常有益的。但是，随着葡萄糖峰值出现次数的增多，我们体内分泌的胰岛素也会越来越多。而胰岛素过多是导致肥胖、2型糖尿病、多囊卵巢综合征等疾病的根本原因。</p><p>  就像杰瑞在晚上需要使用它的淀粉储备一样，当细胞中数以千计的线粒体需要葡萄糖的时候，身体也能够调用储存在我们的肝脏和肌肉中的糖原，将其转化为葡萄糖。接着，伴随糖原储备逐渐减少，身体就会使用脂肪细胞中的脂肪作为能量，这样我们就会处于脂肪燃烧模式，然后体重就下降了。上述情况只有在我们的胰岛素处于低水平时才会发生。如果胰岛素水平过高，身体就会阻止脂肪燃烧：胰岛素使通往脂肪细胞的道路成为一条单行道，可以过去，但是不能回来。只有在葡萄糖峰值出现2小时后，胰岛素水平开始下降，我们才能再次燃烧现有的储备。</p></li><li><p><strong>从头到脚 葡萄糖峰值是如何让我们生病的</strong></p>  <aside>  葡萄糖峰值的危害，引我注意的是疲劳和饥饿感。  </aside><p>  早些时候，一个深刻领悟促使我开始了对葡萄糖的研究：我当下的感觉与自身血糖曲线的峰值和谷值密切相关。</p><p>  我观察了自己的血糖水平变化：自早餐吃了一片咸巧克力曲奇饼干、喝了一杯加了脱脂牛奶的卡布奇诺咖啡之后，血糖水平先是经过一个高高的峰值，然后开始急剧下降。我感到很累的原因是，我的身体刚刚坐了一辆葡萄糖过山车。</p><p>  短期影响：</p><ol><li>持续的饥饿感<ol><li>第一，我们很多人都会在刚吃过饭后就感到饥饿，这同样与葡萄糖有关。将含有相同的热量，但种类不同的两餐进行比较，我们会发现，如果该餐引起的葡萄糖峰值比较小，那么这一餐会让我们有更长时间的饱腹感。所以，热量并非全部的问题所在。</li><li>第二，持续饥饿感是胰岛素水平较高的一种表现。如果葡萄糖峰值频繁出现，我们体内就会产生大量的胰岛素混合在其他激素之中。瘦素，是一种告诉我们“我们饱了，应该不用吃饭了”的激素。胰岛素水平过高会导致瘦素的信号被阻断。而胃促生长素，这种告诉我们“我们还很饿”的激素就会取而代之。尽管有脂肪储备，有大量可用的能量，身体依然会告诉我们还需要更多。所以，我们就会想要再吃东西。</li></ol></li><li><p>食欲旺盛</p><p> 他们发现，当受试者的血糖水平稳定时，他们的食欲并不旺盛。但<br> 是，当他们的葡萄糖水平开始下降时，会出现两种情况：<br> · 看到高热量的食物图片时，受试者大脑中控制食欲的中心会亮起来。<br> · 受试者想吃这些食物的程度明显高于其血糖水平稳定的时候。</p></li><li><p>慢性疲劳</p><p> 在健身车上所做的实验表明，患有先天性线粒体缺陷的人的锻炼时间通常只能达到<br> 正常人的一半。在我们的线粒体受到损伤后，哪怕只是抱起我们的孩子也会变得极具挑战性，搬运一些杂货会让我们精疲力竭，更别提像原来那样处理压力性事件（如裁员和分手）。那些让我们感到困难的事情，无论是身体上的还是精神上的，都需要线粒体产生能量来解决。</p><p> 每一次的葡萄糖峰值都会让我们的线粒体的长期功能受到损害。相对于那些产生平稳化血糖曲线的饮食方式，那些能够造成葡萄糖过山车的饮食方式会让我们感觉更加疲惫。</p></li><li><p>糟糕的睡眠</p><p> 血糖失调的一个常见症状是半夜突然惊醒，心脏怦怦直跳。通常情况下，这是血糖水平在半夜急剧下降导致的结果。</p></li><li><p>感冒和冠状病毒并发症</p><p> 在经历一次葡萄糖峰值之后，我们的免疫系统会出现短暂故障。如果此时血糖水平仍在缓慢升高，那么我们基本不具备对病毒等入侵者的免疫能力了——我们会更容易<br> 遭到病毒感染。</p></li><li><p>更棘手的妊娠糖尿病</p><p> 女性在怀孕期间胰岛素水平都会升高。这是因为胰岛素不仅可以促进胎儿生长，还<br> 可以促进女性乳房组织的生长，为其将来的哺乳做好准备。但是，这些额外分泌的胰岛素有时会导致胰岛素抵抗综合征，即身体不再对胰岛素做出反应。胰岛素水平升高后却不能帮助自身将过量的葡萄糖储存在三个存储单元之中，导致我们体内的血糖水平升高，这就是常说的妊娠糖尿病。</p></li><li><p>潮热和盗汗</p></li><li>偏头痛</li><li>记忆和认知功能问题</li><li><p>更难管理的1型糖尿病</p><p>长期危害：</p></li><li><p>痤疮和其他皮肤问题</p><p> 淀粉和含糖食物会引起连锁反应，表现为身上和脸上长粉刺，以及皮肤泛红。这是因为许多皮肤问题（包括湿疹和牛皮癣）都是由炎症引起的，而正如我们刚刚学到的，炎症是由葡萄糖峰值引发的。</p></li><li><p>衰老与关节炎</p></li><li>阿尔茨海默病与痴呆</li><li>患癌症的风险加大</li><li>精神障碍</li><li>肠道问题</li><li>心脏病</li><li>不孕症和多囊卵巢综合征</li><li>胰岛素抵抗综合征与2型糖尿病</li><li>非酒精性脂肪性肝病</li><li>皱纹和白内障</li></ol></li></ul></li><li><p><strong>第三部分 轻松控糖的10个小窍门</strong></p><ul><li><p><strong>窍门1 正确的饮食顺序</strong></p><p>  <strong>方法：</strong></p><p>  那么，正确的饮食顺序是什么呢？那就是，先吃纤维，然后吃蛋白质和脂肪，最后<br>  吃淀粉和糖类。</p><p>  <strong>原因：</strong></p><p>  在小肠中，食物被分解成葡萄糖分子，然后迅速进入血液。这会造成血糖水平快速升高。我们吃的碳水化合物越多，吃得越快，就会出现越大的葡萄糖负载，从而导致越高的葡萄糖峰值。</p><p>  纤维不会被我们的消化系统分解为葡萄糖。纤维从胃进入小肠，再到被排出，过程十分缓慢，而且形态不变。但是，纤维的好处还不仅仅是这些，它还拥有三种超能力：</p><p>  纤维会减弱α-淀粉酶的作用，这种酶能够将淀粉分解成葡萄糖分子。<br>  ·纤维能够减缓胃的排空速度：当有纤维存在时，食物从胃进入小肠的速度会更<br>  慢。<br>  ·纤维会在小肠内创造一个黏性的网状结构，而这种网状结构会使葡萄糖进入血液<br>  的速度变慢。</p><p>  通过这种机制，纤维可以减缓任何在其之后进入消化系统的食物被分解和吸收的速<br>  度，使我们的血糖曲线平稳化。</p><p>  现在我们来讨论一下蛋白质和脂肪。蛋白质广泛存在于肉类、鱼类、蛋类、奶制品、坚果和豆类中。含有蛋白质的食物通常也含有脂肪，同时，脂肪也可作为主要成分存在于黄油、油和牛油果中。</p><p>  含有脂肪的食物也会减缓胃的排空速度，所以在吃淀粉类食物之前食用这些食物也有助于使我们的血糖曲线平稳化。</p><p>  <strong>Q1 在贝尔纳黛特改变她的饮食顺序之前，下午会饿且累</strong></p><p>  如果我们吃食物的顺序不对（先吃淀粉和糖类），胃促生长素，也就是我们的促食欲激素会在餐后2小时就恢复到餐前水平。如果我们按照正确的饮食顺序（最后吃淀粉和糖类），胃促<br>  生长素被抑制的时间会更长一些。</p><p>  <strong>Q2 水果应该单独吃，否则会烂在我们的胃里？</strong></p><p>  我将水果归为糖类，尽管水果中含有纤维，但其主要成分是葡萄糖、果糖和蔗糖，也就是糖，因此应该最后吃水果。</p><p>  这种错误的观点认为因为水果会“浮在胃里的食物上面，并最终腐烂，而其产生的有毒气体会进入我们的大脑并扰乱整个身体系统”。</p><p>  当细菌停留在食物上，并且开始消化食物促进其自身生长时，就会发生腐烂现象。</p><p>  首先，腐烂需要几天或者几周的时间。腐烂不可能在几小时内发生，而消化水果只需要几小时。其次，我们的胃处于酸性环境（pH为1～2），而任何pH低于4的酸性环境都能够抑制细菌生长，所以也能够抑制腐烂发生。没有什么东西能够在胃里腐烂，事实上，胃和食道是我们整个消化系统中细菌最少的地方。</p><p>  <strong>Q3 需要间隔多久再吃另一种食物？</strong></p><p>  只要我们最后吃淀粉和糖类食物，哪怕其间没有时间间隔，都会使我们的血糖曲线更平稳。</p><p>  <strong>Q4 如果一餐中没有淀粉或糖类怎么办？</strong></p><p>  如果一餐中没有淀粉或糖类，餐后的葡萄糖峰值自然会十分平稳。</p><p>  <strong>Q5 我必须一直这样做吗？</strong></p><p>  最重要的是，尽可能地做到最后吃淀粉和糖类。并且，要记得庆祝这些小小的改变。比方说，先吃蔬菜，然后将淀粉、蛋白质和脂肪混合着吃，这仍然比最后吃蔬菜要好，也是进步。</p></li><li><p><strong>窍门2 在每餐前增加一道绿色开胃菜</strong></p><p>  这其实是另一回事——在你开始吃饭前增加一道菜。这样一来，你会比原来吃得更多，<br>  可在此过程中，你的血糖曲线会变得平稳。我们现在要做的是让食物回到它最初的样子，即加工之前：哪里有淀粉和糖类，哪里就有纤维。通过增加一道美味的绿色开胃菜，纤维就回来了。</p><p>  纤维对我们的身体起着至关重要的作用：为肠道中的有益菌提供能量，丰富肠道菌<br>  群，降低胆固醇水平，确保一切生理活动顺利进行。</p><p>  一定不要购买那些声称是“全谷物”的面包，实际上它的纤维含量并不比传统的白面包更多。我们可以购买那些以黑麦为原料的黑色且紧实的面包，这些面包是由酵母发酵做成的。</p><p>  那么，获取纤维的最佳方式究竟是什么呢？答案是绿色蔬菜。</p><p>  <strong>方法：</strong></p><p>  这道绿色开胃菜应该做多少呢？你喜欢多少就做多少。我发现，开胃菜和随后吃的淀粉类食物的最佳比例是1∶1。</p><p>  <strong>Q1 吃完开胃菜之后多久可以吃主菜？</strong><br>  不需要等，按顺序吃就可以。如果确实要等，间隔时间不要超过3小时。这是因为<br>  纤维通过胃部和小肠上端通常需要2小时。</p><p>  <strong>Q2 我应该吃多少蔬菜？</strong><br>  首先，吃蔬菜比不吃蔬菜要好；其次，蔬菜吃得越多，对身体越好。目前还没有关<br>  于蔬菜的最佳摄入量的科学定论。</p><p>  <strong>Q3 合格的绿色开胃菜是什么样的？</strong></p><p>  任何蔬菜都可以。另外，这些蔬菜既可以生吃也可以煮熟之后吃。但是，请不要榨成汁或者捣成泥，这样会导致纤维流失（榨成果汁），或者使纤维被捣得过碎（捣成泥）。</p><p>  汤是一道很好的菜，汤里含有丰富的营养物质，很容易产生饱腹感，这是我们在饭店里最健康的头盘菜之一。但是，这并没有一整盘蔬菜健康。</p><p>  <strong>Q4 最方便的开胃菜是什么？</strong><br>  在超市买一袋菠菜，将3杯菠菜、2汤匙橄榄油、一汤匙醋（喜欢多少加多少）、一些盐和胡椒粉，放在大碗里拌匀，最上面撒一把菲达奶酪碎和一些烤熟的坚果。</p><p>  每个周日，我都会做好一些调料，将它们放进冰箱，可以用一周。下面是一些更简<br>  单易做的开胃菜：<br>  · 几片剩下的烤蔬菜（通常，我会提前烤好一些西蓝花或者花椰菜，放在冰箱里备<br>  用）。<br>  · 少量泡菜。<br>  · 牛油果酱配黄瓜片。<br>  · 1个番茄切片搭配2片马苏里拉奶酪。<br>  · 少量胡萝卜配鹰嘴豆泥。<br>  · 4份腌制的罐装菜蓟或者其他别的罐装蔬菜。<br>  · 2罐棕榈菜心。<br>  · 2根罐装白芦笋。</p><p>  <strong>Q5 需要服用补充剂吗？</strong><br>  最好的方式是吃完整的食物而非服用补充剂，但是，如果在某些场合服用补充剂确<br>  实比较方便，那么餐前来一份纤维补充剂也会对自己有所帮助。</p><p>  <strong>Q7 在碳水化合物中添加脂肪（如沙拉调料）会导致体重增加吗？</strong><br>  不会。添加脂肪导致体重增加这个错误的观点已经被纠正了。</p></li><li><p><strong>窍门3 停止计算热量</strong></p><p>  计算一个甜甜圈的热量，要按照以下步骤：先将甜甜圈脱水，然后将其放到一个浸泡在水中的容器中，接着将甜甜圈点燃（事实确实如此）并测量其周围的水升高的温度，最后用水升高的温度乘以杯中水的质量，得到的就是水增加的能量（1 g水升高1℃需要1 cal）。这样我们就能计算出这个甜甜圈的能量了。</p><p>  不同物质在产生相同热量的情况下，会产生不同的影响。100 cal的果糖比100 cal的葡萄糖更糟糕。</p><ul><li><p>如果你之前听说过想要保持健康，就必须减少热量的摄入量，那么现在你知道了，这种说法并不正确。我们可以在保持摄入热量不变的同时，通过改变所食用的食物种类来治愈某些疾病。</p><p>  因为不同物质在产生相同热量的情况下，会产生不同的影响。100 cal的果糖比100 cal的葡萄糖更糟糕。</p></li></ul></li></ul></li></ul><pre><code>    与摄入的热量较少但是葡萄糖峰值飙升的人相比，那些摄入的热量较多但是血糖曲线平    稳的人可以减掉更多的体重。    2021年一份针对60项减肥研究的分析报告显示，让胰岛素水平降低才是减肥的关键，只有胰岛素水平先降下来，体重才可能减轻。    事实上，只要专注于使血糖曲线平稳，即使完全不考虑热量，也可以减肥。但是要记住，这需要我们有一些基本的、良好的判断力，如果一天吃了10000 cal的黄油，我们的血糖曲线仍然会是平稳的，但是同时我们的体重也会增加。    **Q1 不同食物产生的热量对我们来说意味着什么？**    如果一顿饭产生的热量能够抑制血糖水平飙升，那么我们可以毫无顾忌地在这顿饭中获取更多热量，如富含纤维、脂肪或者蛋白质的食物。    事实上，热量是有区别的，但这是食品加工行业在拼命混淆的一个事实。真相隐藏在热量本身的背后。这些数字转移了我们的注意力，让我们忽视了盒子里到底有什么。比如，果糖与葡萄糖不同，它不能为我们的肌肉提供能量，几乎全部都会转化为脂肪。- **窍门4 平稳早餐后的血糖曲线**    科学实验已经证明，含有碳水化合物更多的餐食在消化后，会导致身体循环中可用的能量更少。早餐吃的碳水化合物越多，可用的能量越少。    一顿早餐会让血糖水平飙升，很快我们就会再次感到饥饿。更重要的是，早餐会使一天中的血糖水平很难都得到控制，所以午餐和晚餐也会带来很高的葡萄糖峰值。一方面，一顿使血糖水平飙升的早餐是一张葡萄糖过山车的单程车票。另一方面，一顿可以使血糖曲线平稳的早餐，也可以使午餐和晚餐后的血糖水平更加稳定。    早晨醒来处于空腹状态时，身体对葡萄糖最为敏感。我们的胃是空的，所以进入胃的任何食物都会很快被消化。这就是为什么早餐吃糖类和淀粉往往会导致一天中最大的葡萄糖峰值。    早餐最不适合吃糖类和淀粉类食物，但是，大多数人早餐只吃糖类和淀粉类食物。最好餐后再吃甜点。    如果把水果打碎、压榨、干燥并浓缩其中的糖分，去除水果中的纤维，就会给身体    带来快速且有害的冲击——导致葡萄糖峰值的产生。    水果加工的程序越多，对身体就越不利。对我们来说，一个苹果要比苹果酱好，而苹果酱要比苹果汁对身体更有益。请注意，一旦水果被榨成果汁、做成水果干、糖渍果脯、水果罐头或者果酱，我们就应该把水果当作甜点，把其制品当成一块蛋糕。    一份能够使血糖曲线平稳的理想早餐要包含大量的蛋白质、纤维、脂肪，而淀粉类食物和水果则可加可不加（最好最后吃）。    确保自己的早餐含有蛋白质。当然，这并不是说我们每天早晨要狼吞虎咽，一口气吃掉10个生鸡蛋。蛋白质可以是希腊酸奶、豆腐、肉、鱼、奶酪、奶油、蛋白粉、坚果、坚果酱、其他种子类食物，以及熟鸡蛋（可以是炒鸡蛋、煎鸡蛋、水煮蛋，或者溏心蛋）。    添加脂肪。用黄油或者橄榄油炒鸡蛋，再加几片牛油果，或者在希腊酸奶中加5颗杏仁、一些奇亚籽或者亚麻籽，都可以增加脂肪摄入量。顺便说一下，不要喝脱脂酸奶。脱脂酸奶不会让我们产生饱腹感，普通酸奶或者希腊酸奶都是不错的选择。    添加额外的纤维。早餐吃纤维是非常具有挑战性的，因为这意味着早餐我们要吃蔬    菜。如果你不喜欢早餐吃蔬菜也无须勉强。    选择性地添加一些淀粉或者完整的水果（也可以不加）。燕麦、吐司、米饭、土豆，以及任何完整的水果（最好选择浆果类水果）都可以。    早上不吃甜味早餐不行？那么，试试下列既能够吃上甜味早餐又能够降低葡萄糖峰值的方法。    燕麦。如果你喜欢吃燕麦（淀粉类食物），那么请和坚果酱、蛋白粉、酸奶、浆果    等一起吃。避免添加红糖、枫糖浆、蜂蜜、热带水果或者水果干。你还可以换成奇亚籽    布丁，将奇亚籽在无糖的椰奶中浸泡一晚上，再加上一勺椰子油。    奶昔。只需要在奶昔里加入一些蛋白质、脂肪和纤维，你就可以在早餐时享用。你可以先在奶昔里加入一些蛋白粉，再加入一些亚麻籽或亚麻仁、椰子油、牛油果、坚果和一杯菠菜等。制作奶昔的最简单的经验就是，放到榨汁机中的水果总量不要超过你一口气能吃下    的整个水果的总量。    水果。要想使葡萄糖水平稳定，最好的选择就是浆果、柑橘类水果，或是又小又酸的苹果，因为这些水果的纤维含量高，含糖量少。不建议选择杧果、菠萝和其他热带水因为这些水果的含糖量最高。另外，一定要在吃水果之前先吃点儿别的东西。    燕麦牛奶往往会导致更高的葡萄糖峰值的出现，因为燕麦牛奶主要由谷物而非坚果制成，所以比其他奶制品含有更多的碳水化合物。    **Q1 如果我不习惯吃早餐怎么办？**    不吃早餐没问题。不管你的第一餐在什么时间吃，道理都是一样的，咸香美味的饭菜是美好生活的第一步。    **Q2 早餐是不是也应该按照正确的饮食顺序来吃？**    理想情况是这样的，但是如果做不到也不要有太大压力。    **Q3 吃鸡蛋对心脏不好吗？**    科学家曾经认为，食用含有胆固醇的食物（如鸡蛋）会增加我们患心脏病的风险。    现在，我们知道这种说法并不准确，因为糖才是真正的坏家伙。研究表明，2型糖尿病患者若将早餐中的燕麦片用鸡蛋代替（并保持其摄入的能量不变），他们的炎症会减少，患心脏病的风险会降低。- **窍门5 吃自己喜欢的糖，因为所有糖都一样**    **Q1 蜂蜜比糖更健康？**    蜂蜜来源于植物的花蜜，但是蜂蜜含有葡萄糖和果糖，就和食用糖一样。红糖（听起来很健康）和白糖的成分几乎完全一样，唯一的区别就是在制作过程中红糖会被糖浆着色，这让它看起来更健康。    现在，你明白了：任何种类的糖，不管它是什么颜色、什么味道、源自何种植物，它在体内分解后仍然是葡萄糖和果糖，都会导致我们身体中出现葡萄糖和果糖峰值。    **Q2 天然糖更好？**    糖没有好坏之分，不管糖来自哪种植物。糖在体内分解成的分子才是关键.    **Q3 龙舌兰糖浆比白糖更健康吗？**    龙舌兰糖浆经常会被推荐给糖尿病患者和妊娠糖尿病患者，因为相对于食用糖，龙舌兰糖浆的血糖生成指数并不高。这是真的，它确实让我们的身体有较低的血糖水平。但是，这是因为相对于食用糖来说，龙舌兰糖浆含有的果糖较多而葡萄糖较少。龙舌兰糖浆中的果糖含量大约为80%，而食用糖中的果糖含量大约为50%。所以，尽管龙舌兰糖浆能够使葡萄糖峰值稍微小一点，但是其引起的果糖峰值会更高。    因此，尽管龙舌兰糖浆比食用糖含有更多的果糖，但是它确实会比食用糖对我们的健康造成更不利的影响。    **Q4 蜂蜜中含有的抗氧化剂多吗？**    这个问题与“果汁中的维生素含量高吗？”在本质上是同类问题。答案是一样的。为了获得其中的抗氧化剂而吃蜂蜜是不理智的，就像为了获取维生素而喝果汁一样不明智。是的，蜂蜜中有抗氧化剂，果汁中也有维生素，但是这些都弥补不了其含有的大量葡萄糖和果糖对身体造成的不良影响。并且有一个有趣的事实：蜂蜜中并没有那么多的抗氧化剂。我们在半颗蓝莓中就可以找到一茶匙蜂蜜中含有的抗氧化剂的量。这是真的，半颗蓝莓就可以！    选择自己喜欢的糖。不管糖来自哪里，既然所有的糖都是为了获得快乐才吃的，那么选择一种你最喜欢的吧，并愉悦地享用它。    尽量选择水果作为甜品。当我们想吃甜的东西时，最好的选择就是完整的水果。记住，大自然希望我们用这种方式来获取葡萄糖和果糖：少量地、多次地，并且和纤维一起。    人造甜味剂。我们知道很多糖是“天然”糖，那么那些人造甜味剂呢？有些人造甜味剂会使我们的胰岛素水平出现峰值，这意味着它们会促使我们的身体脂肪，从而导致体重增加。    人工甜味剂不仅热量低，还能满足我们对甜味食物的渴望，因此我们会认为多吃一块饼干并无大碍。事实上，人工甜味剂还可能改变肠道菌群的组成，而这会对我们的身体造成负面影响。    对葡萄糖水平和胰岛素水平没有副作用的最佳甜味剂包括：阿洛酮糖、罗汉果、甜叶菊、赤藓糖醇    有一些人工甜味剂建议大家要避免食用，因为这些甜味剂会使胰岛素水平和（或）血糖水平升高，尤其是当它们与食物结合时，还会引起其他健康问题。这些甜味剂包括：阿斯巴甜、麦芽糖醇（消化后转化为葡萄糖）、三氯蔗糖、木糖醇、安赛蜜    **Q5 无糖汽水中的甜味剂怎么样？**    我们要明确一点：在不考虑其他情况时，喝含有人工甜味剂的无糖汽水比普通的汽水要好。但是，无糖汽水和水不同。无糖汽水含有人工甜味剂，这会导致一些我上面讲过的有害的后果。- **窍门6 选择餐后甜点而不是甜甜的零食**    餐后是我们一天之中激素和炎症变化最大的时期。为了消化、分类和存储我们刚刚吃下的食物中的分子，血液会涌入消化系统，我们体内的激素水平会像潮水一样上涨，有些系统（包括免疫系统）会被暂停运作，而另一些系统的功能（如脂肪存储）则会被激活。胰岛素水平会升高，氧化应激和炎症会增加。餐后的葡萄糖或者果糖峰值越高，我们的身体就越难应对餐后状态，因为它不得不管理更多的自由基、糖化反应和分泌的胰岛素。    在非餐后状态时，身体的负担没那么重。我们的器官会执行清理任务，新的细胞会代替受损的细胞，身体会被清理干净。例如，在我们几小时没有吃东西后，小肠会发出咕噜咕噜的声音，这就是我们清空的消化系统在清理它的内壁。在非餐后状态时，胰岛素水平会下降，如此我们就能够重新燃烧脂肪，而不是囤积脂肪。    你可能听说过，史前时期，人们即使长时间不吃东西也不会危及生命。这是因为我们能够轻松地将我们吃的最后一顿饭产生的葡萄糖或者身体储备的脂肪转化为燃料。我们之前讲过，这种转化能力被称为新陈代谢灵活性。这是判断新陈代谢是否健康的一个重要标准。    为了提升自身新陈代谢灵活性，我们要一顿饭多吃一点儿，吃得更饱一点儿，这样，我们就不需要每隔1～2小时就吃零食。这与现在流行的“少食多餐”的观点相悖，但却是经过研究证明了的。    2014年，捷克的科学家在2型糖尿病患者中做了测试。他们确定好每日的热量限额，并让其中一组参与者在两顿大餐中摄入这些热量，而另一组参与者将这些热量分成六顿小餐。吃两顿的参与者不仅体重比另一组减轻得更多（3个月内，吃两顿的人减掉了约3.6千克，吃六顿的减掉了约2.3千克），并且，他们同健康相关的关键指标也都有所改善：他们的空腹血糖更低了，脂肪肝减轻了，胰岛素抵抗减弱了，同时胰腺细胞也变得更加健康了。身体摄入相同的热量，效果却不尽相同。我又要提到自己最热衷的话题了：热量并不意味着一切。    **方法：**    如果你想吃一些甜食，那么最好将其作为餐后甜点，而不是在一天中空腹时吃零食。    **原因：**    不吃零食，可以使自己的身体系统保持更长时间的非餐后状态。这就意味着我们的身体有时间进行上述的清理工作。如果餐后再吃甜点，会减缓由甜点造成的葡萄糖峰值的出现速度。这是因为先吃纤维和蛋白质类食物，再吃糖类和淀粉类食物（不要放在最先吃，也不要当成零食来吃），意味着糖和淀粉从胃到小肠的速度可以更慢（参见窍门1）。    **Q1 我应该一天尽量只吃一餐或者两餐吗？**    没有必要对自己要求那么高。有些人发现自己非常适合这种间隔性的禁食，但它并不适合所有人。研究表明，禁食对男性的好处更为明显，但是对处于育龄阶段的女性来说，禁食时间太久或者禁食太频繁可能会导致激素紊乱以及其他生理压力。试试一日三餐，看看感觉怎么样。    **Q2 想吃夜宵怎么办？**    如果你习惯在晚餐后几小时吃甜甜的零食，更好的办法是将甜甜的零食作为餐后甜点。如果夜宵无法避免，那么继续往后阅读，看看有没有其他的窍门可以帮到你。    **Q3 怎样才能知道自己的新陈代谢是否足够灵活？**    如果你能够在两餐之间轻松地走步5小时，而不会感到头晕眼花、浑身发抖或者出现“饿怒症”，你的新陈代谢应该是极具灵活性的。    吃甜食的最佳时间是在你刚吃完一顿含有脂肪、蛋白质和纤维的餐食之后。- **窍门7 吃饭之前喝点儿醋**    **方法：**    在一大杯水中加入一汤匙醋混合而成的醋汁，在吃甜食前的几分钟先喝它，就会使随后出现的葡萄糖和果糖曲线变得平稳。通过这种方式，食欲会被抑制，同时还会燃烧更多的脂肪。    醋的常见品种包括米醋、白酒醋、红酒醋、雪利酒醋、香醋和苹果醋。所有的醋对葡萄糖的作用都是一样的，所以选择一个你喜欢的味道即可。    喝醋的好处有很多。对于非糖尿病患者、胰岛素抵抗人群和1型或者2型糖尿病患者，只要每天喝一汤匙醋就可以显著降低他们的葡萄糖水平。对于患有多囊卵巢综合征的女性，喝醋的效果也很明显。    下面是所有参与者的身体都发生的变化：若他们在吃富含碳水化合物的大餐前喝一杯醋汁，那顿饭所导致的葡萄糖峰值降低了8%～30%。同时，我们还发现了一个重要的线索：在餐前喝醋后，产生的胰岛素也会减少。    **醋的工作原理：**    植物和人类拥有一种相同的酶——α-淀粉酶。这种酶会将植物中的淀粉和人类吃进嘴里的面包转化为葡萄糖。科学家已经证实，食醋中的醋酸会暂时抑制α-淀粉酶的活性。因此，糖和淀粉转化为葡萄糖的速度就会变得更慢，葡萄糖对我们系统所造成的冲击也更缓和。    一旦醋酸进入血液，它会渗透到我们的肌肉中。在那里，它会刺激我们的肌肉比原来更快地制造糖原，这会使葡萄糖以更高的效率被吸收。    这两个因素，即葡萄糖在体内释放的速度更慢，同时我们的肌肉吸收葡萄糖的速度更快，就会使体内自由流动的葡萄糖更少，因此出现的葡萄糖峰值也更小。    更重要的是，醋酸不仅可以减少胰岛素的分泌量（这有助于我们回到脂肪燃烧模式），还可以诱发某些特定的DNA重新编码，使我们的线粒体燃烧更多的脂肪。    先倒一大杯水（有些人发现热水更好），然后放1汤匙醋进去。如果你不喜欢这种味道，可以在刚开始放1茶匙醋或者再少点，然后逐渐加量。然后拿一根吸管，在吃饭前20分钟，或者吃饭过程中，或者餐后20分钟内喝完这杯醋汁。    还有一个更为简单的方法可以实践这个窍门：在你的餐前开胃菜中加点儿醋。    需要说明的是，不能因为开始吃醋就继续不良的饮食习惯。醋能够调节葡萄糖峰值，但是并不能消除峰值。在吃饭时加点儿醋确实会对你有所帮助，但这并不是你吃更多糖的理由，因为总体来说，吃更多的糖会让你的身体状况比原来更糟糕。    **Q1 为什么要用吸管喝醋？**    尽管稀释后醋的酸性不足以损坏牙齿的牙釉质，但为了安全，我还是建议大家用吸管来喝。千万不要拿起瓶子大口喝。但如果是作为其他食物的一部分，如油醋汁调料，那就拌好直接吃吧。    **Q2 喝完醋汁之后多久可以吃饭？**    饭前20分钟之内或者饭后20分钟喝醋汁，也可以边吃饭边喝，效果接近。    **Q3 喝醋有什么副作用吗？**    只要你坚持喝食用醋，也就是酸度为5%的醋（清洁用的醋酸度为6%，经常出现在超市中的拖布或者卫生纸旁边，请不要喝！），就不会有副作用。对有些人来说，醋会刺激他们的黏膜，也可能会引起胃灼热。所以，不建议患胃病的人使用该窍门。    **Q4 喝多少醋有限制吗？**    有限制。一位29岁的女性坚持6年每天喝16汤匙的醋，之后她因为体内钾盐、钠盐和碳酸氢盐含量过低而住进了医院。所以，不要像她这么做。她喝太多醋了。但是，若用一大杯水稀释一汤匙醋汁，那么大部分人还是可以每天喝几次的。    **Q5 孕期或者哺乳期可以喝醋吗？**    大多数食用醋都会经过巴氏消毒，可以安全食用。不过，苹果醋通常不会进行巴氏消毒，可能会给孕妇带来风险。所以，在食用之前，请先和医生确认。    **Q6 已经吃了一块蛋糕，喝醋还来得及吗？**    来得及，我经常这样做。蛋糕实在是太好吃了，有时就会忘记在吃蛋糕前喝点儿醋。在吃了甜食或者淀粉类食物之后再喝醋（再次说明，要在饭后20分钟内喝醋）也要比不喝醋好得多。饭后喝醋同样有降低血糖的效果。    **Q7 康普茶代替醋可以吗？**    康普茶的醋酸含量不到1%，并且如果不是自制的康普茶，里面通常都会加糖。尽管康普茶并不能作为葡萄糖峰值秒杀神器，但它对健康还是有些好处的，因为它是发酵食品，其中含有的有益菌能为我们肠道中的有益微生物菌群提供能量。- **窍门8 饭后动起来**    通过身体的肌肉收缩，我们能够做出行走、倾斜、抓握、抬举等动作。有些肌肉（如手指肌肉）我们能够有意识地控制，有些肌肉（如心肌）则不能。不管是有意识的还是无意识的，肌肉收缩的次数越多、力度越大，需要的能量就越多，消耗的葡萄糖也就越多。    饭后去健身效果会更好，尽管有些人饱腹后做高强度的运动非常困难。好消息是，在饭后70分钟内的任一时间进行锻炼，都能够有效抑制葡萄糖峰值的出现。葡萄糖水平到达峰值所需时间大概是70分钟，所以在这个时间内运动最好。你还可以通过俯卧撑、深蹲、平板支撑或者举重等运动来锻炼肌肉。实验已经证明，抗阻运动（举重等）能够使葡萄糖峰值降低30%，并且能够使接下来24小时内的葡萄糖峰值下降35%。    这里还有一个关键点：餐后运动会让血糖曲线变得平稳，但胰岛素水平却不会增高，就像喝醋一样。通常，肌肉需要胰岛素来存储葡萄糖，但在收缩状态时，它无须胰岛素就能够吸收葡萄糖。    肌肉收缩的频率越高，身体就越能在不需要胰岛素的情况下消耗更多葡萄糖，葡萄糖峰值也会越低，因此胰腺分泌的用于处理剩余葡萄糖的胰岛素就会越少。这可是个好消息。只需要10分钟的餐后散步，就能够避免我们刚吃过的食物可能产生的副作用。并且，锻炼的时间越长，血糖和胰岛素曲线就会越平稳。    **Q1 我应该在饭后多久开始运动？**    你可以选择餐后70分钟内的任一时间段运动，来看看效果如何。    **Q2 我应该在餐前运动还是餐后运动？**    餐后运动似乎是最好的选择，但是餐前运动也是非常有用的。    **Q3 单次运动多长时间最佳？**    这取决于哪种运动对你最有效。常设的研究项目包括10～20分钟的散步、10分钟的强度训练，以及10分钟的抗阻训练。而我做30个深蹲之后的血糖水平变化比较明显。    **Q4 为什么空腹运动会导致葡萄糖峰值的出现？**    如果在还没有吃饭的时候，即空腹的时候运动，你的肝脏会向血液中释放葡萄糖，为肌肉中的线粒体提供能量。于是血糖曲线上会出现一个峰值，因为确实会有一个峰值。这些峰值也确实会导致自由基增加而引起氧化应激，但是运动同时也提升了你清除自由基的能力。并且，重要的是，这种对自由基的清除能力要比运动生成自由基的能力更加强。    是以，运动实际上会减少氧化应激。运动被认为会对身体造成一种兴奋性压力。这是一种有益的压力，因为这种压力会使我们的身体变得更加灵活。- **窍门9 如果一定要吃零食，就吃咸香美味的零食**    食物会影响我们的感觉，这已经是个公认的事实。科学告诉我们，当食用热量相当的食物时，和食用能维持血糖曲线平稳的食物的人比起来，那些食用了会导致很高的葡萄糖峰值的人的情绪会随着时间的推移变得更差，他们也会出现更多的抑郁症状。    每个人都有过想吃甜食的冲动，尤其是在感到困倦的时候。然而，吃甜食能让我们精力充沛的想法是错误的。相比于一份咸香美味的零食，一份甜甜的零食并没有为我们提供更多能量。    尽管这违背以往认知，但我还是要强调，如果你想补充能量，那么请跳过甜食，不要选择糖果或者能量棒，而要选择一些咸香美味的小吃。并且，也不要选择淀粉类的食物，因为淀粉也会转化为葡萄糖。- **窍门10 为你摄入的碳水化合物“穿上外衣”**    我在前文已经讲过，将淀粉和糖类与脂肪、蛋白质或者纤维结合起来。所以，为了不让碳水化合物“裸奔”（只吃碳水化合物），给它们“穿上外衣”。“穿在碳水化合物身上的外衣”会降低葡萄糖在体内的吸收量和吸收速度。    在主食中加入脂肪会使胰岛素峰值升高——这个观点是由法国的米歇尔·蒙蒂尼亚克在20世纪80年代提出并被推广开来的。但最新的科学证明事实并非如此。在膳食中添加脂肪并不会导致更高的胰岛素峰值的出现。事实上，在吃富含碳水化合物的食物前先吃点儿脂肪类食物，还会减少胰岛素的分泌量，对我们的血糖水平也更友好。    只吃碳水化合物不仅不利于稳定我们的血糖水平，还会对我们的胃促生长素造成严重冲击。所以，饱腹感很快就会变成饥饿感。    只吃碳水化合物后胃促生长素会迅速波动，我们会感到比吃之前更饿。吃碳水化合物会让我们的饥饿感像过山车一样忽上忽下，吃脂肪和蛋白质则不会。    **Q1 需要给全麦食物“穿上外衣”吗？**    我们错误地认为，如果谷物是完整的（如糙米、褐色的意大利面等），那么这些食物对我们的身体就有益。事实是，它们的好处仅仅那么一点点，因为这些食物所含的主要成分是淀粉。    最后要提醒的是，在吃大米时，不管是糙米还是野生稻米，我们最好加一些切碎的蔬菜，如薄荷、欧芹、茴香，还可以加一些烤坚果，如杏仁或开心果，并与烤鲑鱼或者烤鸡一起享用。好了，你吃的碳水化合物已经变得更健康了，并且，在我看来，它也更加美味了。    相对于大米，糙米引起的血糖曲线波动会更小，但是，因为糙米的主要成分是淀粉，还是会导致较高的葡萄糖峰值的出现。所以，吃米饭的时候，最好搭配着纤维、脂肪、蛋白质一起吃。    **Q2 我应该添加哪种脂肪？**    脂肪与糖（糖没有好坏之分，不管它来自哪种植物）不同，有一些脂肪确实要比另一些脂肪对身体更好。    好的脂肪以饱和脂肪酸（来自动物、黄油、酥油和椰子油）或单不饱和脂肪酸（来自水果和坚果，如牛油果、夏威夷果和橄榄果）为主要成分。    不好的脂肪会给我们造成刺激，危害心脏健康，使我们的内脏脂肪增加，并使胰岛素抵抗综合征的病情恶化。它们以多不饱和脂肪酸或反式脂肪酸为主要成分，存在于如大豆油、玉米油、菜籽油、米糠油、油炸食品和快餐中。有一种稍微好点儿的种子油是亚麻籽油。    当饮食中含有脂肪时，我们会更容易产生饱腹感，但是，如果在饮食中添加过量脂肪，葡萄糖峰值的出现确实会极大地被抑制，我们的体重却也会增加得更快。    最后，买任何东西时都不要误以为“低脂”对你更好：含脂肪5%的希腊酸奶要比低脂的酸奶更有助于维持血糖曲线的平稳。    **Q3 如何在饮食中添加纤维？**    所有植物都含纤维，包括坚果等。它们是搭配淀粉类食物最好的选择。你甚至可以尝试纤维药片，如用车前子壳制成的药片。    **Q4 如何补充蛋白质？**    蛋白质主要存在于源自动物的食品之中，如蛋、肉、鱼、奶制品和奶酪。当然，很多植物性食物也含有蛋白质，如坚果和豆类。你也可以使用蛋白粉，但是要买成分表中标明来源的蛋白粉。我一般会选择乳清或豌豆蛋白粉。你一定要确保里面没有添加甜味剂。</code></pre><ul><li><p><strong>附录A 如何做一个控糖女神</strong></p><p>  <strong>当食欲旺盛时:</strong></p><p>  有时候，即使已经使用了我在本书中说的所有窍门，你可能还是想吃糖。下面是战<br>  胜这类冲动的方法。<br>  (1)给食欲一个20分钟的冷静期。在远古狩猎时代，血糖水平的下降意味着人们已经很久没有进食了。作为回应，大脑会告诉他们要选择高热量的食物。而在今天，血糖水平下降，往往是因为我们刚刚吃的食物引起了葡萄糖峰值的出现。所以，尽管有能量储备，也不是很饿，大脑还是会提醒我们去做同样的事情，即选择高热量的食物。血糖水平下降后，肝脏会在20分钟内迅速介入，将储存的葡萄糖释放到血液中，使我们的血糖恢复至正常水平。到那时，食欲通常会消失。所以，当你下次想吃曲奇饼干的时候，设置一个20分钟的计时器。如果你的食欲是由血糖水平下降造成的，那么当计时器响起的时候，这种感觉会消失。</p><p>  (2)如果20分钟到了，但你还在惦记那块饼干，那么就把它留着作为你下一餐的餐后甜点吧。</p><p>  (3)如果你实在等不及将它留作下一餐的甜点，决定现在就要吃掉它，那么请先喝一大杯拌了1汤匙（或者差不多1汤匙，按自己的喜好来）苹果醋的醋汁。<br>  (4)吃之前先吃一个鸡蛋、一把坚果、几勺脂肪含量为5%的希腊酸奶或者一些烤西蓝花。<br>  (5)吃掉它。享受它！<br>  (6)锻炼你的肌肉，在进食后的1小时内动起来，你可以出去散步或者做一些深蹲。</p><p>  <strong>在酒吧时</strong></p><p>  当你在酒吧喝酒时，就没有必要再点一些葡萄糖和果糖含量很高的食物了，这会给肝脏带来很大的负担。</p><p>  能够使我们的血糖曲线保持平稳的酒精有葡萄酒（红葡萄酒、白葡萄酒、玫瑰红葡萄酒和起泡酒）和烈性酒（杜松子酒、伏特加酒、龙舌兰酒、威士忌）。即使空腹喝这些酒，也不会造成高的葡萄糖峰值。你要注意混合酒：添加了果汁、甜味剂或者汤力水的酒会造成高的葡萄糖峰值。</p><p>  啤酒含有很多碳水化合物，所以会造成高的葡萄糖峰值。麦芽啤酒和拉格啤酒要比黑啤（如吉尼斯黑啤酒和波特黑啤）对身体更好，最好选择碳水化合物含量低的啤酒。</p><p>  <strong>在杂货店购物时</strong></p><p>  了解一种加工食物是否会引起高的葡萄糖峰值，不要看前面的标签，要去看后面的配料表。<br>  怎样发现包装上的葡萄糖峰值？第一个要看的地方就是配料表。配料会按照含量降序排列。如果糖排在前5位，那就说明这种产品中有很大一部分都是糖。</p><p>  配料表中有许多不同名字的糖。龙舌兰花蜜、龙舌兰糖浆、大麦麦芽、甜菜糖、糙米糖浆、红糖、甘蔗汁结晶、蔗糖、焦糖、椰子糖、精制细砂糖、玉米糖浆、玉米糖浆结晶、枣糖、粗碎果浆、糊精、右旋葡萄糖、浓缩甘蔗汁、果糖、果汁、浓缩果汁、浓缩果泥、半乳糖、葡萄糖、葡萄糖糖浆结晶、黄糖、黄糖糖浆、高果糖玉米糖浆(HFCS)、蜂蜜、糖霜、麦芽糖浆、麦芽糖糊精、麦芽糖、枫糖浆、黑砂糖、红砂糖、鲜榨果汁、粗糖、大米糖浆、黑糖、糖和分离砂糖。</p><p>  只要水果被改变了形态或者被加工，其中的纤维就会被破坏，水果就变成了和其他糖类一样的糖。</p><p>  每日营养占比指每份食物中的营养素占一天饮食中的营养含量的百分比。一般建议每天2000cal的热量。</p><p>  总碳水化合物和总糖的质量代表着能够引起葡萄糖峰值的分子的量：淀粉和糖类。这部分的含量越高，这种食物就越容易导致你的葡萄糖、果糖和胰岛素水平上升，并引发连锁反应，让你更想吃甜食。</p><p>  纤维是唯一一种不能被我们的身体消化、吸收的碳水化合物——食物中的纤维越多，在食用之后血糖曲线也就越平稳。所以，这有一个小窍门：对于干性食物，要看总碳水化合物和膳食纤维的比率。选择那些成分占比最接近1 g膳食纤维对应5 g总碳水化合物的产品。</p></li><li><p><strong>附录B 控糖女神的一天</strong></p><p>  <strong>早餐：</strong>我在喝咖啡时会加一些全脂牛奶，而不是脱脂牛奶；较高的脂肪含量有助于血糖曲线保持平稳。接着，用平底锅炒2个鸡蛋，加点儿黄油和海盐，然后在旁边放上几汤匙鹰嘴豆。再吃1片抹了黄油的黑麦面包。出门前想吃点儿甜食，我拿了一块可可含量为80%的黑巧克力，在饭后吃它是最明智的，我不会像原来那样在上午11点单独吃它。</p><p>  我用到的窍门包括：<br>  · 窍门4——平稳早餐后的血糖曲线<br>  · 窍门6——选择餐后甜点而不是甜甜的零食</p><p>  <strong>工作时：</strong>我喝红茶（我通常喝绿茶，但是绿茶今天喝完了）。</p><p>  <strong>午餐：</strong>我把前一天晚上吃剩的东西——青豆、芝麻酱烤鳕鱼和野生菰米用微波炉加热一下，这个排序同样也是我吃饭的顺序。</p><p>  我用到的窍门包括：<br>  · 窍门1——正确的饮食顺序</p><p>  <strong>下午茶：</strong>在散步的途中，我发现了一款喜欢的饼干，于是买下了它但并没有马上吃掉。回到办公室后，我先喝了1杯拌了1汤匙苹果醋的醋汁，然后吃了5颗杏仁，最后才吃了饼干。大概20分钟后，我去了洗手间，并在那里做了30个深蹲、撑着洗漱台做了10个俯卧撑。</p><p>  我用到的窍门包括：<br>  · 窍门7——吃饭之前喝点儿醋<br>  · 窍门10——为你摄入的碳水化合物“穿上外衣”<br>  · 窍门8——饭后动起来</p><p>  <strong>晚餐：</strong>我请朋友过来吃晚餐。我准备了用生胡萝卜块和棕榈心片混合而成的蔬菜沙拉，将其作为开胃菜。开饭前，我将自己最喜欢的火腿沙拉和迷迭香烤土豆放在餐桌上。我的朋友们现在都知道要先吃沙拉，再吃土豆，这样能够让他们的血糖曲线变平稳。餐后甜点是草莓和凝脂奶酪。吃完甜点20分钟后，我邀请大家去广场散步10分钟。回来后，客人们精力充沛，都想帮忙洗碗！</p><p>  我用到的窍门包括：<br>  · 窍门1——正确的饮食顺序<br>  · 窍门2——在每餐前增加一道绿色开胃菜<br>  · 窍门10——为你摄入的碳水化合物“穿上外衣”<br>  · 窍门8——饭后动起来</p></li><li><p><strong>后记 独一无二的你</strong></p><p>  本书中的窍门对每个人都适用，并且你在使用这些窍门时不需要佩戴动态血糖仪。但是，如果有一天你佩戴了动态血糖仪，或许会发现某些特定食物可能对你更有效果。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>纵横四海EP42《如何阅读一本书》：阅读的四个层次，你在哪一层？</title>
      <link href="/podcasts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/index.html"/>
      <url>/podcasts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="阅读的四个目的"><a href="#阅读的四个目的" class="headerlink" title="阅读的四个目的"></a>阅读的四个目的</h1><ol><li><p><strong>资讯</strong></p><p> 资讯主要是用来了解当前发生了什么事的，它是不太涉及到深入的理解或者是长期的影响的。</p></li><li><p><strong>知识</strong></p><p> 知识是在资讯积累的基础上进行分析、筛选、理解，总结出规律经验等等。他最后是变成了规律经验、技能。这个是知识，知识才是用来理解世界和解决问题的。</p></li><li><p><strong>理解力</strong></p><p> 知识和理解力之间的区别：</p><p> 第一个区别就是内化了，变成了我自己的知识。</p><p> 第二个用于实践，就跟举例子有关。你是不是能够举出很多的例子在把这个知识用于实践。</p><p> 这个知识满足了这两个条件，我们就从知识跃升到了理解力。</p></li><li><p><strong>娱乐</strong></p><p> 娱乐我觉得也分成两种，一种如果同时有知识，有尤其是有理解，这个时候我们自然而然会产生一种悟道的快乐。第二种娱乐是我们不涉及到知识，也不涉及到尤其不涉及到理解。我们纯粹就是为了娱乐，纯娱乐去读书。</p></li></ol><h1 id="新媒体能取得阅读的作用吗"><a href="#新媒体能取得阅读的作用吗" class="headerlink" title="新媒体能取得阅读的作用吗"></a>新媒体能取得阅读的作用吗</h1><p>社交媒体正在以压倒性的范泛滥的资讯阻碍我们的理解力。他而且他不但就太多选择，等于没有选择。他拿这些信息的洪流来阻碍我们真正的去理解这些信息背后所蕴藏的社会的规律，世界的规律。</p><p>记忆是思想的残渣，你没有思考你就没有记忆。社交媒体很擅长的一件事情就是不让你思考。它可以把所有的东西都包装在一个非常短的时间之内。告诉你说这个事情就是这样子的，这个道理就是这样子的。我给你分析好了，你只要听我的就可以了，那如果在每每在这种时候我们就被剥夺了思考的机会。如果你不思考的话，其实你是没有真正的记忆，你脑子里面是不会装进去任何东西的。</p><p>所以在这样的大环境中，其实阅读才是我们这个时代捍卫心智的强大的武器。因为它不但提供资讯，它提供理解，它能让我们有能力筛选，它能让我们有能力做出应对。如果我们只是获得资讯不理解，那我们就是书呆子，就是无知的阅读者。</p><p>反过来，如果我们进行好的阅读，我们其实也能够获得资讯。更重要的是我们能够获得知识，而且在这个过程中我们获得了理解力，那我们的心智就会随着阅读而成长。反过来我们在筛选高质量的知识和资讯上，效率都会更高。</p><h1 id="读者的自我修养"><a href="#读者的自我修养" class="headerlink" title="读者的自我修养"></a>读者的自我修养</h1><p>主动阅读就是我们作为读者应该具备的基本素养。这里给大家一个比较可衡量的、可操作的主动阅读的标准。就是什么是主动阅读的核心是你必须要能够回答问题。</p><ol><li>这本书到底在谈些什么？就是这本书的主题。</li><li>作者具体是怎么展开说的？就是他的想法、声明、论点。整个论述的过程就是我有这个主题，然后我是怎么给你讲这个主题的</li><li>你说的有道理吗？你说的是全部有道理还是部分有道理呢？你说的这些事实的前提是真的吗？</li><li>这本书跟我有什么关系？为什么我要获得这些资讯和知识？为什么这本书的观点对作者很重要？那为什么对我也很重要呢？我真的有必要去了解吗？</li></ol><aside> 💡基于主动阅读的核心就是提出问题，回答问题。所以我们最好养成一边读书一边记笔记的习惯。一边读书一边记笔记有这么三个好处：第一是笔记会让你保持清醒第二个好处是主动阅读，它就是一种思考第三个好处就是把我们的感想写下来，其实能够帮助我们记住作者的思想</aside><aside> 💡在做这种主动阅读的笔记中，我们有三种笔记：第一种叫做结构笔记。就是全书架构。这是什么类型的书？这本书的谈的是什么？作者是怎么谈的？第二个是概念笔记，概念指的就是观点，一开始是你可以做作者的观点的总结。渐渐的在这个过程中你会产生自己的观点，所以有时候你要把自己的观点也写上去。第三种叫做辩证笔记，就是针对一个主题，让不同的作者跟你开始展开一场讨论。</aside><h1 id="阅读的四个层次"><a href="#阅读的四个层次" class="headerlink" title="阅读的四个层次"></a>阅读的四个层次</h1><ol><li><p>基础阅读</p><p> 就是认字儿，学会读懂句子，摆脱文盲的状态</p></li><li><p>检视阅读</p><p> 重点就是在时间，就是一个快读，需要在很短的一段时间之内抓出一本书的重点，它是一种系统化的阅读。</p><p> 检视阅读就是非常快的把它把一本书读一下的过程中，我们要回答这些问题。比如说这本书是讲啥的这本书的架构是什么？这是一本什么样类型的书？</p></li><li><p>分析阅读</p></li><li><p>主题阅读</p><p> 主题阅读中我们会阅读很多本书，而不是一本书，然后并且列举出这些书之间的相关之处</p></li></ol><h1 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h1><h2 id="两种检视阅读"><a href="#两种检视阅读" class="headerlink" title="两种检视阅读"></a>两种检视阅读</h2><ol><li><p>有系统的阅读或者是粗读，最重要的就是掌握主题和架构。</p><ol><li>先读书名，如果有序的话就读序</li><li>读目录，目录是能够快速get一本书的基本内容和架构的</li><li>如果有索引的话，看索引</li><li>如果有的话，就读一下出版方对这本书的介绍</li><li>挑几个跟主题最相关的章节来看</li><li>把剩下的章节大概的翻一下</li></ol></li><li><p>粗浅的阅读</p><p> 从头到尾非常快的读一遍。你碰到不懂的地方你不要停下来，你也不要查，你也不要思考。总之我们就是尽量快速读完，这就是第二种解释阅读。你这快速的读完这一遍，哪怕你只有50%的理解，甚至你只有30%的理解他，你再重新读这本书的时候，都会帮助你增进理解的。可以听书。</p></li></ol><aside> 💡**多轮复习**大脑是联网的，大脑学习是一个滚雪球的过程。如果你第一遍的时候你的雪球非常的小，你指望你再认真。比如说你花2个小时去琢磨一个概念，你其实雪球滚的就是这么点大。然后你要是快速的滚一遍，雪球就起来了。</aside><h2 id="检视阅读的好处"><a href="#检视阅读的好处" class="headerlink" title="检视阅读的好处"></a>检视阅读的好处</h2><p>检视阅读是为了让我们做好准备，让大脑了解这些信息之后，不但更理解后面的内容，而且大脑会预先找到跟这些内容适配的那个频道。</p><aside> 💡**读书速度慢**他说读书速度慢很多时候并不是一种能力，而是一种习惯。也就是说并不是说这个人读一个字都读一个词需要比别人更多的时间，而是他在读过程中习惯逗留和退行性倒流。改掉这个习惯的一个训练方式就是手指移动法，你要用手指来做光标，当然你在电脑上你就用光真正的光标，你眼睛要跟着你的手指头走你手指移动的速度要比你原先阅读的速度要稍微快一点点。</aside><h1 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h1><p>分析阅读分成三个阶段，每个阶段它都有不同的规则。</p><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h2><p>第一我们先分类。第二我们来做一个简短的总结。第三我们要了解全书的架构。第四我们要在这些基础上找出作者问我们的到底是一个什么样的问题。</p><ol><li><p><strong>规则一：读一本书前，先分类</strong></p><p> 不同类别的书适用于不同的阅读技巧，不同的阅读速度。</p><p> 分类方法：</p><p> |小说||文字小说、绘本漫画类||<br> |—-|—-|—-|—-|<br> |非小说|论述型|专注在一个主题上给你进行深入的挖掘和探讨|需要思考，停下来做笔记|<br> ||叙事型|专注的是一段历史，一个故事、一个体验|一口气看完|<br> ||浏览型|摄影集、绘画作品、历史漫画|合在碎片时间看|</p></li><li><p><strong>规则二：用一句或几句话，给一本书做总结</strong></p><p> 想要知道自己是不是真的理解一本书在说什么，最好的测试当然就是说说看了他到底在说什么。这里我们要加一个条件，就是要简洁的说出来。</p></li><li><p><strong>规则三：找到作者用什么架构来阐述主题</strong></p></li><li><p><strong>规则四：作者想问一个什么问题，或者作者要解决的问题</strong></p><p> 比如说超越百岁问的是长寿到底意味着什么呢？我们又要如何达到这种长寿呢？毫无意义的工作可能问的是为什么现代社会激增的狗屁工作会让我们痛苦呢？我们到底应该怎么办呢？</p></li></ol><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h2><p>就是第一阶段的分析阅读是初步了解作者的观点，在这个过程中会形成一些自己的观点，这是一个主动阅读去理解的过程。第二个阶段是在第一个阶段的基础上，一切都在往上拔升一层，就深入理解作者的观念，然后把第一阶段自己产生的那些想法、雏形，真正的去把它形成一个自己的理解。</p><ol><li><p><strong>规则一：和作者同步词义</strong></p><p> 作者的责任是我尽量去避免模糊地带。读者责任是帮助作者跟随他的词语，努力达成成共识。在这个过程中你要超越语言去处理语言背后的思想含义，超越文法去处理文法背后的逻辑。也就是说在沟通中你千万大家千万不要停留在自的表面上，哪怕对方用错了。但凡你能够理解这个意思，你就不要去再纠结这个用词了。</p><p> 你要结合上下文去理解作者不能自己是怎么理解的就怎么理解，你要想到作者是什么意思。</p><p> 永远都要结合上下文来理解，绝对不能够断章取义。</p> <aside> 💡 **不要做以下的事情** 第一，不要是听到一个词儿产生了自己的理解，然后就不愿意去努力的试图理解对方想说啥就开始批评对方了。 第二是不做确认，就觉得自己理解的对，然后就开始根据自己的理解去发挥后面的谈话了。 </aside></li><li><p><strong>规则二：找到作者的主旨（结论）</strong></p><p> 们可以通过常见的推理的逻辑的架构来找到这个结论。通常结论要不然就是现在一个推理的最前面，要不然就出现在一个推理的最后面。</p> <aside> 💡 **结论是否找对的测试方法** 第一种测试方法是用自己的话说一遍。最重要的是要用自己的话，非常朴素的把这个道理讲出来。但凡你不能用自己的话把这个道理讲出来，你就没有找对作者的结论，或者你没有理解作者的结论。 第二个测试就是举一个例子。你能不能基于它的结论举出一个你生活中观察到的例子。你举不出例子来，那你就是在玩弄文字，你只是把作者的文字玩弄而已，你没有自己的理解。 </aside></li><li><p><strong>规则三：这个结论背后的完整论述是什么</strong></p><p> 到我们的结论概括了我们的整个argument，但是我们不能够只看结论，我们必须要把它结合在一起，看这个argument我是怎么逻辑推理一度到达这个结论的。当你这样做的时候，你就真正理解了作者在说什么。</p><p> 我们看一下整个逻辑中哪些是提供背景信息的，哪些是前提，哪一句是结论。找到结论，你找到前提，接下来用你自己的思想，用你自己的头脑，用你自己的琢磨去把中间的这个逻辑给构架起来。这个就是你找到argument，找到论述的过程。</p></li><li><p><strong>规则四：作者的提出的问题都解答了吗？他是怎么解答的呢？还有哪些问题没有解答呢？</strong></p></li></ol><h2 id="第三阶段（如何写评论，才是有礼节）"><a href="#第三阶段（如何写评论，才是有礼节）" class="headerlink" title="第三阶段（如何写评论，才是有礼节）"></a><strong>第三阶段（如何写评论，才是有礼节）</strong></h2><p>公正的去评断一本书。</p><p>主动阅读不会因为已经了解了一本书在做什么，在说什么而停下来。你必须要能够对这本书提出评论或者是提出批评，才能够算完成。</p><aside> 💡**受教是一种美德**受训：如果你没有自己的判断力，你就没有办法学到任何东西。那么你其实是在受训，而不是在受教。受教和学习一样，都是一种极为主动的美德，而不是卑躬屈膝，而不是照单全收。所以受教的意思是我主动的要去跟作者进行交流。在这个对话中，当然就是既然你要评论，你要批评，那么我们还是要有一种批评的礼节在的。</aside><ol><li><p><strong>规则一：我了解了</strong></p><p> 具体来说就是在你能说在你说出我同意我不同意或者是我暂缓评论之前，你一定要非常肯定的说我了解了。如果我们不了解，就没有办法说我们同意还是不同意。</p> <aside> 💡 本书的作者说这种时候你要是不是遇到瞎评论，你可以请他用他自己的话复述一遍你的观点。如果第一他复述不出来，就说明他根本就不了解你在说什么，此时你就不要理会这种批评了。 </aside> <aside> 💡 以微博为例，如果我在微博上搜一个博主够久的话，我总会看到那么一两个帖子是我不认同的这有什么关系呢？就是人跟人之间的多元性反而是精彩的一部分。你对这个人的评判是经过很多很多帖子下来，以我对他的价值观、道德观、世界观有一个基本的评判。所以当他偶尔说出一些好像似乎不符合你对他价值观的认知的话的时候，我们要迟至少要迟疑一下，而不是马上反应。我们至少要问自己说，这是因为我过去识人不清，还是因为他就人人人无完美，人总是有时候可能会说错话？ </aside></li><li><p><strong>规则二：不要进行无理的争论</strong></p><p> 就是不要争强好胜，非辩到底不可。我们只要达成了一定的沟通，那么我们就可以保留各自的观点，对吧？我了解了你，你了解了我，咱们在有些事情上无法达成共识，咱们就不要再争下去了。</p><p> 越讨论我们越能够解决其中的一些问题，这个过程我觉得就是持续讨论下去都是没有问题的。但是如果说我们每一轮的讨论都在兜圈子，都在同一个问题上，就是互相各执己见，那就没有必要再继续下去了。</p></li><li><p><strong>规则三：区分主客观，也就是尊重知识和个人观点之间的不同。</strong></p><p> 在你做出任何论断之前都要找到理论依据。我觉得这条的意思其实就是说区分自己到底是在表达喜好，还是在进行观点的交流。</p><p> 爹和不爹之间的区别在于，你到底是想要教别人做事儿，还是纯粹的在讲你的东西。</p></li></ol><h1 id="如何写批评，才是有礼节"><a href="#如何写批评，才是有礼节" class="headerlink" title="如何写批评，才是有礼节"></a>如何写批评，才是有礼节</h1><p>当你批评的时候，你必须要至少做到以下四点钟的一点：</p><ol><li><p>你必须拿出你的观点之后，你要证明作者的知识不足</p><p> 你不能单纯的说你没有考虑到叉叉叉，这是很不礼貌的话。要说全了，你必须要说你没有考虑到叉叉叉，这个叉叉叉为什么对你的这个东西是有结论受影响的。</p></li><li><p>或者你要证明作者的知识错误</p></li><li><p>或者你要证明作者不合逻辑</p><p> 这本书的作者说一般有两种荒谬，一种是缺乏连贯，另外一种作者说是前后矛盾。</p></li><li><p>或者最后你要证明作者的分析和理由他不完整</p><p> 对我们的要求太高了，通常你需要高于作者，然后你才能够说你其实你只回答了一部分，你没有回答另外一部分。</p></li></ol><p>在批评的过程中也要注意，不是只讲出这些东西就可以了。你必须要证明自己的结论，就是人人都负有证明自己结论的义务。</p><aside> 💡我说在无声大雅的情况下，口音是一种文化的体现，多文化的体现，是一种个人特色。这种情况下你没有必要揪住口音不放，因为它不影响你的理解。只有当它影响你的理解的时候，我们提出口音问题来是完全OK的。</aside><aside> 💡总之大家一定要知道，在平时的沟通中也是一样，你们不能揪住一个小错误不放，遮住小错误不放的人就是扫兴者，就非常的扫兴。因为这个错误对整体事件、对结论、对论述没有什么大的影响。那人无完人，为什么一定要揪住这些小错误不放呢？揪住小错误不放的行为是一种社会地位竞争的行为。我通过对你错误的指出和打压，造成一种我的社会地位的上升。不管你怎么，只是明意识里面是怎么样的，潜意识就是这样的行为，这是一种非常粗鲁和不礼貌的行为。</aside><h1 id="辅助阅读的方法"><a href="#辅助阅读的方法" class="headerlink" title="辅助阅读的方法"></a>辅助阅读的方法</h1><ol><li><p><strong>相关经验</strong></p><ol><li><p>一般经验</p><p> 一般经验就是我们日常例行正常生活的经验，就是人生阅历</p></li><li><p>特殊经验</p><p> 超越了一般人生活经验的那一些。比如需要通过科学实验来证明，或者说医生写的一些临床的经验。</p></li></ol></li><li><p><strong>其他书</strong></p><p> 那个作者可能会有写其他主题的书，加在一起同一个作或者一起看，其实你会对他有很大的理解。</p></li><li><p><strong>导读与摘要</strong></p><p> 作者的建议是尽量不要使用。</p></li><li><p><strong>工具书</strong></p><p> 字典、百科全书什么的，也可以使用AI工具。</p></li></ol><h1 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h1><p>加起来意思就是说我有一个主题，我要找到相关的书，然后我要找到这书里面相关的章节，然后我要把作者的所有的作者搞出来，先同一个语言，然后我要我要我要决定他们应该讨论哪些问题，然后我要让他们讨论，讨论完了之后我还要加一瓶。就相当于你组织了一个论坛，然后把这整个论坛所有的事情作为一个组织者全都干了。</p><p>五个步骤：</p><ol><li><p><strong>找到相关的章节</strong></p></li><li><p><strong>引领作者跟你达成共识</strong></p><p> 也就是说现在我们不能用作者的语言了，因为我们现在是横跨不同的书。因此你要像一个协调者一样，在不同的书中把所有的语言协调成你的语言。</p></li><li><p><strong>厘清问题</strong></p><p> 比如说我们以爱为主题，那么我们会有一系列的小问题，就是厘清这个问题是你的第三个步骤。比如说什么是爱呢？好，我们爱的艺术可以回答这个问题，为什么爱这么重要呢？这种能力一般是怎么来的呢？自卑与超越可以回答这个问题，如果缺失了爱这个能力会发生什么呢？</p><p> 你要提出一系列你关心的问题，然后你要找出不同的书去回答这些问题。</p></li><li><p><strong>界定</strong></p><p> 就是要找出作者持有不同观点或者不同论述方法来阐述的主题</p></li><li><p><strong>分析讨论</strong></p><p> 好，这个议题界定了之后，我们要去分析评判不同作者的论述观点。</p></li></ol><aside> 💡改良的版本1. 在你已经读过的书里挑选一个或者几个吸引你的主题2. 看到跟这个主题相关的书，你就优先阅读3. 当你读了一些这里面的书的时候，你就要尝试开始把作者带到一起。这个步骤简单的来说就是知识卡片，我们讲过知识卡片就是选择一个主题，在里边把你读到的那些内容都写进去就好了。 </aside><h1 id="五个收获"><a href="#五个收获" class="headerlink" title="五个收获"></a>五个收获</h1><ol><li><p>今天我们了解了怎么阅读一本书之后，我们才会减轻阅读的负担</p><p> 要质量好，读几遍都OK，质量远远高于数量。</p><p> 不要觉得读书是一件原来这么有负担，这么累的事情，反而应该非常兴奋的发现说，原来我用了这些方法之后，我能够快速的得到心智的提升。</p></li><li><p>主动阅读是关键的关键，越主动阅读效果越好。</p></li><li><p>阅读是一项技能</p><p> 我阅读能力不行，我不聪明。我觉得这些其实都是不是就是都没有站不住脚，都不合理。阅读就是一项技能，你只能说我现在这个技能比较低。那么通过我们今天给了这么具体的方法的锻炼，你就可以把这的技能给连起来。</p></li><li><p>对于做读书笔记这件事情就更清晰了</p><p> 第一我们可以用一句话来总结所有的书。第二我们可以给想要做进一步笔记的书回答四个问题。这书说啥的，他是咋说的，说的有道理吗？那我的感想是什么？也就是跟我有啥关系。同时我们也知道了怎么做知识卡片，它就是一种改良型的主题阅读，对吧？如果这些笔记都能够变成输出，那就更好了。</p></li><li><p>可以在今天的基础上做出一张终身书单</p></li></ol><aside> 💡论述型的书它的传达的是知识。叙述型是一种体验。哲学、数学、科学，这所有的这些学科塑造出的是一个我们活着的世界，真实的世界。但是偶尔我们需要脱离一下这个真实的世界，去往一个更深沉更伟大的真理之中。这个真理就是我们内在的真实世界，是我们每一个人独特的世界观。接触这个内在的世界会让我们快乐。这种深层的体验，它会深深的满足我们平时不太有机会接触到的那个部分的自我。从这个角度来说，阅读一部想象文学作品就是应该他的目的就是应该达成某种深沉的经验为目标。总之我们需要想象文学，我们需要想象的世界，故事的世界，我们需要在这个世界中不断的把我们所有平常不太能够用到的那一部分脑神经元锻炼起来</aside><h1 id="三个作业"><a href="#三个作业" class="headerlink" title="三个作业"></a>三个作业</h1><ol><li>第一，开始你的主题阅读。</li><li>第二，给三本书做评论。</li><li>第三，建立你的终身书单。</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>纵横四海EP38《时间贫困》一个人的时间花在哪里,是看得见的</title>
      <link href="/podcasts/%E6%97%B6%E9%97%B4%E8%B4%AB%E5%9B%B0/index.html"/>
      <url>/podcasts/%E6%97%B6%E9%97%B4%E8%B4%AB%E5%9B%B0/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是可支配时间与时间贫困"><a href="#什么是可支配时间与时间贫困" class="headerlink" title="什么是可支配时间与时间贫困"></a><strong>什么是可支配时间与时间贫困</strong></h1><h2 id="可支配时间"><a href="#可支配时间" class="headerlink" title="可支配时间"></a>可支配时间</h2><p><strong>可支配时间</strong>就是花在想做之事上的时间，就是你想干嘛就干嘛的那种时间。</p><h2 id="可支配时间和生活满意度之间的关联"><a href="#可支配时间和生活满意度之间的关联" class="headerlink" title="可支配时间和生活满意度之间的关联"></a>可支配时间和生活满意度之间的关联</h2><p><strong>可支配时间每天&lt;2小时</strong>：会陷入时间贫困。</p><p><strong>可支配时间每天&gt;5小时</strong>：会失去目标感和成就感</p><h2 id="两个增加快乐，让我们过得更幸福的启示"><a href="#两个增加快乐，让我们过得更幸福的启示" class="headerlink" title="两个增加快乐，让我们过得更幸福的启示"></a>两个增加快乐，让我们过得更幸福的启示</h2><ol><li>我们要至少我们要在一天中找到让我们不限于时间贫困的这个时间，理想的话至少是2小时以上。</li><li>下一步要做的是看看这两小时我们应该怎么使用能够让我们更加快乐，这才是重点。</li></ol><h2 id="时间贫困是一种主观感觉"><a href="#时间贫困是一种主观感觉" class="headerlink" title="时间贫困是一种主观感觉"></a>时间贫困是一种主观感觉</h2><p>时间贫困指的其实并不仅仅是可支配时间小于2小时，他指的也是一种感觉。时间贫困是一种主观的判断，是一种我自己内心深处的这种快乐的感觉。假设如果我每天的那可支配时间是2小时，但是这两小时我没有好好的利用的话，其实我的快乐指数也很低。</p><h1 id="两种基本形式的动力"><a href="#两种基本形式的动力" class="headerlink" title="两种基本形式的动力"></a>两种基本形式的动力</h1><div class="table-container"><table><thead><tr><th><strong>积极聚焦</strong></th><th>聚焦于积极结果</th><th>时间充裕时倾向</th><th>对一切的信心都会提升</th></tr></thead><tbody><tr><td><strong>预防聚焦</strong></td><td>聚焦于回避消极结果</td><td>时间紧张时倾向</td><td>不愿意去探索</td></tr></tbody></table></div><h1 id="如何感觉拥有更多的时间"><a href="#如何感觉拥有更多的时间" class="headerlink" title="如何感觉拥有更多的时间"></a>如何感觉拥有更多的时间</h1><h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p>从三个因素上让我们自己感觉到时间更加的充裕</p><ul><li><p><strong>自信心</strong></p><p>  对自己的信心越足，就越觉得自己是时间充裕的。</p><p>  <strong>自我效能感</strong>，指的是一个人相信自己可以做到自己想做的事情的那个信心的程度。</p><p>  影响自我效能感的因素</p><ol><li><p><strong>过往的经验</strong></p></li><li><p><strong>替代经验</strong></p><p> 如果你能够观察到别人成功的完成了类似的任务，尤其是当成功的那个人跟自己有相似之处时，这个时候你的自我效能感也会提高。</p></li><li><p><strong>言语劝导</strong></p><p> 来自于他人的积极反馈</p></li><li><p><strong>情绪和生理的状态</strong></p><p> 当我在感觉良好的时候，放松的时候，那我的自我效能感就是高</p></li><li><p><strong>社会和环境因素</strong></p></li></ol></li><li><p><strong>运动</strong></p><p>  有研究表明运动会提升我们的自我效能感。</p><p>  可以尝试去满足每天走30分钟，这个目标非常的容易。当你一开始的时候，你发现你完成了目标，你的整个感觉真的就瞬间变好了。然后我就觉得这一天我有时间去干很多别的事情。没有过久你就会发现，确实对于整个身体的状态有改变。</p><p>  <strong>实践：</strong>从现在往后数的七天内，请大家坚持至少每天找出半小时的时间，打电话也好，听播客也好，听书也好，拿出半小时的时间出去走一圈。</p></li><li><p><strong>行善</strong></p><p>  帮助他人其实是一种能够显著提高自我效能感的活动。因为你能够帮到他人，那你就说明你们认同自身的能力，会让我们看到我们对别人的生活造成的影响，会增加我们的目标感，增加我们的成就感。</p><p>  当你愿意去帮助别人的时候，你就会自然而然觉得我一定是有时间我才会去帮别人的。</p><p>  实践：就是本周抽时间随机做两件善事，一件给你的亲友，一件给陌生人。</p></li><li><p><strong>敬畏感</strong></p><p>  其实就是当我们产生一种我们超越了我们个体的极限，我们产生了一种敬畏心的时候，我们就会感觉时间变充裕。</p><p>  获得敬畏感的方式：</p><ol><li>比如，看完了电影之后，我的心中那一刻是平静的。是没有觉得我没有时间坐这，暂时就不会回到时间贫困的心态中去。而反而会生出我有很多的时间，我的人生有更大的理想，我可能想要去做更多的事情。</li><li>社交互动也是可以获得敬畏感的。就当我们进入到一段比较好的高质量的很深的人际关系，他突然之间让我们觉得这段关系超出了我们个人的界限。</li><li>艺术肯定是能让你沉醉其中的。那种产生共鸣的艺术总是让能让人平静下来，忘记时间的。每个人都可以找到最打动自己的艺术形式。</li><li>还有成就这件事情，不是你自己的成就，是人类所取得的成就，它也能够让我们产生敬畏感</li></ol></li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>要至少给我们找出两小时的可支配时间。</p><p>所有有些事情就是要少做。如果你要是连续刷5个小时的手机，那就是可以节留出很多的时间来。</p><p>可是我们忙碌的人生中有很多东西是没有办法节流的。节流也就只能截到那儿，一天也就只有24小时</p><h1 id="快乐是一种主动的选择"><a href="#快乐是一种主动的选择" class="headerlink" title="快乐是一种主动的选择"></a>快乐是一种主动的选择</h1><p>当我们用我没有时间叉叉叉这样的句式来造句的时候，第一时间浮现到我们脑海，当然就是我想做的事情。可是让我们心底真正想要去做的事情，这么快乐的事情，我为什么就是想不起来去做呢？咱是不是就应该优先考虑先把这些事情填满我们的时间？</p><p>快乐不是我们的本能，快乐不是我们下意识就一定会做的事情。快乐其实就是一种主动的选择，或者说快乐其实是一种需要你后天培养的能力，而且是需要你主动经常想到我要做让我快乐的事情，我要主动去管理我的快乐。</p><h2 id="记录时间与快乐值"><a href="#记录时间与快乐值" class="headerlink" title="记录时间与快乐值"></a>记录时间与快乐值</h2><p>那怎么去主动努力呢？很简单的方法就是你一定要把自己的时间花在快乐的事情上。</p><p>所有你要看你一天24小时，你的每1个小时是花在了什么事情上，而这件事情让你有多快乐，这个原理非常的重要。</p><p>我们要做两件事情。第一记录你的时间，第二记录你每一个事件的快乐值</p><h3 id="记录时间"><a href="#记录时间" class="headerlink" title="记录时间"></a>记录时间</h3><ul><li><p><strong>方式</strong></p><ol><li><p>如果说我正在PC机上或者安卓上的，直接使用谷歌的日历。如果我是在苹果电脑上，我就会使用苹果电脑自带的那个日历。</p></li><li><p>一定要有一个好用的备忘录，备忘录里面记下，说我这段时间在干嘛，他大概花了多长时间。你再把这个时间重新补到日历上就可以了。</p></li><li><p>以15分钟为单位来记录的</p></li><li><p>分类，按色块</p><p> 尽量的要给不同的时间安排上不同的色块，这个色块就对应着不同的类别。</p><p> 大家可以随着你的使用不断的去进行思考，不断的去进行调整。在这个调整中渐渐的你就会找到你自己最好的分类和最好的颜色。</p></li></ol></li><li><p><strong>内容</strong></p><p>  日历的记录它其实不光是时间的记录，它也是一个非常有用的小的时间生活笔记的一个记录表。记录尽量详细一点，因为你的这个记录是为了对自己的时间使用有更清晰的认知，对自己有更清晰的认知。</p></li><li><p><strong>意义</strong></p><p>  记录时间的意义就是帮助你更好的理解你的时间花在了哪里。我你的时间花在哪里，你就会肉眼可见的看到自己成为一个什么样的人，你的经历构成了今天的你。</p><p>  记录时间不光光是能够帮助了解你个人，还能够给你更多的动力去把你的作息调整的非常的健康。</p><p>  发现后来就是一定要留出这一天的娱乐时间来。</p><p>  以及在这一天的效率非常的高的情况下，就算你今天能够12点前睡觉，整个恢复不过来。你会严重的影响到第二天的效率。</p></li></ul><h3 id="记录快乐值"><a href="#记录快乐值" class="headerlink" title="记录快乐值"></a>记录快乐值</h3><p>我们可以以十分制来记录，一分就是不快乐，对吧？那个十分就是非常快乐，分数越高越快乐，大家自己凭感觉。</p><p>这里要注意的是，我们一定要区分真正的快乐和多巴胺驱动。快乐其实分成两个层级，就是当下的快乐和未来的快乐。</p><h2 id="快乐的三个元素"><a href="#快乐的三个元素" class="headerlink" title="快乐的三个元素"></a>快乐的三个元素</h2><ol><li><p><strong>投入程度</strong></p><p> 当你投入程度越高的时候，你的感觉上就会越快乐。而且你投入的话，你不但当下比较快乐，你得到的成果比较好，对将来你也比较快乐吧。</p></li><li><p><strong>有质量的社交</strong></p></li><li><p><strong>成就感、意义感、目标感</strong></p></li></ol><p>寻找快乐的第一个目标并不是去做更多快乐的事情。我们首先要削减那些让我们不快乐的事情。</p><h2 id="快乐和意义的四个象限"><a href="#快乐和意义的四个象限" class="headerlink" title="快乐和意义的四个象限"></a>快乐和意义的四个象限</h2><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/d5f13d55-2b6b-48e4-b70a-4b1b036c0c2d/0437c18e-fadf-42db-9e1d-8b4deb39b15d/dfb234c8f167abea933014cee265522.jpg" alt="dfb234c8f167abea933014cee265522.jpg"></p><ol><li><p><strong>第一类：既快乐又有意义。</strong></p><p> 这个不用想，无论是现在还是未来肯定都是快乐的时间。</p></li><li><p><strong>第二类是：快乐和意义只占其一的这个事情</strong></p><p> 我们把它叫做无聊的事情。</p></li><li><p><strong>第三类：既不快乐又没有意义</strong></p><p> 当然就是浪费的时间。我们希望我们的快乐直升增加，其实第一步首先要去处理的就是浪费的时间这一类里边所有的事情。</p></li></ol><p>每一个人其实对这些事件的分类都不一样。总之在你自己的这个象限里边，每个人都有自己的意义值，每个人都有自己的快乐值。</p><h2 id="快乐跟踪"><a href="#快乐跟踪" class="headerlink" title="快乐跟踪"></a>快乐跟踪</h2><p>会更明白对你来说这些事件都在你的哪个象限。</p><ol><li><p><strong>首先我们可以写下我们最快乐的三件事</strong></p><p> 就是对我来说又快乐又有意义的三件事。</p><p> 今天开始记录时间，往后的一周你不但记录你的时间段，而且你的每一段时间在当下凭感觉凭直觉有一个分值，然后写下十分分值的三类事情。</p></li><li><p><strong>写下你最不快乐的三件事</strong></p></li><li><p><strong>在你最快乐的三件事和最不快乐的三件事上分别去找共同点</strong></p><p> 写的时候每一件事情都要写出时间、地点、人物、事件。</p><p> 例：作者就发现他所有让他开心的事情的地点都有一个特点，就是户外。在人物方面他发现让他快乐的社交必须是一对一的交谈。</p></li></ol><aside> 💡对大多数人来说，最快乐的事情都是有质量的人际关系，以及跟大自然去建立连接。</aside><h2 id="亲密关系诱导任务"><a href="#亲密关系诱导任务" class="headerlink" title="亲密关系诱导任务"></a>亲密关系诱导任务</h2><p>增加大家能够从人际关系中得到的快乐的方法</p><ol><li>把学生两两分成一组，互相回答三组问题。首先用两分钟回答第一组问题，这些是很基本的问题。比如说你叫什么名字？你来自哪里？</li><li>五分钟回答第二组问题。这些是个人兴趣、目标、经历相关的问题。比如说你喜欢做什么？你的爱好是什么？如果你可以去世界上任何地方旅行，你会去哪里？为什么？你最想改变的一个习惯是什么？这是第二组问题。</li><li>然后剩下的八分钟回答第三组问题。这一组问题开始就相对比较私人，比如说认识新的人对你来说是困难还是容易呢？为什么？描述你最近一次感到孤独的时刻，你最害怕的事情是什么？最近有什么让你感到自豪的事情吗？</li></ol><h2 id="不快乐的三个障碍"><a href="#不快乐的三个障碍" class="headerlink" title="不快乐的三个障碍"></a>不快乐的三个障碍</h2><ol><li><p><strong>关联性</strong></p><p> 就是人际关系，就是跟他人产生真正的链接。如果你阻碍了这个链接，让你觉得你跟世界，你跟他人没有链接，让你觉得孤独的，那肯定就是不快乐。</p></li><li><p><strong>自主性</strong></p><p> 这个很好理解一件你自己本来自己做的是很开心的事情，别人命令你去做，你马上就不开心了。</p></li><li><p><strong>能力</strong></p><p> 也就是说这件事情让我阻碍了我对自己产生能力，就是产生了自我贬低自卑的感觉，让我就是成就感的反面，那这个时候肯定是不快乐的</p></li></ol><h2 id="情绪兴奋剂：做了以后都会觉得很开心"><a href="#情绪兴奋剂：做了以后都会觉得很开心" class="headerlink" title="情绪兴奋剂：做了以后都会觉得很开心"></a>情绪兴奋剂：做了以后都会觉得很开心</h2><ol><li><strong>运动</strong></li><li><strong>睡眠</strong></li></ol><h2 id="无法避免不快乐事件时，我们该怎么办"><a href="#无法避免不快乐事件时，我们该怎么办" class="headerlink" title="无法避免不快乐事件时，我们该怎么办"></a>无法避免不快乐事件时，我们该怎么办</h2><ol><li><p><strong>外包</strong></p><p> 如果你的家务劳动很很繁重的话，很简单的解决方法就是家务外包</p></li><li><p><strong>快乐捆绑</strong></p><p> 就是把你喜欢的事情跟你不喜欢的事情绑在一起。</p><p> 比如说我家务没有办法，我一定要做，那我做家务的时候我就要听播客，我就要听有声书。</p></li><li><p><strong>目标感，意义感，联结感</strong></p><p> 工作上要找到快乐，其实我们的方法就是找到你的目标感和意义感。一定要在工作上积极的寻找朋友，在职场上一定要给你一种人际关系的联结感，才能够弥补你们缺乏意义感和目标感的那种痛苦。</p></li></ol><aside> 💡**寻找自己的目标：使用5Y法**一定要找到一个问题的根源，你不能够停留在第一个Y上。</aside><h2 id="如何让平凡的生活变得更快乐"><a href="#如何让平凡的生活变得更快乐" class="headerlink" title="如何让平凡的生活变得更快乐"></a>如何让平凡的生活变得更快乐</h2><aside> 💡**享乐适应**我们在持续反复接触一样事物的时候，会产生一种适应性。因为熟悉的东西对我们来说是安全的，我们总是去探索新的东西，因此对于熟悉的东西，我们的快乐值就会逐渐的下降，这个就叫做**享乐适应**，他就会削弱曾经的美好经历给我们带来的感受。</aside><p><strong>方法：</strong></p><h3 id="1-计算剩余时间"><a href="#1-计算剩余时间" class="headerlink" title="1.计算剩余时间"></a><strong>1.计算剩余时间</strong></h3><p>随着年龄的增长，人们对于平凡事件所赋予的快乐值会不断的升高，最终会跟不平凡的事件的快乐值等同。</p><p>如何计算：</p><ol><li><p><strong>计算你已经花在这件事情上的时间</strong></p><p> 过去这么多年加起来一共花在这件事情上的次数或者是时间都可以。</p></li><li><p><strong>计算你未来预估会花在这件事情上的时间</strong></p><p> 对未来的预估一定要考虑到各种意外事件。然后预估一个比较合理的你剩下的时间或者是次数。</p></li><li><p><strong>计算一下你剩下的没做的那个部分占总时间的比例</strong></p></li></ol><p>例：我想到我跟我儿子一起散步在这条路上的进度只剩下20%的时候，我突然之间觉得每一天去幼儿园的路都非常值得珍惜。这个快乐值就一下子上来了。</p><p>这个计算进度对我们真的有很深重的影响。我们立刻就能够意识到普通时刻的美。也许做这样的计算，有些人会感到惶恐不安。我自己也觉得有时候计算这样的事情很扎刀子在心里面。但是只有做了这样的计算，你才能够更珍惜所拥有的一切。</p><h3 id="2-仪式感"><a href="#2-仪式感" class="headerlink" title="2.仪式感"></a>2.仪式感</h3><p>仪式感可以让平凡的事情变得不再平凡</p><h3 id="3-中场休息"><a href="#3-中场休息" class="headerlink" title="3.中场休息"></a>3.中场休息</h3><p>大多数的事情其实都是可以使用中场休息的概念，切换很重要，要顺应我们身体的这个韵律，一般来说90分钟就差不多了。但是不同的事件所用用中场休息的时间是不一样。要靠大家自己从实践中自己去摸索。</p><p>也可以多样性，比如运动，不要每次都是一样的运动，你可以变着来。</p><h2 id="活在当下"><a href="#活在当下" class="headerlink" title="活在当下"></a>活在当下</h2><p>当你投入越高的时候，你的快乐程度就是越高</p><ol><li><p><strong>像度假那样的去度过你的周末</strong></p><p> 有研究表明说度假对满足感、健康、创造，乃至工作表现都有非常积极的影响。</p><p> 度假如此神奇的改变你的体验，就是因为度假就是一种当下在度假的时候，你就会自动把更多的时间安排给快乐，更少去做不快乐的事情。</p></li><li><p><strong>练习冥想，推荐无感冥想</strong></p><p> <strong>做法：</strong>在你的周围寻找找五件能看到的事物，四件能摸到的事物，三件能听到的事物，两件能闻到的食物，一件能尝到的食物。</p><p> 在这种无感练习中能够锻炼感受到实实在在的事物，也就是当下的能力。</p></li><li><p><strong>戒网，就是戒网瘾</strong></p><p> 建议我们可以每周找一天的时间进行断网，可以结合前面的周末度假。</p><p> 实在做不到全天断网的话，至少你可以做到说我在这个时间大家找我，不要期望我秒回。这个周末只会早中晚看三次手机来回复大家的消息。所有的社交媒体你都不要刷。</p></li></ol><h1 id="储时罐"><a href="#储时罐" class="headerlink" title="储时罐"></a>储时罐</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>时间管理就像这个桶，当你放入大石块的时候，你还有很多的空隙，你再放入小石子儿，你还是可以填进去。你放完小石子之后，你会发现它还有空隙，能够让细沙再进来。放完细沙之后你再放水，水就能够渗透到整个桶里。但是如果你反过来，你不按照这个顺序你乱来。如果你在这个桶里面先把沙子填满了，那你是不是就放不进石块，也放不进石子。</p><p><strong>时间管理就是一定要给自己的工作划分优先级</strong>，那些重要的东西是大事块，你先把那个大事块填进去，然后你在中间填小石子，然后你再填细沙。</p><p><strong>大石块</strong>：优先级最高的事件，比如说家人和健康这两件事情</p><p><strong>小石块</strong>：优先级稍微次一点的事情，工作上一些重要非紧急的项目</p><p><strong>细沙</strong>：可有可无的小事儿</p><p>我们一定要按顺序来使用我们的时间，就是先保证你的时间上一定要有这些重要的事情。</p><h2 id="细沙陷阱"><a href="#细沙陷阱" class="headerlink" title="细沙陷阱"></a>细沙陷阱</h2><p>就是不知不觉的时候，我们把那些可有可无，不是那么重要的事情填满了我们的时间。那你的大石块，你的小石子儿，你就进不去了，是不是？这个就叫<strong>细沙陷阱</strong>。</p><p>三种常见的细沙陷阱：</p><ol><li><p><strong>刷手机</strong></p><p> 可以我不是不允许自己刷手机，我只是要先把今天所有的这些事情全做了，把这个事情填了，我再来刷手机好不好。</p></li><li><p><strong>回复消息</strong></p><p> 如果你有消息你不在，你不集中在一个时间段去回复，而是有消息你看到的时候，你就会你会发现如果你记录时间的话，你会发现这种时间是很多的。</p></li><li><p><strong>过度承诺</strong></p><p> 就是我们对时间的感受非常不准确，所以很容易过度承诺出去说我未来要做什么。</p><p> 比如说人家邀请你参加一件事情，你当下觉得好像是有点意思，反正就是那天还很空我就先答应下来。结果到了那一天你会发现说，我有很多比他更重要的事情。</p></li></ol><h2 id="细沙陷阱的过滤器"><a href="#细沙陷阱的过滤器" class="headerlink" title="细沙陷阱的过滤器"></a>细沙陷阱的过滤器</h2><ol><li><p><strong>目标过滤器</strong></p><p> 一旦你有很明确的目标，你就能够过滤掉一切不在你这条目标线路上的东西</p></li><li><p><strong>快乐过滤器</strong></p><p> 现在我觉得我们把大石块、小石子都填进去之后，剩下的这个快乐过滤器要过滤的就是要给自己时间去做这些让自己能够快乐的事情。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>我们一开始的时候讲到了可支配时间在2到5小时。如果低于2小时，我们就会陷入时间贫困。如果高于5小时，我们就会陷入缺乏目标感和意义感的无所事事的痛苦。</li><li>首先我们第一步是希望我们能够从这个节流这一方面，找出每天至少可支配时间2小时。</li><li>第二步我们就要进行开源，开源的部分是从主观感受上让自己更加的感到时间充裕，包括运动，做善事，包括让自己感到有些敬畏感。</li><li>接下来我们就要记录我们的时间了。在日历上今天给大家分享了我是怎么用日历这个工具来记录我的时间，以及在这个上面安排快乐值的。</li><li>对于不快乐的事件，比如说占据我们时间最多的像是通勤、家务和工作，都分别给出了让它变得更快乐的方法。</li><li>对于快乐的时间，比如说日常中的美、小确信，我们也讨论了怎么能够从平凡中发现，持续发现美，去摆脱享乐适应的这个问题的方法，我们讨论了活在当下。</li><li>我们也最后讲了这个储蓄罐的概念，就是一定要优先安排大石头和小石子。</li></ol><p>今天讲的内容非常的多，但是如果大家只能记住一点的话，我希望大家记住的就是快乐不是一种本能，快乐是一件我们需要主动去管理，甚至主动去安排时间的事情。快乐是一种需要学习和锻炼的能力，不是与生俱来的。</p><h1 id="部分记录"><a href="#部分记录" class="headerlink" title="部分记录"></a>部分记录</h1><p>就是宇宙中其实存在着很多很多的两种循环，要不然就是良性循环，要不然就是恶性循环。这两个时间漩涡，你踏出的每一步它都不是独立存在的，它都是踏进了一个或良性或恶性的循环。宇宙是熵增的对吧？所以踏出恶性循环的那一步远远比踏出正向循环的那一步要轻松非常多。所以每是我们踏出那一步的时候，总觉得说，就这一次有什么关系。</p><p>第二个是你会发现这一天的效率非常的高的情况下，就算你今天能够12点前睡觉，整个恢复不过来。第二天真的所以你会严重的影响到第二天的效率。如果两天加总在一起，其实你就相当于头一天的这个高校就被抵消掉了。那何苦？那我为什么不在这一天稍微做的少一点，有一种意犹未尽的感觉。我第二天在高校，通常你每一天都保持一种稳定的高效，你整个效率就是最高的。</p><p>我觉得如果你觉得时间记录很累，时间记录很繁琐，很不自由，就是没有意识到你对于时间的判断有多么的不准确，也没有意识到我们人类是天生不擅长让自己快乐的。我需要主动的去安排我的时间以获得我的快乐值，我就会有很有动力，就觉得时间记录是一件必须的事情。而且当记录变成一种习惯之后，其实你对时间的判断会越来越准确。现在我会更加准确的安排明天大概这些时间，大概什么时间点，大概我能完成什么。你看其实时间记录并不是让你不自由，时间记录反而会让你更自由。因为你能够更准确的预估你的时间应该怎么使用，你就能够更自由的去掌控你的时间。</p><p>在我很喜欢的一本书叫做写出我心，里面有一句话我很喜欢，作者说我原本以为自由代表中为所欲为，自由其实意味着自己知道自己是谁，在这世上应该做什么，然后切实的履行自己的责任。我觉得我特别有共鸣，就是真正的自由其实并不是为所欲为，并不是随心所欲。真正的自由是我非常清楚我是什么样的人我非常的清楚我想要什么。并且我能够向着我的北极星进发，去履行我在这个世界上的使命，这个就是真正的自由。如果你不记录自己的时间，你对自己的认知就不是准确，你就不能够最高效率的履行自己的责任，你就不能够空出时间来在这些时间数据的基础上不断的思考，我在这个世界应该做什么，你其实就是不自由的。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>自习室 STUDYROMM 47 Q&amp;A 卷王的年终问答，书单推荐</title>
      <link href="/podcasts/%E8%87%AA%E4%B9%A0%E5%AE%A447/index.html"/>
      <url>/podcasts/%E8%87%AA%E4%B9%A0%E5%AE%A447/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>在面对海量信息时，如何筛选真正适合自己的内容，并找到自己的节奏和主路线？对于如何高效快速地获取大量信息，并有效利用零碎时间，有什么心得或策略吗？</strong></p>  <aside>  我们首先要像节食一样给自己制定一个信息饮食计划（information diet plan），控制对信息的欲望，避免因焦虑而无法专注。建议将80%的时间聚焦于主线阅读，设定明确的目标书单，并坚决执行。对于其他20%的时间，可以被动地接收信息，但要确保这些信息来源是顶尖的。有时候，学会不做某些事情比做更重要，比如减少信息获取，去掉那些对我们无益的信息渠道，更能体现反脆弱性。此外，可以通过构建个人的信息神经元系统，找到各自领域的顶尖知识来源，当有具体疑问时直接向对应专家或渠道提问，形成全面的专家库和知识库。  </aside><p>  其实就是比如说咱们Q到反脆弱一下，Q到塔勒布。塔勒布在最开始解释反脆弱这个概念的时候，就假如说有一些习惯是让你脆弱的有一些习惯是让你反脆弱的。他举了一个例子，比如说你想让身体更健康，你可以做两种事情。一种是增加一些习惯，比如说我多吃点什么，我多去吃补剂，抽个血查一个什么，或者我增加一个什么健康的习惯。另外一种就是我减少一些对自己的伤害。</p><p>  比如说我减少吃一些垃圾食品，减少吃糖，或者我去掉一个不好的习惯。他说比起增加一个习惯，去掉一个习惯会让你整个人更加反脆弱。这个我其实是很同意的，然后我就想跟这个花卷说，我们其实都活的有点太焦虑了。我们总是看别人的这个，就是拿别人知道的事儿和我们不知道的事比。</p><p>  每天其实我也有这个感觉，我都会觉得比如古稀提到一个书我没看过，然后我就会想，那这个书我也得看看，那个书我也得看看。导致我桌上的书，我们家书架上的书和我的这个微信读书，我不知道有没有多少内存，反正就是每天我在读自己的书的时候都很难专注。因为我想的是，我还有这么多书没看，就是哪本书你都没看下去。</p><p>  本来你现在应该是专注的把你手里这本书看完，但是你现在手里这本书也没看下去，其他的书你只是花了时间下载，花花了时间去找，但是你也没有读。因为你沉浸在深深的焦虑里面，所以我就觉得那天你说了一个话，我觉得特别对。就是现在在多吃之前，在想我们怎么获取海量信息源之前，我们要先像节食一样给自己制定一个信息diet的plan。</p><p>  我们对信息的欲望有的时候和对食物的欲望是一样的。看见甜的东西，看见高热量的东西，就想立刻给吃到嘴里的这种基因。</p><p>  其实这么想很有道理，就像你吃东西其实是一种生存焦虑，我们现在迫不及待去鲸吞各种信息，其实也是一种生存焦虑，它只是以不一样的方式呈现出来了。</p><p>  对我觉得这都是我们古老身体的本能。因为我们的古老的身体那会儿是在一个食物匮乏的时期，所以你看见食物就想往嘴里放，我觉得这是没毛病的。那会儿你确实你如果看到一个新鲜的信息，你确实是要把它获取的。因为你获取的信息越多，就意味着你生存能力越强。</p><p>  但是到现在的这个世界上，我觉得我们既不能任随原始的吃饭的欲望知识，我们也不能任凭着自己获取信息的这个欲望而行事，那样的话你就会消化不良。我现在的法则就是我强行聚焦。就是说我今年的年初的时候给自己设定了三个读书的主题，读书的方向。一个叫运动和营养，一个是心理学，还有一个就是社科类的。就比如说像黑天鹅，像塔勒布，像我们讲过的像一如既往这一类的。</p><p>  然后我在每一类图书里都给自己制定了一个非常详细的目标书单，这些书是我今年要恶补的，就在这三个方向。然后这个是定死的，这个占了我80%的时间，系统化的阅读的时间。这个东西无论今天古稀给我推荐一本，我觉得我多该晚上看的书，我不完成我自己的书单的这个任务，我是不去看的。然后甭管今天再见爱人这个节目有多火，好东西，这个电影有多想看，这个东西都是不能动我这个主页的。</p><p>  你都要紧紧地抱住你的反脆弱性。</p><p>  对我就是要专注其他的20%的时间。我现在对自己要求特别低，只有两个字儿就是掐尖儿。除了这三类以外，其他的我就囫囵吞枣，不求甚解的去获取我觉得比较专业的意见。我在菲弗莱里面讲到古稀对于面包现在是有多懂，然后我又是一个我又想吃好吃的面包，但是我对好吃的面包又一无所知的人。</p><p>  每次在我买面包的时候，我现在就强迫自己，要不然就直接问古西，我今天想买一面包，你给我推荐一家，然后你推荐完我就立刻下单，我自己不假思索，不做任何的研究和research。要不然我就打开大众点评买离我最近的，我觉得还OK的，就OK就好。然后现在比如说我今年想知道新闻，那我基本上就是英文博客就听了一两个，然后中文可能就那一个。</p><p>  另外我每天早上上厕所的时候，会打开那个财经和财新，就是随便划一划，就他给我推什么，我就看什么。但是我看的这个媒体本身是一个比较trusted。</p><p>  你把你的读书也变成一个帕雷托效应的模型。80、20 80是你非常有主线的，你非常有目的的，你就死守的。然后另外的20，就是你反正被动的让这个信息过来流经你，然后你来知道一下这个世界发生了什么。</p><p>  然后这个流经的这些东西，你要确保这些渠道都是他所在的那个领域里面最顶尖的对我相信比如说像财经新闻，肯定财新和财经不是覆盖的很全面的那我肯定看的越多对我越有帮助。但是我只有这么一点点时间，所以我就选择放弃。就是我了解那些最重要的大事儿就OK了。然后面包比如说我就fully trust古稀，你可以fully trust吗？对吧？</p><p>  就我成本最低的一种方式，要不然我就随便吃，我就放弃了。你总会要放弃很多东西，我到现在都没看好东西。说实话在家爱人我一集都没有看过，你说你想不想知道？然后你跟大家会损失很多话题，我承认，但是你多少你得损失一些。这个就是我觉得我结识的代价，我信息结识的代价，这个代价我就决定承受了。然后另外我还有一个原则，这个是塔勒布教我的，也是来自反脆弱这本书。</p><p>  他说了一个观点，他看书不看近期的热畅销书，他只看经过时间验证的经典的书。他拿来看，他觉得这个是最节省时间的，我觉得他好聪明。所以你知道我今年的读书的清单，你看我年末的清单，我给你说过两本，一本叫沉思录，一本叫道德前的对，然后我就觉得这个也是你读书的一种掐尖儿。</p><p>  就这些我们刚刚说的像社科，还有脑神经科学的书，我发现其实这些都在十几年前就有的书写的非常之好。所以我们去看经典，确实可能有花卷会问到你们怎么去评判一本书好不好？我想先说的是找的过程中一定可能会遇到不是那么对你胃口的书，那你看了你就气就好了。就像塔勒布讲过的，永远不要去讨厌读书这个行为。你可以讨厌具体某本书，你觉得看了坚持不下去，你把这本书放下，看别的就好了。</p><p>  所以你要在这种不停的碰撞的过程中，去摸索出来自己的读书的趣味还有倾向。还要知道你目前你的读书的需求是什么。还有一点是我从你刚刚讲到的，只要你想获得某一个具体的信息，你就找到那个对应的人或者那个渠道。我有一年给我的年度计划里面写了一条叫构建我的信息神经元系统。我记得这事儿，对，就是神经元它就是发送电信号，就会让你产生思想，对吧？</p><p>  这是神经元，那神经网络就可以组成你的整个的知识库。为什么叫神经元系统？比如说我作为面包代言人，在你的神经元系统里面就是关于比如说询问像面包、烘焙、发酵这些，我是那个神经元。那对于我来说，我的神经元系统里面也有很多不同的人，他代表着不同领域的我认为最顶尖的知识的来源。所以我就会确保当我有具体的一个疑问的时候，我会去找到那个神经元。</p><p>  而所有这些神经元连接起来，第一它们会是我的神经网络。你不知道哪个神经元与另外一个神经元相连，就会产生一个非常迷人的化学反应。第二就是你有非常全面的，我们叫专家系统专家库，可以去询问，可以去请教，然后拿这些东西来反出形成你自己的知识库。所以这是我给自己一个计划。</p><p>  所以如果是总结一下给这个花卷的或者花卷们的建议，就是你先找到你最感兴趣的那点，用80%的时间把这个给学透。因为这你感兴趣的，你学的也快，你学的也用心。然后其他的用20%的时间来铺面，怎么铺面的股息给出了很好的解法。掐尖儿和找比如说懂行的人，然后因为你也在某些方面懂行，所以别人跟你在一块儿他愿意跟你分享。</p></li><li><p><strong>如何避免信息过度消费带来的焦虑感？</strong></p><p>  可以尝试设定主线阅读任务，强迫自己聚焦于核心目标，而不是盲目追求广泛的知识涉猎。同时，对非主线信息采取“掐尖儿”策略，即只关注最权威、最重要的信息源，放弃部分非关键内容。</p></li><li><p><strong>应该push自己一把，还是应该放自己一马？</strong></p>  <aside>  自控力最强的人并非仅在自我较量中取得掌控，而是学会接受并融合相互冲突的自我。当面临是否push自己或放松自己的纠结时，应尝试从更高维度寻找解决方案，让冲突的自我形成合力，共同推动自己朝着目标前进。例如，采用“先行动再说”策略，先进行一定程度的活动，再根据实际情况调整强度，以此达成内在自我的和谐统一。  </aside><p>  因为咱们其实今年讲过很多，一个是过于push自己的很多很多的不好的地方，一个是又说你永远应该往下卖一个火盆儿。How bad do you want？IT?</p><p>  然后我们又告诉大家，你应该找到最小阻力之路。</p><p>  对，我们又告诉大家说，意志力是可以锻炼肌肉，越练越强。但有时候又说说这个肌肉你练的太伤了，它就撕裂了。</p><p>  然后有时候又说你应该去听你心的声音，因为心是最强的肌肉。</p><p>  对，所以这个我承认确实就是那你如何现在制定一个及时的战略，就是我到底是应该push自己，还是应该现在让自己放松下来。我想说的是，其实我今年在自我发现的层面，我觉得有非常大的进步，就今年可以算是我一个开悟的一年。我的自我发现开窍在哪呢？其实来源于我们自习室说过的一句话。</p><p>  这句话叫做自控力最强的人，不是在与自我的较量中获得掌控，而是学会了如何接受相互冲突的自我，并将这些自我融为一体。</p><p>  然后为什么这句话让我开悟了呢？我原来总是觉得自我之间是矛盾的。比如说有一个自我是其实是想要向前push的，然后另外一个自我是向回拉的那我就要是在这两个自我之间做一个选择。我今天是跟A一头还是跟B一头，我只能跟一头。但是我今年突然发现你的目的其实不是非A或B而是把A和B的力量统一起来，形成一个合力。</p><p>  所以我就想跟这个花姐说，如果这种情况经常发生，比如说你每天都会有一些纠结，我现在到底应该往往前走还是应该往后退？我应该push自己一下还是放自己一马？请你现在向上走一步，从更高的地方看你的这个问题，你会发现其实这个是你冲突的两部分的自我，它就像一对争吵的姐妹。所以你现在应该做的不是说我今天听谁的这么简单的一个决定。</p><p>  你需要做的这个决定是如何让她们这俩一对姐妹形成合力，让你往你想往的方向走。我觉得这个才是你应该解决的课题。也是更高阶的一个解法。我在这里也想举几个例子。然后有一个情况，就是我每天早上就在我怀孕之前，我都会要求自己晨练，然后每天早上起来都得下楼跑步。然后这个呢在冬天你也很痛苦，在夏天你其实也很痛苦。</p><p>  然后每天你下床的时候都觉得，我是不是有点过牢，最近太累了，我是不是其实今天应该休息，因为你其实每天都不想跑，但是又说我如果今天不跑，我课本又不完不成，那我明天就会更累，反正就是每天都是这么纠结的。就是这一对姐妹每天早上都出现。当时我的一个解法其实受启发于你和邓亚萍的那期，也是邓亚萍那本书叫新丽。</p><p>  他就说无论我想练不想练，我要求自己先到这个体育场先打100个球，然后之后再决定我今天怎么练就如果打完这100个球我觉得好了，那我今天就正常训练。如果我觉得我今天真的越练越难受，那我今天就休息或者我减强度，我就基本上把这句话给实行下来。</p><p>  来了这一年，然后我发现有一个好处是在于，无论你今天最后的决定是跑步了，就是按照课表跑步了，还是我放弃了，我只跑了他100个球，而我其实可能就是3公里。我无论如何我每天都跑了这3公里，这3公里就变成了你的baseline，因为原来你的baseline是零公里。就比如说我我今天准备push自己一把，我跑了5公里，明天决定放自己一马跑了0公里。</p><p>  那你一年下来你的平均值是2.5公里。但是执行每天下楼就跑3公里，然后之后再决定自己跑多少，你的这个平均值变成了3公里，比你2.5公里增长了0.5公里。我觉得这个就是你让冲突的自我形成了一个和解。这个多的这0.5公里其实就是那个合力。</p><p>  你知道我在这里面我有一个take away，就是所谓的形成合力，也不一定是要让他们同时的向你施加力量，也可以有一个先来后到。比如说像邓亚萍，她的心理里面说了，他的那个观点是叫先无脑挥拍100下。我到了这个场合，我先不要让自己的脑子感受，就是赢家其实靠的直觉，他不思考，他靠的是直觉。</p><p>  对，所以你要过去之后，先无脑先把这个练习给练起来，将你的身体给热起来，让热气瘦弱的身体好好的跟你的大脑对话。我从这里面的一个take away，就是有的时候大脑的保护机制会过强，这个时候你应该做两个事儿。第一个是先行动起来，第二个是有一个5秒的法则。因为等了5秒钟之后，大脑就反应过来，这个事儿好难，他就开始下判断了。</p><p>  所以在这5秒钟大脑反应过来之前，你就先迅速的开始你的热身，迅速你该做手上的一切的事情，先把他给骗过去。然后你就发现那5秒之后，大脑会重新的进入另外一套计算规则。他会对于对事情的难度的评估，进入一个新的一个原则系统里面去。所以我从这本书和这一期里面，我当时的一个take away，就是所谓冲突的自我，它是可以有先来后到的。</p><p>  我先来之前我先来一个蠢蠢的我，聪明的我先后面等一等，他可以等5秒，最后两个人依然是可以很好的共存的。</p><p>  你这个让我想到了之前我们做如何对抗暴食，就对食欲的一个最管用的tips。就是你先在你的盘里放你觉得你应该吃的那个portion，吃完了之后无论你饿不饿，你都等十分钟，十分钟之后再判断。因为这个也是你两个自我饱腹感其实是有滞后的。你那十分钟你就觉得我靠我就跟没吃一样，我就是肯定得再吃点甜的。但其实十分钟之后你就不一定再这么想了。</p><p>  但是后话就是如果你打完100个球，你的大脑反应过来之后还是觉得很累，或者你在十分钟之后还是觉得很饿，那你该吃就吃，就是你的合力。像我说的三公里总是比2.5公里要长的。</p></li><li><p><strong>“不在自己的日子里”怎么做</strong></p><p>  对，然后我在这里想多插一句，就是没有人问这个问题。但是我想说的就是如何面对不像自己的时候，我最近因为可能也是真的是孕期你的整个的体能量值，你的疲劳感其实跟原来都是不太一样的。</p><p>  而且我每天我现在已经重了四点多公斤，就是你每天都拖着一个比原来沉很多的身体，然后又有点肿什么，就是他不舒服的感觉会越来越多。你就像在你最低谷的那个低谷期，我相信大家都长胖过都状态不好，我都很累过。所以我现在逐渐的就是这方面的感触会很深。原来我很少有那种今天起就想摆烂的那种日子，然后现在这种日子越来越多了。有的时候你真的就是望洋兴叹。</p><p>  你看这外边天儿挺好的，你也有计划用，你就累的就是不行，我必须得睡午觉。我上一次跟古稀录那个爱的对谈下棋，我还跟他说，我说姐们我好累，我好困，好难得从你的嘴里听到关于摆烂的话。然后我想跟大家分享一个一句话，叫意志力的死敌是压力。原来我其实老觉得压力是意志力的朋友就觉得在你逼自己的时候，你的意志力应该是最强的。</p><p>  然后我今年就是在我觉得不像自己的时候，我现在知道了往往意志力在最强的时候是你自我和解的时刻。前几天我有三天连续每天醒来都觉得特别累，不想动，然后没有行动力。第一天觉得还OK，我第二天就觉得我你怎么还累？你昨天干啥啥都没干，就正常工作什么啥也没干，还特别累。第三天还特别累，然后我既不想运动，工作还特别拖。</p><p>  就是我知道我这几天其实应该把这些活干完，但是我就是干不完，就是一直拖。那天就无所事事，就刷出来什么买买东西，收拾家，就随便干点什么，然后这个一天就过去了完晚上看看点电视，然后第四天我们的商务给我打电话说薇娅客户快催死我了，你这东西必须得给我。</p><p>  结果我只能当时因为实在没办法了，人家都给你打电话，我就硬着头皮起来就开始弄，结果把那个东西弄完，我咵咵咵咵咵把之前三天欠的活都干完了之后，我还去健了个身。</p><p>  你现在是怎么理解了？塔勒布说的应该把活给那个公司里面最忙的人是吧？</p><p>  对，然后你就发现就这么无心插柳。就是因为这一个电话，你当时烦的不行，突然一下把这三天的活儿都补上了，你好像也没落下啥。所以我觉得那几天让我感觉说人真是流动的，就是包括你的经历，你的效率和你的人格，在天和天之间可能也真是像我爸原来说的一句老话，叫猫一天狗一天。所以有的时候在你不是你觉得今天怎么那么不张威亚，你越给自己压力你越动不了。</p><p>  他只会让你彻底的放弃，会让你摆烂的时间越来越长。但是如果你想到说人真的是流动的，就我的人格，我的能量都是流动的。我可能就像我的月经周期之后的荷尔蒙一样，我就是今天刷一下，高一下，明天低一下。但是我的均值其实是我自己其实当你想到这件事儿的时候，可能往往是你意志力最强的时候。所以我现在给自己的一个tips就是我要在我发现自己今天只能摆烂的时候，先允许自己摆烂。</p><p>  就是我往往是滞后的。就比如说我今天应该健身，我给自己制定一个特好的计划。然后到下午的时候发现我今天太累了，我完全动不了。这个等于相当于你被通知分手，就别人告诉你你得分手了，这个时候你就很被动。但是如果在我发现自己今天估计是要摆烂的时候，我先给自己一个允许。就好像你在发现男朋友想跟你分手的时候，主动先跟他分手一样，就是把这个主动权先读回来。</p><p>  就是我往往是滞后的。就比如说我今天应该健身，我给自己制定一个特好的计划。然后到下午的时候发现我今天太累了，我完全动不了。这个等于相当于你被通知分手，就别人告诉你你得分手了，这个时候你就很被动。但是如果在我发现自己今天估计是要摆烂的时候，我先给自己一个允许。就好像你在发现男朋友想跟你分手的时候，主动先跟他分手一样，就是把这个主动权先读回来。</p><p>  我原来就把自己摁的死死的，不能允许自己原谅自己。因为我觉得我今天一旦开了这个口子以后，我就会每天都原谅自己。然后我是在今年才发现不是这样的。当你原谅自己的时候，也是其他的一切产生张力开始松动的时候，你就会发现它是意志力的土壤，它是绝对可以长回来的。</p><p>  你的这个画面让我想起了拔河，就是在拔河的过程中，您的一个很巧妙的技巧是你先送递给他，然后你再使劲往后一拽。</p><p>  对你得给他送一点力，让他稍微松懈一下，然后让整个对方的军队发生涣散，因为他不知道该怎么合力了。这个时候送完了之后，使劲再往回一扯，这就是你跟你的意志力和你跟你的目标之间的拔河比赛。</p><p>  所以你松的那一下，在拔河的时候松的那一下，其实就是原谅自己。你不要以为你只要一松那边就取胜了，其实不是这样。你松一下，你往回夸这么一拽你就赢了。是的，所以我再次call back一下这句话叫意志力的死敌是压力。在你已经不像自己的那些日子里，不能死咬，不能拼命就不原谅自己。</p><p>  一定要把自己往回拽，想象的像拔河一样，先原谅自己，先接受我也有摆烂的这一天，再往回一拽你就成功了。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>独树不成林98-如何抵抗互联网上越来越重的戾气和恶意？</title>
      <link href="/podcasts/%E7%8B%AC%E6%A0%91%E4%B8%8D%E6%88%90%E6%9E%9798/index.html"/>
      <url>/podcasts/%E7%8B%AC%E6%A0%91%E4%B8%8D%E6%88%90%E6%9E%9798/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，欢迎来到读书不成林。今天咱们这个播客讨论的是我最近的一些想法，那就是如何抵抗互联网上越来越重的戾气和恶意。</p><p>我相信这个现象不需要我来论证，是不是我们大家都可以注意到，越来越多的人不愿意在网上发表自己的观点，越来越多我们原来尊重、喜爱甚至崇拜的对象，可以在一夜之间因为一些言论或者行为触犯了某一些规则和共识，或者说他过去的言论和行为被揭露，一夜之间成为了过街老鼠，被人攻击，被人审判，被人居高临下的审视，这种戾气和恶意无处不在，变得越来越普遍。</p><p>我们就事论事的话，可能会觉得，哎，这个人好像确实做了一些错事，确实不应该说这些话，确实不应该做这些行为，确实值得被深挖他个人历史里令人讨厌的或者说表里不一的一些事迹，这个人确实值得被发展成一门学科。就事论事的话，我们会觉得这种戾气和恶意，它并不是完全毫无理由的。但是如果我们退一步，从广义上来观察这个现象，这一整个公共讨论环境又被这些越来越常见的一瞬间就可以翻涌上来，包裹摧毁，你的戾气和恶意，变得这个公共环境变得乌烟瘴气，不但让越来越多的人失去了说话的欲望，甚至会创建一个人人自危的环境，让越来越多的人恐惧而不敢说话，让越来越多的人自愿的加入围观审判的大众，加入施加恶意和利器的审判方。审判别人，不但能够给予我们道德上的满足感，更重要的是它能够让我们感到自保安全。当你把审判的手指指向别人的时候，起码在那个时刻你是安全的。但是退一步讲，这样的一个大环境是一个越来越不友好的大环境，一个充满了戾气和恶意的公共讨论环境，是一个我们可以预设路人是残忍的看客的公共讨论环境，而不是心怀善意的听众。</p><h1 id="三个恶习"><a href="#三个恶习" class="headerlink" title="三个恶习"></a>三个恶习</h1><p>今天这一期播客我想要对立三种恶习，这三种恶习分别是残忍、虚伪和傲慢。我认为互联网上绝大多数的恶意和戾气，都是出于对于后面两种恶习的过于不容忍。我们过于讨厌他人的虚伪，也过于讨厌他人的傲慢，以至于我们忘了自己的虚伪和自己的傲慢。我们忘了虚伪是人性的一部分，傲慢也是人性的一部分。如果我们能够把互联网想象成一个极端民主的环境的话，因为人人都可以在上面发声。我觉得一个民主的社会，一个民主环境，他对于虚伪和傲慢这两种品质拥有着天然的敌意乃至于恶意。今天我们要讨论的其实就是虚伪和傲慢这两种品质。</p><p>你可以把这一期播客理解成是我对于虚伪和傲慢的维护。与其说是维护，不如说是我想要好好的展开讨论一下，这两个品质究竟意味着什么。我觉得这是每一个人身上人性身上共存的特质。但是在民主社会，在互联网这个民主的语境中，我们过于习惯指责他人身上这两种充满了人性的平常的恶习。我们拿着放大镜不停地去审判他人身上的虚伪和傲慢。在几乎所有情况下，这种审判只能够加重我们自己身上的虚伪和我们自己的傲慢。与此同时，在审判别人的虚伪和傲慢的同时，他会加重我们自己第三个恶习。我觉得这第三个恶习才是对于公共环境伤害最大的一个恶。</p><p>可惜那就是残忍，它会让我们变得更加残忍。我刚才讲的这三种不好的品质，三种恶习，残忍带来的是一定程度的冷漠。虚伪带来的是一定程度的说一套做一套，言行不一，行为和语言上的不自洽。傲慢带来的是我们对于自己所在群体感到的一种优越感。</p><p>我相信，我们都可以承认，残忍、傲慢和虚伪都不是什么好东西，都是一个良善的人应该要尽可能克服的恶习。一个良善的人应该要尽可能的减少他的残忍，他的虚伪和他的傲慢。但是我想说的是，与此同时，这三种恶习都是极其平常的恶习。如果我们拿着放大镜转而放到自己身上的话，会发现我们每一个人都或多或少的有点残忍，有点虚伪，有点傲慢，这是每一个人身上难以避免的品质。我的观察是在一个人人都可以发声的互联网环境中，我们对于虚伪和傲慢过于不宽容，我们甚至会要求其他人完全不虚伪，完全不傲慢，一旦发现了他们的虚伪和傲慢，就可以立刻开始审判他们。这种行为是一种残忍，残忍它也是一个恶习，我甚至愿意说它是一个比后后面两者更危险、更有危害的恶习。</p><p>因为虚伪和傲慢很难成为一整个公众特质，但是残忍可以成为公众的特质，一大群人可以极其残忍而不自知，甚至为此感到沾沾自喜，因为他们感到自己正在做一件消除其他不好的东西、其他恶习的行为。我们正在消除他人的虚伪和他人的傲慢，这种庞大的、广泛的残忍会造成一个充满了恶意和利器的公共环境。</p><p>今天讨论的内容的灵感来自于我最近重温的一本我非常喜欢的20世纪女性政治理论家rude clare施克莱写的一本书，叫做平常的ordinary vices。所以我可以把我的结论先放在开头，我想说的是如何抵抗一个越来越充满了liq恶意的公共讨论环境。那就是我觉得我们作为一个又一个独立的个体，在听播客的，你不是公众，你是一个人，可以尝试着对于人身上普通的恶更加宽容，当然不是完全接受这些恶，但是我们可以更加宽容别人的虚伪和傲慢，不是因为虚伪和傲慢不值得鄙视，而是因为我们自己也挺虚伪，也挺傲慢的。而且通常在我们对他人的虚伪和傲慢表示残忍的审判的时候，这个行为在绝大多数时候也是我们自己傲慢和虚伪的体现。反思带来的宽容，是我能过一个平凡而艰巨的道德生活，作为一个个体我能做出的努力。我觉得一个完全不宽容、虚伪和傲慢的社会，必将是一个残忍的社会。</p><p>这可能是被科技民主化之后的社会，现代社会最残忍的形态。哪怕我们不反感残忍，但是一个残忍的社会将是一个难以生存的社会。它是一个没有温情的社会，没有善意的社会。这会是一个让你感到面目全非，不知所措，从而只能一言不发的社会。所以今天接下来的内容，我想要讨论我刚才说的这三个恶习，虚伪、傲慢和残忍。讨论这些平常的恶的目的不是为了把它们简化。简化并不能够使这些品质在我们心中更加明晰，恰恰相反，我想要把它们复杂化。通过使它们变得更加复杂，我们对于这些品质的体会也会更加明晰。</p><h1 id="虚伪"><a href="#虚伪" class="headerlink" title="虚伪"></a>虚伪</h1><p>OK我们先来说一说虚伪。虚伪它有一个反义词，虚伪的反义词是什么？虚伪的反义词是真诚。我们讨厌虚伪，是因为现代人把真诚当做一种美德。</p><p>现代社会，尤其是互联网上，有一个极其普遍的观念，那就是真诚是美德，我一无所有，只有真诚，这是很多人的宣言，不是吗？甚至可以更进一步。我这个人就是充满了各种不好的品质，我没礼貌，我一事无成，我干了很多坏事儿，我没素质，我没有美德。但是我真诚地展示着我的平庸，甚至是我的恶劣。只要我真诚，我就可以招人喜欢我觉得所谓互联网自媒体时代，绝大多数人都感到真诚是我需要的唯一品质。我一我一无所有，只有真诚，甚至那就够了。我只要能够真诚的分享那就够了。 其实在互联网时代的政治也是一样，政客最讨人喜欢的品质是真诚，哪怕是你在真诚地描述自己做的一些坏事儿。只要你能够让选民或者是大众觉得你是诚实的，你不虚伪，你就可以获得他们的喜爱。他们喜欢你就可以超过那个他们觉得虚伪的对手。</p><p>我不知道大家记不记得2016年，特朗普作为一匹政治黑马，他在16年之前都不是共和党员，当时所有人都觉得特朗普不可能战胜希拉里。我之前在那个特朗普选民都是什么人呢？那期播客里讨论过，在2016年的时候，民调显示98%点几，显示希拉里能够战胜特朗普，成为2016届的总统这个结局。当然咱们知道特朗普打败了希拉里，成为了当时的美国总统。其实他们在进行辩论的时候，有一个著名的时刻，让特朗普获得了很多美国选民的青睐，也让我当时觉得哇哦这个人有点东西。 就是在希拉里跟特朗普辩论，我忘了是第一次还是第二次辩论那个台上，希拉里准备了一记重拳，准备挥向特朗普。希拉里说，特朗普，你是一个狡猾的商人，你是一个不好的公民。因为你之前偷税漏税，不是非法的偷税漏税。因为美国人的税务制度里有很多合法的机制，可以帮助你在在法律范围内灰色地带规避你纳税的方式。希拉里为此指责特朗普，他说，你之前盈利的那些钱，都被你通过规避税收的手段，没有向税务局缴纳你应该缴纳的税，就你这种素质低下的公民，你凭什么来领导美国人成为美国的一把手？ 那个时候特朗普他的回复是什么呢？特朗普使用了真诚，他用他典型的那个表情，他耸耸肩一摊手。他说对，没错，我就是一个狡猾的商人，我用合法的手段偷税漏税，因为我是一个好商人，聪明人就是要干这种龌龊的事情，我偷税漏税是因为我是一个好的商人。特朗普说出这句话之后一片哗然，因为他是美国历史上第一个公开承认他就是干了这么一件合法的偷鸡摸狗的事儿的这样的一个总统候选人。当特朗普讲出这句话的时候，我其实就理解为什么会有这么多老百姓网友喜欢特朗普。因为他真诚，他的真诚，他真诚的承认了他自己就是干了偷鸡摸狗的事，合法的偷鸡摸狗。它看起来比希拉里这种诡辩的、成熟的、遮遮掩掩的职业政客要来的招人喜欢的多。一个真诚的小人比起一个虚伪的君子，在现代社会更招人喜欢。</p><p>听到这里，你可能想说，这有什么问题吗？我们要求政客能够言行一致，我们希望社会可以完全开放、完全透明、完全诚实。我们希望公众人物可以透明地承认自己的贪婪，透明地承认自己的花心，透明地承认自己的野心，透明地承认自己做事情有什么不择手段，不对公众隐瞒任何事情。一旦发现这个人有什么虚伪的行为，我们要么试图将这个虚伪根除，要么试图去痛斥这种虚伪，这有什么问题吗？想要一个开放、诚实、透明的社会有什么问题吗？</p><p>我们可以看到，在西方民主社会，他们对于公众、对于政客虚伪行径的反感变得越来越激烈。在英国和美国，他们发现这种政府高官首相boris Johnson制定了新冠疫情聚众派对的规则之后，自己违反了这些规定，群众对于他们的反感之激烈就像是一场政治斗争一样，我们知道这个boris Johnson下台就是因为所谓的派对门事件，他被英国记者爆出来说，他没有遵守自己制定的这个疫情期间公众呃，聚众派对的规则，这是一种虚伪，这种虚伪使民主老百姓恼火，越来越多的西方民主政客因为被发现不坚守自己的规则，言行不一从而毁掉了自己的政治生涯听到这里，你会理所当然的觉得这种对于虚伪的厌恶不是很好吗？我竟然想要维护虚伪，站在这些政客的角度去维护虚伪，我是不是有病？虚伪当然不是一件好事儿，我在这不是试图在论证虚伪是一件好事，但是恰恰是因为虚虚伪它是一件非常平常的恶习，它不是一件好事儿，我们想要消除它这种消除虚伪的欲望，在我的观察中，它不但无法消除虚伪，而且在很多时候它会带来一种残忍。我的观察是，公众对于虚伪的讨伐，在几乎在所有时候都是一项自欺欺人的运动。</p><p>自欺欺人的原因有2，第一点是，如果我们要求透明，我们要求人人言行一致，我们要求公众人物不对大众进行任何的隐瞒，我们要求建立一个完全开放、完全诚实、完全透明的社会，并且以此为标准去要求我们的公众人物，不管他是政治人物还是明星。这种透明化的运动只会迫使政客和其他的公众人物寻找更加隐秘的地方，来隐藏他们不想被人知晓的事情。一个完全要求公开的文化带来的结果并不会是完全的公开带来的结果通常是原来的那些秘密会被隐藏在更深更黑暗的角落。 我的第二个观察，他为什么是自欺欺人的？这种对于虚伪的讨伐，他更重要的自欺欺人的原因是因为他是一个自相矛盾的运动。最终我们去观察它给社会带来的改变，并不是虚伪的减少，而是虚伪的增加。我们看到的不是越来越多真诚的人，我们看到的是越来越多虚伪的真诚的人。所有的人都会变得更加虚虚伪的真诚，假装真诚。</p><p>其实让我想做一个播客。讨论虚伪和真诚的有一个重要原因是前几天我不知道被一个什么杂志的记者采访，忘了是什么杂志了。这个作者，这个记者在听完了我有一期讲互联网的播客之后，应该是如何哗众取宠给我发邮件，他说他在写一个文章说现在人人都要当博主，旅游博主、知识博主、读书博主、离职博主、离婚博主、结婚博主、生娃博主、丁克博主，年轻人渴望通过在互联网上自我表达来获得共鸣。这个记者听完我的播客之后，因为我在播客里面说，能够在互联网上成功的哗众取宠获得尊重，你需要的一定不是真诚的表达自我，你需要的是有保有保留的表达自我。这个记者感到很困惑，就连连追问。他说年轻人要如何通过自我表达，真诚的自我表达来达到共鸣呢？真诚的自我表达和获得别人的关注，这两件事情如果有冲突，那该怎么办呢？</p><p>我跟这个记者聊了1个小时，我觉得他就是没有办法放弃这个执念，放弃真诚是一件好事。这个执念他的这个执念，我觉得是跟互联网网上很多把真诚视为一种美德的年轻人心中怀有的执念是一模一样的那就是他觉得寻找自己一定要通过放弃伪装，放弃虚伪，摒弃虚伪，一定要通过无所保留，说实话不做一个伪君子，保持绝对的诚实和透明，一个绝对诚实的自己才是一个真实的自己，一个虚伪的自己就不是一个真实的自己。这是一个非常普遍的执念，对吧？我觉得这个想法被很多现代人当做成是一个真理。所以当这个执念就是我不能虚伪，我一定要做一个真诚的人。</p><p>当这个执念跟现实起了冲突的时候，我们会觉得现实有问题，现实糟透了，现实是腐败的。当时我觉得我没有试图让这个记者理解我想要表达的一个观点，我只能够在播客里自己自言自语地表达。我当时是这么跟他说的，我说我不认为寻找自我需要的是真诚，这是一种浪漫化的自我，浪漫主义的自我，这是一个极端。只有你浪漫化了一个所谓的自我，你才会觉得失意的、直接的、不加思索的、没有隐藏的、毫无保留的、完全透明的自我表达，就可以开启一条路，让你直接通往真正的自己。</p><p>现在很多成年的年轻人不理解小朋友都理解的事情。那就是在一个小朋友跟他最好的朋友描绘一件事情的方式，跟这个小朋友跟他妈妈描绘这个事情的方式，跟这个小朋友跟班主任描绘这个事情的方式，一定是有所差别的，有所隐藏的。没有一种描绘方式是完全真诚的，每一种描绘方式都包含了某种隐藏。这种隐藏我们可以说它是一种虚伪，我们也可以说它是一种成熟。这种小朋友都知道的虚伪，他背后需要的是是一种是一种实践智慧，也就是古典美德中亚里士多德认为仅次于知识上的智慧。索菲亚的另外一种现实生活中的实践智。So funy用英文来说，知识上的智慧是wisdom，实践中的智慧是prudent。</p><p>所有的家长在教育小孩的时候，都需要运用这种言行不一的虚伪，我们可以叫做伪君子的那套，家长教育小孩的时候一定是说一套做一套的，一定是言行不一的。家长在教育小朋友的时候会跟他说，做人就是不能撒谎，这不代表家长这辈子不会撒谎。家长跟小朋友说我们不能做坏事，这不代表家长没有做过坏事。家长跟小孩说未成年不能够抽烟喝酒发生性关系，这不代表家长自己未成年的时候没有做过这个事儿。家长跟小孩说，你要好好学习，要把作业做完，不要抄袭。这不代表这个家长自己小时候就好好学习了，就做完作业了，就没有抄袭了。</p><p>现代人一旦发现了家长是一个表里不一的伪君子，就会立刻像小人得得志似的，揪着这种虚伪反过来指责家长，说你凭什么这么要求我，这是你自己都没有做到的事情，对吧？这是一种表里不一。我们假设一个百分之百真诚的家长，一个不虚伪的家长，他从小跟小孩说真诚的实话，他在社会上摸打滚爬获得的残酷的真理，他跟小孩说这个社会就是一个吃人的社会，好人没好报，做坏事也不一定有报应。苦读书多半不能让你改变阶级。看到摔倒的老人，你最好不要上去扶，防止他讹你。看见有权有势的人，你要多去八点。我们对比一下刚才这个虚伪的家长和现在这个真诚的家长。我相信这个对比会让大家意识到这个真诚的家长他不是一个好家长。</p><p>为什么不是一个好家长？因为在不同的社会关系中，在不同的场合里，对不同的人我们就是要说一些不同的话。如何说不同的话，去隐藏一些绝对真实的观点，如何适当的虚伪，这需要要的是实际生活中的智慧soproni一个过于把真诚当做美德的社会，是一个把无知当做个性的社会。作为一个成熟的人，有时候我们不光光要通过自我表达来寻找自我，我们还要通过自我隐藏来寻找真实的自我。学会如何在不同的人面前说不同的话，在晚辈面前说晚辈该听的话，在长辈面前说给长辈听的话，在互联网上有所保留的说话，在现实生活中有所保留的说话，这是虚伪。但是这也是一种实践的智慧，这需要的是一种实践上的知识，这才是美德，毫无保留的真诚不是美德，我们顶多可以说它不是一件坏事儿。</p><p>所以咱们话说回特朗普，特朗普作为一个民粹主义领袖，他之所以能够在极短的时间内在2016年崛起，我觉得他的选民喜欢的重要原因就是因为他看起来比其他虚伪的政客更加真诚，我觉得我跟特朗普有一个共同点，那就是我们都可以让听我们讲话的人感觉到我们很真诚。但是实际上我想说的是，特朗普我不知道，毕竟我也不认识他，我就说我自己。我想说的是我之所以能够让很多人感觉到很真诚，并不是因为我真的很真诚，而是因为我掌握了真诚的艺术。换句话说，我知道如何虚伪的有所保留的让自己假装真诚。这一点是我在如何哗众取宠那期播客里讲的重点。从我自己蔓延出去，我坚信所有能够以真诚作为个人特质而讨人喜欢的公众人物，他们到那个层次了之后，一定不是纯粹的真诚，他们一定是掌握了一种真诚的艺术。真诚的艺术只不过是用更加漂亮的话来描绘一种虚伪而已。 特朗普地毯下的秘密还少吗？我并不认为他在地毯下的那些肮脏事儿要少于他批评认为他不够真诚的那些华盛顿的其他职业政客。但是他在演讲的时候，他懂得如何把自己的真诚呈现给用令人讨讨人喜欢的方式，令人信服的方式呈现给他的选民。让他的选民我不知道你们有没有去听过特朗普竞选演讲的时候，对于他支持者的那些采访。他的支持者非常统一的，相对常见的一个声音就是他们会说这个政客特朗普不像其他政客一样在骗我。特朗普知道如何让别人觉得他很真诚，这是一种真诚的艺术，the art of appearing authentic.</p><p>特朗普在很多时候是如何展示他的真诚呢？我觉得他是在使用一种残忍的方式。特朗普是一个把残忍当做自己名片的政客，他展现自己真诚的方式很多时候就是在展现他的残忍。他对于他对手的残忍，他对于美国一整个既有的政治体系所维系的这种假惺惺政客之间贸易的残忍，他对于攻击他的人的残忍。</p><p>为什么特朗普在2016年可以撕碎共和党体制内的政客以及撕碎希拉里？就是因为他会残忍地直指对手的缺点，毫不留情面地用一种不给对手留后路的方式去挑起他人对于她对手的攻击。比如说他说我们要把希拉里给搞起来locker up，比如说他嘲笑他的那些共和党竞选的对手给他起的那些外号，他羞辱和攻击他讨厌的媒体。你可以说这个就是特朗普讨人喜欢的原因，他真诚地攻击他的对手，他不虚伪。但是在听完了特朗普如何改变美国政治布局的那期播客的朋友，我换一个方式来总结我那期播客的一个主要的观察，就是在特朗普之后，美国政局之所以变得更加极端，就是因为总体来说，大家都变得更加残忍了。</p><p>特朗普介绍到政治舞台上的这些攻击别人的方式，那种不留后路地撕碎别人脸面的直接讨论，政客私生活领域的这些平时不会放到台面上的这种攻击方式。在他之后，这种残忍进入了美国民主政治的讨论领域。他真诚地承认自己就是一个骗子，他真诚地承认自己就是合法的偷税漏税了。他真诚的承认自己就是在婚内出轨，睡了一个雁行。这种真诚其实是一种厚颜无耻的真。</p><p>我的观察是在互联网上运行的这种民主社会公众极端厌恶虚伪，乃至于我们甚至会奖励厚颜无耻的真诚，哪怕这种真诚他是残忍的真诚，也会有人拍手叫好，也会有人说好歹他是真实的。但是我想要对这种拍手叫好泼一盆来自于我的冷水。我觉得想要创造一个没有那么有恶意和戾气的环境，我们需要的是对于这种厚颜无耻的真诚少一点拍手叫好。</p><p>18世纪的法国哲学家拉UQ有一句非常著名的话，说的是伪善是恶习，在向美德致敬。我觉得当然真君子要好过伪君子。我们这个社会，我相信大家都可以感到真君子是越来越少了。但是我们面临的这个局面，好像更像是一群厚颜无耻的真小人在那里赶尽杀绝，还愿意假装向美德致敬的伪君子，仅仅是因为他们虚伪？我的想法是一个真小人横行霸道的腐败社会是不可能出现真君子的，我们需要的是一个对伪君子拥有更多宽容的社会。我宁愿先做一个向美德致敬的伪君子，我也不想做做一个真小人，因为哪怕暂时还没有良好的德行，我也不想完全的放弃我对于美德的向往。</p><h1 id="傲慢"><a href="#傲慢" class="headerlink" title="傲慢"></a>傲慢</h1><p>OK接下来我们要说的傲慢，傲慢也是一个让公众非常厌恶的品质，我们极其警醒他人的傲慢，并且出于本能的厌恶他人的傲慢，非常有意思。这个播客讨论的三种常见的恶习，残忍、傲慢和虚伪。我刚才说我们不厌恶残忍，但是我们极端的反感虚伪和傲慢。我们几乎本能的就可以发现他人身上的虚伪和傲慢。我觉得我们对于傲慢的厌恶甚至要更甚于虚伪，因为建立在民主人人平等之上的，人人都可以发声的互联网这种社会的应然是他他的道德准则是人人平等。我们应该平等，我们或多或少应该是一样的，或者至少应该平等的对待彼此。</p><p>哪怕我们可以容忍差异，但是我们不允许我们的差异能够使一些人凌驾于他人之上。民主社会的特质就是反对任何凌驾于他人之上的特权。有关于傲慢，我想要提出两个我自己的两个方面的观察。我认为傲慢有两种展现形式。第一种是你对于自己社会地位的一种广泛的傲慢，这种傲慢是广义上的。第二种是你对于具体对象产生的一种具体的傲慢。</p><p>我们先从第一种广泛的、广义的傲慢开始讲。不管怎么样，我们可以把傲慢定义为一种优越感。这种优越感它脱离了事物真正的内在价值，它是建立在一种我们认为不公平的外在优势之上的。傲慢之所以使我们感到愤怒，并不是因为我们愤怒于这个人他的优越感本身。我们愤怒的是他的这个优越感的根基是建立在某种不公之上的。我们认为这种根基不应该给予这个人优越感。</p><p>我给大家举几个最直白的例子。前几天我的好朋友状元姐来找我吃饭。状元姐考了江苏省理科状元之后，就去了香港大学学习。他来我们家吃饭的时候，他跟我说，前几天他在纽约参加港大校友会的时候，遇到了各个年龄阶层的港大毕业生，有他这种三十多岁的，还有70后，甚至还有50后。他跟我说，那个70后的校友在校友会上摆明了他自己是一个精英，是一个纽约律所的管理合伙人，在那个校友会上大放厥词，就是说我的微信我不加合伙人以下的人，我看不起年薪多少数字以下的，我的朋友圈那都是只有华人精英才能够进入我的朋友圈。这是一个有点令人搞笑的傲慢的一个人，对吧？状元姐跟我讲这个故事的时候，她带着一种鄙夷的态度跟我描述这个故事。因为他觉得这个70后在校友校友会上，当着师兄师姐的面，直接就说他看不起低于某个社会阶层的人，或者说那个社会阶层的人不配拥有他的微信，这是一种非常广泛的傲慢。</p><p>第二个故事也是状元姐的故事，我不知道为什么状元姐是混社会的人，所以她认识的坏人比较多。我身边都是身家清白的书呆子，所以见舞蹈这种乱七八糟的人说。云姐跟我说，她公司有一个跟她关系很好的男同事，每天醉生梦死，兴趣爱好就是开着豪车去社交软件上约会漂亮性感的女孩，跟她们发生性关系。 状元姐跟我说，她最匪夷所思的地方就在于这个男同事他一方面可以做着这件事情，另外一方面他真诚的觉得自己是一个传统顾家的好男人，他以后人生的规划就是去找一个单纯的好女孩，年轻漂亮单纯的好女孩，成为他的妻子，组建一个家庭。他对于这个能够成为他妻子的女人的要求也是有一种非常粗暴的，硬性的，关于外貌、年龄、身材和长相的要求，低于这个要求的人他看都不看，我们可以说这也是一种傲慢，对吧？这个男士他在两性关系上对于女人的想象非常傲慢。我刚才举了两个我觉得在社会上非常常见的例子。状元姐跟我说的这两个人都是相对极端的傲慢。我们可以想象到我们身边肯定会有没有那么极端的，但是持有差不多态度的傲慢态度的人。这种傲慢使我们感到自然而然的愤怒。我觉得我们这个社会解决这种愤怒的方式，通常现在是试图去实行更加全面的平等主义。</p><p>我们拒绝承认任何身份能够给予人在任何层面的优越感，拒绝承认任何人在任何情况下能够在理性基础上产生任何高下之分，拒绝承认我们能够在一切合理的基础上产生合理的优越感。在原则上，我们希望通过这个方法来排除任何人仅仅因为自己拥有过权力或者权威，受过良好的教育，拥有着身高美美貌和浓密的头发，拥有着高薪工作，就可以凌驾于他人之上的这种傲慢。我们希望在原则上可以排除这种人感到优越感的途径，这是一种民主社会的极端平等主义。但是实际上这种极端平等主义在现实生活中它是有点反人性的对吧？</p><p>哪怕我们想在原则上宣称极端的平等主义，没有人能够因为任何身份就高人一等。但是人作为一个社会性的生物，我们在社会上大家都能观察到，自然而然的就会形成身份上的高低之分，这是理论上的平等主义没有办法扭转的人性。人性不但会自然而然的对各种各样的身份进行自然的高低之分，人性还有另外一个特征，那就是我们渴望为了我们自己的一些身份感到骄傲，哪怕我们不想要分一个高下。但是骄傲就意味着我们要做一个区分，我们想要为女性的身份感到骄傲，这就意味着如果有选择，我们不会去做一个男的。如果做男的做女的都一样这样的话，那我们为什么要为做女的感到骄傲呢？</p><p>骄傲意味着你要对你的身份做一种区分，区别就意味着要做一种隐藏的高下之分。只不过现在很多为自己感到骄傲的人，他捂着耳朵，他自欺欺人，他不承认这是一种高下之分。当我们想要为自己中国人的身份感到骄傲的时候，就一定意味着你不想要做美国人。你不能够再为自己是一个中国人感到骄傲的同时你又是一个美国人。这不是一个可以并存的东西，因为骄傲意味着一种区分，你为这种区分感到骄傲，你就不能够再为自己是一个同性恋的身份感到骄傲的同时，又渴望成为一个直男。这两种东西是不能够同时存在的这也就意味着在西方非常流行的这种为了某个身份感到骄傲，它其实就是一种高下之分。</p><p>这是一种在隐藏在平等主义躯壳之下的高下区分。他们拒绝承认自己的这种不自洽，他们想要鱼和熊掌兼得。一方面他们想要呼吁绝对的平等，另外一方面他们又想要为自己感到骄傲。而感到骄傲就必然意味着一种优越感。这是一种你认为你自己所带表的身份背后的价值要高于其他身份，或者说没有身份的一种价值判断。</p><p>所以我在这里说的这个问题在于什么呢？问题就在于我觉得我们过于极端的想要消灭一切身份特权带来的优越感和随之而来的傲慢。我们消灭了旧的身份特权，但是我们并没有解决这个问题。在我的眼中，我觉得我们永远都没有办法解决我们根据身份而自然而然感到的一种由衷的自豪和优越感。这种优越感当他达到了一定的极端之后，它的体现方式就会变成傲慢。消灭了旧的身份特权，我们还会创造新的身份特权。在这里，我想说的是，旧的身份特权和新的身份特权在我眼里并没有理论上的好坏之分，他们都是值得进行公共辩论的。</p><p>我们需要讨论的不是特权应不应该存在，我们要讨论的是特权应该以什么形式存在。什么样的特权是有内在价值的？什么样的特权是不公正的特权？什么样的优越感它是有内在价值的？什么样的优越感它是没有内在价值的优越感。</p><p>比如说我为我是一个中国人感到骄傲、感到自豪这种优越感和我为我是一个有钱人感到骄傲、感到自豪这种优越感，它是明显是有高下之分的。我为我是一个律所合伙投资合伙人感到骄傲、感到自豪，和我为我是一个不婚不育的独立女性感到骄傲、感到自豪，这两种优越感的社会，哪一种是更好的社会？我觉得这是一个很有意思的问题，可能得出来的结论是，这两种优越感都有道理，又都没道理，它背后隐藏的是两种针锋相对的价值判断。我们很难说拥簇一个价值的社会就要好于拥簇另一个价值的社会。我们值得辩论，应该去反思的不是如何去消灭这个优越感本身。</p><p>我觉得我们应该去辩论的是这个优越感背后的价值判断。它究竟是一个好的价值判断，他究竟是不是一个正义的价值判断。一个同性恋该不该因为自己是一个同性恋就感到骄傲了？一个律所合伙人该不该因为自己是一个律所合伙人就感到骄傲了？一个有钱人该不该因为自己是一个有钱人就感到高人一等了，一个不婚不育的女性，该不该因为自己是一个不婚不育的女性就感到高其他区服于父权的结婚生子的妻子一等了？张震该不该因为自己是全中国最性感的男人，就感到高其他男人一等了？</p><p>我觉得我们能做的是更加开放的去讨论这些问题。这些问题背后可能是有答案的。他的这个傲慢或者说优越感背后的价值判断是否合理，而不是把手指直接指向这个优越感和傲慢本身，试图直接把它们抹平。这种抹平本身是一件反人性的事情。</p><p>当然真的去说服我一开始举的那两个例子里面那个傲慢的校友和那个傲慢男人是一件很难的事情。听到他们的故事，从我的角度来说，我感受到的更多的不是愤怒，而是有点可怜他们。我想说，如何在这个社会上减少这种不可一世的傲慢之人，义愤填膺的道德谴责，通常没有办法改变这种人。能够改变这种人的社会态度通常是相对普遍的。对于他们的轻蔑和无视，咱们不和知识上的矮子论短长。</p><p>第二种我想要讲的是更加具体的傲慢。我刚才说的是一个相对广义的社会上的傲慢，它更像是一个人生态度。但是具体的傲慢是一种我们在生活中经常会碰到的，就事论事的高高在上。我们通常会认为傲慢是强者对于弱者的霸凌，导致强者在这个社会中几乎变成了一个贬义词。但是我认为，把强者和弱者之间的关系想象成霸凌，是一种现代文明平等的现代秩序全新的现象。在古典秩序中，强者和弱者之间的关系不是霸凌，强者是弱者的保护者，强者是需要为保护弱者承担责任的人。而且在我的经历中，所有具体的傲慢，他几乎全部都是弱者对于弱者的霸凌，弱者对于更弱的人表现出的高高在上，他们的傲慢展露的不是自己的强大，而是自己的弱小。</p><p>说到这种具体的傲慢，我给大家举一点串在我这个博客中出现的例子。我想专门举一些看似微不足道的案例。比如说我在讲锻炼的那个博客下面，我印象非常清楚的。记得有一次我在那儿说，我说如果你无法做一个俯卧撑的话，你可以选择跪姿俯卧撑。如果做不了跪姿俯卧撑，可以选择靠墙60度斜着做俯卧撑。通过不断的进阶，慢慢的我们就能够达到做俯卧撑的力量。然后再从俯卧撑进阶成更加高阶的。比如说钻石俯卧撑，俯卧撑击掌，结果下面有一位能人志士评论说，如果连一个俯卧撑的力量都没有的话，那确实有点太弱了。</p><p>还有一些同学会在我的博客下留言记录说今天读了刘瑜，有一个什么心得，读了留情，要不就读了韩炳哲，评论一些自己的感悟。每一次都会有人轻蔑的回复，这些回复都被我删了。这些人都会回复说，哲学界的短视频，读这种书说明你还没有深度。还有一些同学最近刚刚读到一个评论，有一个同学参加了道长许知远和鲁豫的线下节目，兴致冲冲的在豆瓣上晒了合照，这个同学给我留言说他配文说自己的五岳文化程度爆表，结果被更傲慢的更有文化的豆瓣网友高高在上的嘲讽，说这就文化了，肤浅。</p><p>这种傲慢的例子我越想越多。我朋友二妹，她是马拉松跑者，她跟我说自己瞎跑的，很开心。一上互联网的朋友圈，充满了各种各样的鄙视链，不管你晒怎么样的配速，都会有人傲慢的跳出来讥讽你的配速在于家圈也能够看到一模一样的情况。在我眼中明明已经练得非常优秀的人，不管晒怎样的瑜伽姿势，下面一定会冒出来一些大师说一年才只能够练手肘倒立水平不行，你这个腰用力不够，推轮才推到这个程度，说明你不够努力。</p><p>我刚才举了这么一大串例子，我就不往下说了。这些小小的案例没有我一开始描绘的这种不可一世的傲慢这么令人愤怒。但是实际上我相信每一个上网的人都经历过我刚才说的，这种傲慢的一种模式。这也是作为一个不是公众人物的普通人，当我们开始思考互联网的恶意和戾气怎么这么重的时候，最影响我们的就是我刚才举例的这些比较微小的傲慢。我刚才说的这种傲慢不是强者对于弱者的霸凌，这种傲慢是弱者对于弱者的霸凌。我每次看到这种人，大家知道我在想什么吗？我就在想到孟德斯鸠写那个波斯姓扎那个小说里，他描绘一个在波斯拥有着后宫三千佳丽3000的波斯人来巴黎旅游的故事。</p><p>这个小说主要是孟德斯鸠借着波斯人的视角在嘲讽巴黎，但是他其中有一段很重要的剧情，就是在描绘这个被留在波斯管理后宫佳丽3000的那些个被阉过的波斯太监。孟德斯鸠描绘这些太监非常犀利，这些太监个个都渴望权力，但是他们渴望权力的目的仅仅是为了成为大太监。管事的太监能够骑在其他的小太监头上，骑在其他小太监头上就是权力对于这些人的诱惑，那些个太监拥有了权利，他们不想要真正的去执行权力管理后宫，成为一家之主，他就是想骑在别人头上。</p><p>我举了刚才这些个嘲笑别人的例子。我看到那些嘲笑别人的人，一看到那些人我就会想到波斯信扎里面的太监。为什么呢？我觉得这种傲慢，这种高高在上，他之所以是最平常的，又是最可笑的。是因为拥有这些态度的人，他们忘记了自己为什么喜欢这个东西，自己为什么享受做这些事情，为什么喜欢跑步，为什么喜欢瑜伽，为什么喜欢读书，为什么喜欢思考。你做这些事情的原因不是因为你能够做的比别人好，而是因为这件事情它本身是一件令人愉悦的事情，它是一件好事。你的愉悦感不是来自于你能够骑在别人头上，成为一个管事太监，这是一种通过残忍才能够获得的愉悦感。愉悦感的来源应该是来自于你做这件事情可以做得更好，你可以跑得更快，你可以通过一些简单的反思，从而去进行更加深刻的反思。</p><p>只有孟德斯鸠书里的那些太监，因为他们被淹了，没有办法再体会到真正的欲望，真正的野心，他们的自然，他们的人性已经变态了，他们的梦想才会变成成为大太监，骑在小太监头上，从一些本末倒置的事情上得到快感。而且就做好一件事情来说，咱们谁不是一个小虾米。咱们退一步来看，有多少人喜欢跑，不喜欢读书，喜欢思考非常少。</p><p>你带着傲慢的态度去嘲笑其他做的没你好的人，跑的没你快，没有你读的深度的人，没你逻辑缜密的人。这个态度本身体现的是一个最可耻的以残忍为乐的弱者心态。我鄙视这种人的原因，不但是因为他们在嘲笑比他们更弱小的人，并且从这种残忍中获得快感，而且最主要的是他们正在损伤一件在我心中本身可能很有意义的事情，他让其他人不再享受做这件事情了。我在读武侠小说的时候也发现了这个事儿，那就是最傲慢、最不可一世、最有力气，最喜欢霸凌弱者的人，从来都不是真正的大侠，最喜欢霸凌弱弱者的，都是那种比弱者稍微强了那么一点点的弱者。我们应该联合起来，鄙视那些嘲笑弱者的弱者，这种想骑在其他人头上的太监这种人，他们不是强者，他们的傲慢恰恰反映了他们的弱小，因为他们的傲慢是建立在对于他人的残忍之上的，而不是建立在对于更高、更快、更强的渴望之上。</p><p>说到这里，大家也应该听得出来，我这个播客叽里呱啦讲了这么多，并不是在维护虚伪和傲慢。我不是在试图说服大家，傲慢是一件好事儿，虚伪也是一件好事儿。我想说的是，虚伪和傲慢都是人性中平常的一部分。当我们在高声要求别人停止虚伪，停止傲慢的时候，其实我们自己很难躲避同样的指控。我也有我自己的虚伪和傲慢。</p><h1 id="如何抵抗互联网上越来越重的戾气和恶意"><a href="#如何抵抗互联网上越来越重的戾气和恶意" class="headerlink" title="如何抵抗互联网上越来越重的戾气和恶意"></a>如何抵抗互联网上越来越重的戾气和恶意</h1><p>关于我播客一开始提出的这个问题，如何抵抗互联网上越来越重的戾气和恶意？我觉得我们自己能做的一件事儿，第一件最重要的事儿就是意识到咱们自己也不是个好鸟。虚伪不意味着你是一个两面三刀的小人，傲慢也不意味着你是一个令人鄙夷的狂徒。虚伪和傲慢意味着你是一个人，而意识到这一点，意识到这些不好的品质有多么普通，在每个人身上都可能会出现。可以让我们对他人不要这么残忍，也可以让我们在思想上更加自由。</p><p>我想说的另外一件事情就是你可能会说，这个博客把一个这么简单的事情说的这么复杂。这个博客把一个看似很简单的事情说得很复杂。没错，这也是我的目的之一。我想说的是有一些社会上需要达到共识的话题，随着它的复杂化，它反而会变得更加清晰。这是一种和笛卡尔创建的现代科学相反的人文主义思维。笛卡尔创造的现代科学信奉的是随着事情变得越来越简单，它会变得越来越清晰。 笛卡尔的第一沉思录里说的是clarity和simplicity，简单和清晰是一对相辅相成的东西。但是我认为在社会上需要达到共识的问题上，他遵守的规则是和科学规则恰恰相反的。随着它变得越来越复杂，随着我们能够意识到人性的复杂性，complexity和clarity才是一对。随着我们能够意识到人性的复杂性，人性会变得越来越清晰，我们也会变得越来越温和，越来越不那么偏激。OK今天咱们就说到这儿，我们下期再见吧，拜拜。</p>]]></content>
      
    </entry>
    
    
  
</search>
