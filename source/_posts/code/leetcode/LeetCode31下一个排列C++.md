---
title: LeetCode31下一个排列C++
date: 2025-03-15 22:00:50
categories:
  - 力扣
tags:
  - 力扣
  - 代码
  - CPP
mathjax: true
---
# **问题描述**

整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须原地修改，只允许使用额外常数空间。

**示例 1：**
**输入：**``nums = [1,3,4,2,2]``
**输出：**2

**示例 2：**
**输入：**``nums = [3,1,3,4,2]``
**输出：**3

**示例 3 :**
**输入：**``nums = [3,3,3,3,3]``
**输出：**3

# **解法**
**首先，我们来说下一个排列是什么意思：**
下一个排列 本质上是在 当前排列的基础上寻找比它稍大一点的排列。如果 `nums` 已经是字典序最大的排列，那么 直接变成最小的排列
当前排列：
```cpp
nums = [1,2,3,6,5,4]
```
后面所有可能的排列（按字典序排列）：
```
1,2,4,3,5,6← 目标（下一个排列）
1,2,4,3,6,5  
1,2,4,5,3,6
1,2,4,5,6,3
1,2,5,3,4,6
```



**接下来我们看如何解决这道题，分两种情况讨论**
1. 当前的排列是字典序最大的：直接翻转排列，这样就变成了最小的
2. 当前的排列不是字典序最大的：观察``1,2,3,6,5,4->1,2,3,4,5,6``，我们要找到下一个最大的，我们会找到3，因为``3<4``。然后我们会在``6,5,4``中找最小的来与3交换，此时变成``1,2,4,6,5,3``。4后面的肯定要升序摆放，于是就变成``1,2,4,3,5,6``。所以可以得到步骤：
	1. 从后向前找“下降点”：找到 `nums[i] < nums[i+1]` 的 `i`。
	2. 在 `i` 右侧找到比 `nums[i]` 大的最小值，交换两者。
	3. 将 `i` 右侧的元素翻转，变成最小的排列（升序）。


# **代码实现**

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int i = n - 2;
 
        // 步骤 1：找到第一个下降点
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        //步骤2：在i右侧找到比 nums[i] 大的最小元素(注意i右侧一定是降序排布)
        if (i >= 0) {
            int j = n - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums[j], nums[i]);
        }
        // 步骤 3：将 i 右侧的元素翻转，使其成为最小排列
        reverse(nums.begin() + i + 1, nums.end());

    }
};
```

