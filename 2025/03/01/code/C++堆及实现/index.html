<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++堆及实现，priority_queue | 森林</title><meta name="author" content="Ouyiz"><meta name="copyright" content="Ouyiz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[!NOTE]以下内容为Chatgpt生成后整理  堆（Heap）是一种特殊的树形数据结构，通常用来实现优先队列、排序算法等功能。堆是一种完全二叉树，它满足特定的顺序性质。我们可以分为最大堆和最小堆两种。 1. 堆的定义堆是一个完全二叉树，其节点满足堆的性质：  最大堆（Max Heap）：每个父节点的值大于或等于其子节点的值，即根节点是树中的最大值。 最小堆（Min Heap）：每个父节点的值">
<meta property="og:type" content="article">
<meta property="og:title" content="C++堆及实现，priority_queue">
<meta property="og:url" content="https://ouyiz.github.io/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="森林">
<meta property="og:description" content="[!NOTE]以下内容为Chatgpt生成后整理  堆（Heap）是一种特殊的树形数据结构，通常用来实现优先队列、排序算法等功能。堆是一种完全二叉树，它满足特定的顺序性质。我们可以分为最大堆和最小堆两种。 1. 堆的定义堆是一个完全二叉树，其节点满足堆的性质：  最大堆（Max Heap）：每个父节点的值大于或等于其子节点的值，即根节点是树中的最大值。 最小堆（Min Heap）：每个父节点的值">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ouyiz.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-03-01T07:16:00.000Z">
<meta property="article:modified_time" content="2025-03-11T06:20:08.349Z">
<meta property="article:author" content="Ouyiz">
<meta property="article:tag" content="堆">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ouyiz.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++堆及实现，priority_queue",
  "url": "https://ouyiz.github.io/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/",
  "image": "https://ouyiz.github.io/img/avatar.jpg",
  "datePublished": "2025-03-01T07:16:00.000Z",
  "dateModified": "2025-03-11T06:20:08.349Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ouyiz",
      "url": "https://ouyiz.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/ico.png"><link rel="canonical" href="https://ouyiz.github.io/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":3,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++堆及实现，priority_queue',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/podcasts/"><i class="fa-fw fas fa-podcast"></i><span> 播客</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">森林</span></a><a class="nav-page-title" href="/"><span class="site-name">C++堆及实现，priority_queue</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/podcasts/"><i class="fa-fw fas fa-podcast"></i><span> 播客</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++堆及实现，priority_queue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-01T07:16:00.000Z" title="发表于 2025-03-01 15:16:00">2025-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T06:20:08.349Z" title="更新于 2025-03-11 14:20:08">2025-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>[!NOTE]<br>以下内容为Chatgpt生成后整理</p>
</blockquote>
<p>堆（Heap）是一种特殊的树形数据结构，通常用来实现优先队列、排序算法等功能。堆是一种完全二叉树，它满足特定的顺序性质。我们可以分为最大堆和最小堆两种。</p>
<h3 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h3><p>堆是一个完全二叉树，其节点满足堆的性质：</p>
<ul>
<li><strong>最大堆（Max Heap）</strong>：每个父节点的值大于或等于其子节点的值，即根节点是树中的最大值。</li>
<li><strong>最小堆（Min Heap）</strong>：每个父节点的值小于或等于其子节点的值，即根节点是树中的最小值。</li>
</ul>
<p>堆的特点：</p>
<ul>
<li><strong>完全二叉树</strong>：除了最底层外，其他层的节点都是满的，最底层的节点从左到右排列。完全二叉树的结构保证了堆的高效性。</li>
<li><strong>堆的顺序性质</strong>：堆中任意节点的值与其子节点的值有顺序关系，最大堆的父节点值大于子节点，而最小堆则相反。</li>
</ul>
<h3 id="2-堆的基本操作"><a href="#2-堆的基本操作" class="headerlink" title="2. 堆的基本操作"></a>2. 堆的基本操作</h3><p>堆主要支持以下几种基本操作：</p>
<ol>
<li><strong>插入元素（Insert）</strong>：<ul>
<li>在堆的末尾插入一个新元素，并通过“上浮”操作将其放到正确的位置，以保持堆的顺序性质。</li>
<li>上浮操作：如果新插入的元素比父节点大（最大堆）或小（最小堆），则与父节点交换位置，直到堆顺序性质被恢复。交换不会破环堆得性质，不需要堆化，因为父节点得值大于所有得子节点。</li>
</ul>
</li>
<li><strong>删除根节点（Delete）</strong>：<ul>
<li>删除堆的根节点，并将堆的最后一个元素放到根位置。然后通过“下沉”操作将其放到正确的位置，以恢复堆的顺序性质。</li>
<li>下沉操作：将根节点与其子节点中较大的（最大堆）或较小的（最小堆）子节点交换，直到堆顺序性质被恢复。需要使用堆化。</li>
</ul>
</li>
<li><strong>堆化（Heapify）</strong>：<ul>
<li>堆化是将一个无序数组转换成一个堆结构。它的过程是从数组的最后一个非叶子节点开始，逐步执行“下沉”操作，直到堆顺序性质得到恢复。</li>
</ul>
</li>
<li><strong>获取最大（最小）元素</strong>：<ul>
<li>在最大堆中，根节点存储着最大元素；在最小堆中，根节点存储着最小元素。这个操作的时间复杂度是O(1)。<h3 id="3-堆的应用"><a href="#3-堆的应用" class="headerlink" title="3. 堆的应用"></a>3. 堆的应用</h3></li>
</ul>
</li>
</ol>
<p>堆广泛应用于以下场景：</p>
<ul>
<li><strong>优先队列</strong>：堆可以用来实现优先队列，保证插入和删除操作都能按照优先级进行。</li>
<li><p><strong>堆排序（Heap Sort）</strong>：利用堆的性质，可以对元素进行排序。首先将元素插入堆中，然后逐个删除根节点，即得到一个有序序列。</p>
<h3 id="4-堆的时间复杂度"><a href="#4-堆的时间复杂度" class="headerlink" title="4. 堆的时间复杂度"></a>4. 堆的时间复杂度</h3></li>
<li><p><strong>插入操作</strong>：O(log n)，插入元素后最多需要上浮h层，所有为O(log n)</p>
</li>
<li><strong>删除根节点操作</strong>：O(log n)，删除根节点后需要执行下沉操作，也需要log(n)次比较和交换。</li>
<li><strong>堆化操作</strong>：O(n)，从最后一个非叶子节点开始执行下沉操作，整体的时间复杂度是O(n)。</li>
</ul>
<blockquote>
<p>[!NOTE] 堆得高度为什么是O(log n)<br>对一棵完全二叉树，<br><strong>第 0 层</strong>（根节点）有 1 个结点。<br><strong>第 1 层</strong> 有 2个结点。<br><strong>第 2 层</strong> 有 4个结点。<br><strong>第 h 层</strong> 最多有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g></g></g></svg></mjx-container> 个结点。<br>因此，<strong>最多的总结点数</strong>：1+2+4+⋯+<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g></g></g></svg></mjx-container>=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.24ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 990.3 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g></g></g></svg></mjx-container>+1−1<br>设堆的结点总数为 n，则：n≤<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.285ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 1894 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container>-1<br>    n+1≤<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.285ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 1894 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1354,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container><br>    <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.894ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4815 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mn" transform="translate(1311,-241.4) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2103.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2925.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3926,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4426,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>≤h+1<br>    h≥ <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.168ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6704.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mn" transform="translate(1311,-241.4) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1714.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1881.2,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1211.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2211.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2711.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mo" transform="translate(5203.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6204.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container><br>    h=O(log n)</p>
</blockquote>
<h3 id="5-堆的实现"><a href="#5-堆的实现" class="headerlink" title="5. 堆的实现"></a>5. 堆的实现</h3><p>堆通常用数组来实现，因为完全二叉树的结构适合用数组来表示：</p>
<ul>
<li>数组中下标为 <code>i</code> 的元素的左子节点在下标 <code>2*i + 1</code>，右子节点在下标 <code>2*i + 2</code>，父节点则在下标 <code>(i-1) / 2</code>。<br><strong>代码：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;  <span class="comment">// 使用vector存储堆元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆化操作，从下标i开始，调整堆。（加上left(i)与right(i)都是最大堆）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="type">int</span> largest = i;           <span class="comment">// 假设当前节点是最大值</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;      <span class="comment">// 左子节点下标</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;     <span class="comment">// 右子节点下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子节点比当前节点大，更新largest</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n &amp;&amp; heap[left] &gt; heap[largest]) {</span><br><span class="line">            largest = left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右子节点比当前节点大，更新largest</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp; heap[right] &gt; heap[largest]) {</span><br><span class="line">            largest = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果largest不等于i，说明需要交换</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) {</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[largest]);</span><br><span class="line">            <span class="built_in">heapify</span>(largest, n);  <span class="comment">// 递归调整下去</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);  <span class="comment">// 将新元素插入到堆的末尾</span></span><br><span class="line">        <span class="type">int</span> i = heap.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 上浮操作：如果新插入的元素比父节点大，则交换</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; heap[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; heap[i]) {</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 更新i为父节点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆顶元素（根节点）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteRoot</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">size</span>() == <span class="number">0</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"Heap is empty!"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将堆的最后一个元素移动到根节点</span></span><br><span class="line">        heap[<span class="number">0</span>] = heap.<span class="built_in">back</span>();</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 调整堆，使其重新满足堆的性质</span></span><br><span class="line">        <span class="built_in">heapify</span>(<span class="number">0</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆操作，调整整个数组为一个堆，以为最后一个结点的父节点为(n-2)/2,也就是n/2-1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，进行堆化操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="built_in">heapify</span>(i, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印堆的元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printHeap</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : heap) {</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取堆顶元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRoot</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="string">"Heap is empty!"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 返回一个无效值</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MaxHeap maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    maxHeap.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after insertion: "</span>;</span><br><span class="line">    maxHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆顶元素</span></span><br><span class="line">    maxHeap.<span class="built_in">deleteRoot</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after deleting root: "</span>;</span><br><span class="line">    maxHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆操作</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = {<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>};</span><br><span class="line">    MaxHeap customHeap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : arr) {</span><br><span class="line">        customHeap.<span class="built_in">insert</span>(val);</span><br><span class="line">    }</span><br><span class="line">    customHeap.<span class="built_in">buildHeap</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"Heap after building from array: "</span>;</span><br><span class="line">    customHeap.<span class="built_in">printHeap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6.priority_queue"></a>6.priority_queue</h3><p><code>priority_queue</code> 是 C++ 标准库中的 <strong>优先队列</strong>，底层通常由 <strong>堆（heap）</strong> 实现。默认情况下，它是一个 <strong>最大堆</strong>（大顶堆），即 <strong>每次取出的元素都是当前最大的</strong>。如果想要最小堆（小顶堆），需要进行一些特殊处理。</p>
<h6 id="1-priority-queue-的基本用法"><a href="#1-priority-queue-的基本用法" class="headerlink" title="1.priority_queue 的基本用法"></a><strong>1.<code>priority_queue</code> 的基本用法</strong></h6><p> <strong>头文件</strong><br><code>priority_queue</code> 需要包含 <code>&lt;queue&gt;</code> 头文件：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>定义 <code>priority_queue</code></strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;  <span class="comment">// 默认是最大堆（大顶堆）</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;, </span><br><span class="line">          <span class="keyword">class</span> Compare = std::less&lt;<span class="keyword">typename</span> Container::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>队列中存储的元素类型</td>
</tr>
<tr>
<td><code>Container</code></td>
<td>存储数据的底层容器，默认是 <code>std::vector&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>Compare</code></td>
<td>比较器，默认是 <code>std::less&lt;T&gt;</code>（大顶堆）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>常用操作</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(x)</code></td>
<td>插入元素 <code>x</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>删除堆顶元素</td>
</tr>
<tr>
<td><code>top()</code></td>
<td>返回堆顶元素</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
</tr>
</tbody>
</table>
</div>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"堆顶元素: "</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 5（最大值）</span></span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">pop</span>();  <span class="comment">// 删除 5</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"新的堆顶元素: "</span> &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆顶元素: 5</span><br><span class="line">新的堆顶元素: 4</span><br></pre></td></tr></table></figure></p>
<hr>
<h6 id="2-小顶堆（最小堆）"><a href="#2-小顶堆（最小堆）" class="headerlink" title="2. 小顶堆（最小堆）"></a><strong>2. 小顶堆（最小堆）</strong></h6><p>默认情况下，<code>priority_queue</code> 是 <strong>最大堆</strong>，如果需要 <strong>最小堆</strong>，可以使用 <strong><code>std::greater&lt;T&gt;</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"堆顶元素: "</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 1（最小值）</span></span><br><span class="line"></span><br><span class="line">    minHeap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"新的堆顶元素: "</span> &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆顶元素: 1</span><br><span class="line">新的堆顶元素: 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!NOTE] <strong><code>std::greater&lt;T&gt;</code>std::greater<t><code>是 C++ 标准库</code><functional>` 头文件中的一个</functional></t></strong>函数对象（仿函数）<strong>，用于 </strong>比较两个值的大小<strong>，它的作用是</strong>定义”大于”（&gt;`）的比较规则**。</p>
</blockquote>
<hr>
<h6 id="3-存储-pair（结构体、对象）"><a href="#3-存储-pair（结构体、对象）" class="headerlink" title="3. 存储 pair（结构体、对象）"></a><strong>3. 存储 <code>pair</code>（结构体、对象）</strong></h6><p>有时，我们需要让 <code>priority_queue</code> 存储 <strong>更复杂的数据类型</strong>，例如 <code>pair&lt;int, int&gt;</code>，可以通过 <strong>自定义比较方式</strong> 来决定排序规则。</p>
<p><strong>(1)按第一个元素降序（默认）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure>
<p>这样 <code>pair&lt;int, int&gt;</code> <strong>会按第一个元素降序排列</strong>，也就是最大堆。<br>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">5</span>, <span class="number">200</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">4</span>, <span class="number">400</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><br><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(5, 200)</span><br><span class="line">(4, 400)</span><br><span class="line">(3, 100)</span><br><span class="line">(1, 300)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>(2) 按第一个元素升序（小顶堆）</strong></p>
<p>如果希望 <strong>按 <code>pair</code> 的第一个元素升序排列</strong>，可以使用 <code>std::greater&lt;&gt;</code>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">5</span>, <span class="number">200</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">4</span>, <span class="number">400</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p> <strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1, 300)</span><br><span class="line">(3, 100)</span><br><span class="line">(4, 400)</span><br><span class="line">(5, 200)</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="4-自定义比较函数"><a href="#4-自定义比较函数" class="headerlink" title="4. 自定义比较函数"></a><strong>4. 自定义比较函数</strong></h6><p>如果需要更复杂的排序规则（如按照 <code>pair.second</code> 排序），可以使用 <strong>lambda 表达式或函数对象</strong>。</p>
<p> <strong>(1) 使用 <code>lambda</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">};</span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">1</span>, <span class="number">300</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">2</span>, <span class="number">100</span>});</span><br><span class="line">    pq.<span class="built_in">push</span>({<span class="number">3</span>, <span class="number">200</span>});</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"("</span> &lt;&lt; p.first &lt;&lt; <span class="string">", "</span> &lt;&lt; p.second &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2, 100)</span><br><span class="line">(3, 200)</span><br><span class="line">(1, 300)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>(2) 使用 <code>struct</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> {</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 按 second 升序排列</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, Compare&gt; pq;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="5-priority-queue-时间复杂度"><a href="#5-priority-queue-时间复杂度" class="headerlink" title="5. priority_queue 时间复杂度"></a><strong>5. <code>priority_queue</code> 时间复杂度</strong></h6><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入 (<code>push</code>)</td>
<td>O(log⁡n)</td>
</tr>
<tr>
<td>取堆顶 (<code>top</code>)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除堆顶 (<code>pop</code>)</td>
<td>O(log⁡n)</td>
</tr>
</tbody>
</table>
</div>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81/">代码</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/26/code/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/" title="LeetCode二分查找专题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">LeetCode二分查找专题</div></div><div class="info-2"><div class="info-item-1">基础知识二分查找是一种在有序数组中查找特定元素的算法，它通过不断将搜索区间减半来快速定位目标元素。对于搜索区间的定义有三种方式，分别是左闭右闭，左闭右开和左开右开。  这三者之间的主要区别在于以下两点(1)每次折半的时候两端的坐标应该移到mid的位置上还是多偏移一个元素(2)while判断结束的条件是 left&lt;right,left&lt;=right,还是left&lt;right-1    left和right的偏移区别 ...</div></div></div></a><a class="pagination-related" href="/2025/03/06/code/C++%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/" title="C++自定义排序方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++自定义排序方式</div></div><div class="info-2"><div class="info-item-1"> [!NOTE]以下内容为Chatgpt生成后整理  在 C++ 中，自定义比较函数（通常是一个函数或者函数对象）和仿函数（函数对象）都可以用于自定义排序规则或比较方式，但它们的实现方式和使用方法有所不同。 1. 自定义比较函数自定义比较函数是指一个普通的函数，它用于定义如何比较两个对象。通常，这个函数有两个参数，返回值是一个布尔值，表示这两个对象之间的比较结果。 特点： 形式：自定义比较函数通常是一个独立的普通函数。 使用方式：它可以作为参数传递给排序算法（如 std::sort）或数据结构（如 std::priority_queue）等，定义对象的排序或比较规则。 返回类型：一般返回一个 bool 类型，表示是否满足某种条件（例如：a &lt; b，返回 true 表示 a 小于 b）。  示例：#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 自定义比较函数bool compare(int a, int b) {   ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/06/code/C++%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/" title="C++自定义排序方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-06</div><div class="info-item-2">C++自定义排序方式</div></div><div class="info-2"><div class="info-item-1"> [!NOTE]以下内容为Chatgpt生成后整理  在 C++ 中，自定义比较函数（通常是一个函数或者函数对象）和仿函数（函数对象）都可以用于自定义排序规则或比较方式，但它们的实现方式和使用方法有所不同。 1. 自定义比较函数自定义比较函数是指一个普通的函数，它用于定义如何比较两个对象。通常，这个函数有两个参数，返回值是一个布尔值，表示这两个对象之间的比较结果。 特点： 形式：自定义比较函数通常是一个独立的普通函数。 使用方式：它可以作为参数传递给排序算法（如 std::sort）或数据结构（如 std::priority_queue）等，定义对象的排序或比较规则。 返回类型：一般返回一个 bool 类型，表示是否满足某种条件（例如：a &lt; b，返回 true 表示 a 小于 b）。  示例：#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;// 自定义比较函数bool compare(int a, int b) {   ...</div></div></div></a><a class="pagination-related" href="/2025/03/10/code/C++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/" title="C++重载运算符"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="info-item-2">C++重载运算符</div></div><div class="info-2"><div class="info-item-1"> [!NOTE]以下内容为Chatgpt生成后整理  1. 基本概念(1)什么是运算符重载？运算符重载（Operator Overloading）允许我们为已有的运算符（如 +、-、*、== 等）定义新的行为，以便这些运算符能够处理我们自定义的类型（如类）。换句话说，运算符重载让运算符能够支持自定义类的对象，使得这些对象在运算符使用时像内置数据类型一样工作。 (2)为什么需要运算符重载？运算符重载能够让我们：  提高代码的可读性和可维护性。 让自定义类的对象可以使用常见的运算符，方便直接参与运算。  例如，考虑两个 Complex 类对象相加，如果没有运算符重载，我们可能需要调用复杂的成员函数来完成加法操作，而运算符重载可以让加法操作变得简洁直观。  C++ 允许重载的大部分运算符 不能重载的运算符： ::（作用域解析符） .*（成员指针访问运算符） .（成员访问运算符） sizeof（求大小） typeid（运行时类型识别）     2. 重载运算符的方式 作为成员函数（operator+、operator==...</div></div></div></a><a class="pagination-related" href="/2025/03/11/code/leetcode/LeetCode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97C/" title="LeetCode136只出现一次的数字C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">LeetCode136只出现一次的数字C++</div></div><div class="info-2"><div class="info-item-1">题目描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须在线性时间复杂度（O(n)）和常数额外空间（O(1)）的限制下完成这个问题。   示例 1： 输入: nums = [2,2,1]输出: 1  示例 2： 输入: nums = [4,1,2,1,2]输出: 4  示例 3： 输入: nums = [1]输出: 1  解法题目要求 O(n) 时间复杂度和 O(1) 空间复杂度，我们可以使用 异或（XOR）运算 来解决。  异或运算性质  a ⊕ a = 0（任何数和自己异或结果为 0） a ⊕ 0 = a（任何数和 0 异或不变） a ⊕ b ⊕ c = a ⊕ c ⊕ b（异或运算满足交换律和结合律）  由于数组中除了一个数出现 1 次，其余的数都出现 2 次，那么所有数字进行异或运算后：  成对出现的数会互相抵消变成 0 最终只剩下那个只出现一次的数   C++ 代码class Solution {public:    int singleNumber(vector&lt;int&gt;&amp;...</div></div></div></a><a class="pagination-related" href="/2025/03/11/code/leetcode/LeetCode169%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" title="leetcode169多数元素"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">leetcode169多数元素</div></div><div class="info-2"><div class="info-item-1">题目描述给定一个大小为 n 的数组 nums，找出其中出现次数超过 ⌊ n/2 ⌋ 的元素。 你可以假设数组总是存在多数元素。  示例 示例 1： 输入: nums = [3,2,3]输出: 3 示例 2： 输入: nums = [2,2,1,1,1,2,2]输出: 2  进阶要求  你能在时间复杂度 O(n)、空间复杂度 O(1) 的条件下完成算法吗？   解法 1：哈希表（map 计数）思路 我们可以使用哈希表（unordered_map）统计每个元素出现的次数，然后找到出现次数超过 ⌊ n/2 ⌋ 的元素。 代码 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;class Solution {public:int majorityElement(vector&lt;int&gt;&amp; nums) {    unordered_map&lt;int, int&gt; count;    int n =...</div></div></div></a><a class="pagination-related" href="/2025/02/26/code/leetcode/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/" title="LeetCode二分查找专题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">LeetCode二分查找专题</div></div><div class="info-2"><div class="info-item-1">基础知识二分查找是一种在有序数组中查找特定元素的算法，它通过不断将搜索区间减半来快速定位目标元素。对于搜索区间的定义有三种方式，分别是左闭右闭，左闭右开和左开右开。  这三者之间的主要区别在于以下两点(1)每次折半的时候两端的坐标应该移到mid的位置上还是多偏移一个元素(2)while判断结束的条件是 left&lt;right,left&lt;=right,还是left&lt;right-1    left和right的偏移区别 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ouyiz</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ouyiz"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ouyiz" target="_blank" title=""><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">祝你有更好的生活</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 堆的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 堆的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">3. 堆的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">4. 堆的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 堆的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-priority-queue"><span class="toc-text">6.priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-priority-queue-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">1.priority_queue 的基本用法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%88%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%89"><span class="toc-text">2. 小顶堆（最小堆）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8-pair%EF%BC%88%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-text">3. 存储 pair（结构体、对象）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-text">4. 自定义比较函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-priority-queue-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">5. priority_queue 时间复杂度</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/code/leetcode/LeetCode169%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" title="leetcode169多数元素">leetcode169多数元素</a><time datetime="2025-03-11T06:12:09.000Z" title="发表于 2025-03-11 14:12:09">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/code/leetcode/LeetCode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97C/" title="LeetCode136只出现一次的数字C++">LeetCode136只出现一次的数字C++</a><time datetime="2025-03-11T05:56:53.000Z" title="发表于 2025-03-11 13:56:53">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/code/C++%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/" title="C++重载运算符">C++重载运算符</a><time datetime="2025-03-10T14:00:00.000Z" title="发表于 2025-03-10 22:00:00">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/06/code/C++%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F/" title="C++自定义排序方式">C++自定义排序方式</a><time datetime="2025-03-06T08:00:00.000Z" title="发表于 2025-03-06 16:00:00">2025-03-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/01/code/C++%E5%A0%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" title="C++堆及实现，priority_queue">C++堆及实现，priority_queue</a><time datetime="2025-03-01T07:16:00.000Z" title="发表于 2025-03-01 15:16:00">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ouyiz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>